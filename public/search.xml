<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>双重思想（转载）</title>
      <link href="sui-bi/shuang-chong-si-xiang-zhuan-zai/"/>
      <url>sui-bi/shuang-chong-si-xiang-zhuan-zai/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一遍非常详细的解释双重思想定义的文章</p><p>From : <a href="https://yonglezh.github.io/2017/01/21/doublethink/">https://yonglezh.github.io/2017/01/21/doublethink/</a></p></blockquote><p>大概2011年的时候，读了《1984》，对书中提到的“双重思想”很感兴趣，却一直觉得不能彻底理解。</p><p>书中定义双重思想为“一个人的脑子里同时具有两种相互矛盾的信念，而且两种都接受。”最初读到这里我非常迷惑：何谓“同时接受矛盾的信念”？人真的可以做到吗？比如，为什么我觉得无法想象自己同时接受地心说和日心说呢？</p><h3 id="澄清定义-“同时接受”带来的误解"><a href="#澄清定义-“同时接受”带来的误解" class="headerlink" title="澄清定义 - “同时接受”带来的误解"></a>澄清定义 - “同时接受”带来的误解</h3><p>有一个非常经典的例子可以用来帮助理解“同时接受矛盾的信念”：母亲和女友同时掉入水中，且两人都不会游泳，你会救哪一个？</p><p>很多人会选择在面对母亲的时候说救母亲、面对女友的时候说救女友，但同时面对母亲和女友两人的时候就不知该如何回答了。</p><p>所以人是没法同时按照两种相互矛盾的信念来行为的。那么，这是说没有“双重思想”这种东西吗？</p><p>不，书中描述的双重思想还是存在的，但是其定义中的“同时接受”却容易造成误解。“同时”指的是“两种想法同时存在在脑中”，但并非指“两种想法同时表现于意识的表层并指导此人的行为”。</p><p>Wikipedia上对于双重思想的定义在《1984》书中原句的基础上增加了一个描述，跟我的理解很相似：</p><blockquote><p>Doublethink is the act of simultaneously accepting two mutually contradictory beliefs as correct, often <strong>in distinct social contexts</strong>.</p></blockquote><p>这个定义特别指出了双重思想是指“<strong>在不同的情景下</strong>接受矛盾的信念”。</p><p>牛津英语字典（The Oxford Companion to the English Language）中对于双重思想的解释也着重说明了这一点：</p><blockquote><p>The term is widely used to describe a capacity to engage in one line of thought in one situation (at work, in a certain group, in business, etc.) and another line in another situation (at home, in another group, in private life), without necessarily sensing any conflict between the two.</p></blockquote><p>那么，这就是双重思想的全部了么？只要我面对母亲的时候相信该救母亲、面对女友的时候相信该救女友，就是双重思想了么？</p><h3 id="双重思想到底是什么？"><a href="#双重思想到底是什么？" class="headerlink" title="双重思想到底是什么？"></a>双重思想到底是什么？</h3><p>《1984》中对于双重思想的定义作了进一步的解释：</p><blockquote><p>“知与不知，知道全部真实情况而却扯些滴水不漏的谎话，同时持两种互相抵消的观点，明知它们互相矛盾而仍都相信，用逻辑来反逻辑，一边表示拥护道德一边又否定道德，一边相信民主是办不到的一边又相信党是民主的捍卫者，忘掉一切必须忘掉的东西而又在需要的时候想起它来，然后又马上忘掉它，而尤其是，把这样的做法应用到做法本身上面——这可谓绝妙透顶了：有意识地进入无意识，而后又并不意识到你刚才完成的催眠。即使要了解“双重思想”的含义你也得使用双重思想。”</p></blockquote><p>这段话的核心是：</p><ol><li>相信两种互相矛盾的信念。（并非同时，而是脑袋里具备两种互相矛盾的信念。）</li><li>根据情境来切换自己相信的信念。</li><li>忽略矛盾，认为自己当下的信念就是自己一直以来坚持的信念。</li><li>忽略自己在忽略矛盾，忽略自己在不断地切换信念。（意识不到自己按不同情境做了不同的选择 —— 这是明知两个信念存在矛盾却不认为自己的行为有矛盾的关键。）</li></ol><p>依然用经典例子来帮助理解：如果（1、2）一个人面对母亲的时候相信应该救母亲，面对女友的时候相信应该救女友，并且（3）意识不到自己在面对另一个人时的矛盾信念和行为，而且（4）意识不到自己在使用这种思想方法忽略矛盾。这就是双重思想了。</p><h3 id="什么不是双重思想"><a href="#什么不是双重思想" class="headerlink" title="什么不是双重思想"></a>什么不是双重思想</h3><p>仅有（1）、（2）是不够的，（3）的重要性在于：如果一个人面对母亲的时候说应该救母亲，面对女友的时候说应该救女友，但是意识得到自己在两种情况下的矛盾行为，那么这个人并没有双重思想。因为他没有两种相互矛盾的信念，而是只有一个一致的信念：相信应该哄母亲和女友开心。</p><p>《1984》中老大哥的缔造者们正属于此类，他们意识到只有一个唯一不变的目的，那就是权力本身。为了维护权力，在说谎有利的时候说谎、在使用双重思想有利的时候使用双重思想。这并非双重思想！因为他们一直只有一个一致的信念：追求权力。</p><p>仅有（1）、（2）和（3）还是不够的，（4）的重要性在于：即使一个人有在不同情景下矛盾的信念和行为，但是一旦被提醒就意识到了自己的前后矛盾，并且调整自己的信念来化解该矛盾，那么此人也不是双重思想，而仅仅是可以改正的不一致信念。即，仅有“忽略矛盾”是不够的，必须要有“忽略自己在忽略矛盾”。</p><p>（3）“忽略矛盾”和（4）“忽略自己在忽略矛盾”正是双重思想最关键之处，也是《1984》中党用来培养双重思想的特殊训练的重点。</p><h3 id="双重思想是如何造就的"><a href="#双重思想是如何造就的" class="headerlink" title="双重思想是如何造就的"></a>双重思想是如何造就的</h3><ol><li><p>犯罪停止(crimestop)</p><blockquote><p>“犯罪停止(crimestop)的意思就是指在产生任何危险思想之前出于本能地悬崖勒马的能力。这种能力还包括不能理解类比，不能看到逻辑错误，不能正确了解与党的原则不一致的最简单论点、对于任何可以朝异端方向发展的思路感到厌倦、厌恶。总而言之，犯罪停止(crimestop)意味着起保护作用的愚蠢。”</p></blockquote><p>这是训练一个人针对党的观点“忽略矛盾”的能力。</p><p>其实这种不加思考的、对某些观点本能的反感的能力人类本身就具备，如果一个观点让人觉得不舒服（比如被人当面指出错误），即使它逻辑上正确，人情感上也很难接受。反而是依据客观事实的逻辑思考和分析的能力才是需要辛苦训练才能获得的。</p><p>此“犯罪停止”训练，一方面增强人类本身的这种缺点，另一方面确保这种能力应用在党的观点上。</p></li><li><p>黑白(blackwhite)</p><blockquote><p>“这意味着不顾明显事实硬说黑就是白的无耻习惯。用在党员身上，这意味着在党的纪律要求你说黑就是白时，你就有这样自觉的忠诚。但这也意味着相信黑就是白的能力，甚至是知道黑就是白和忘掉过去曾经有过相反认识的能力。”</p></blockquote><p>这是训练针对党的要求“忽略自己在忽略矛盾”的能力。其实无需特意训练，人类本身就具有这种忽略矛盾并厚着脸皮死不承认的能力……人类实在是是个善于欺骗自己的物种。</p><p>所以，即使不经历书中的训练，人也能形成双重思想。只要不鼓励人们学习进行深入客观的思考、形成自己的意见即可。</p></li></ol><h3 id="人的思想可能一致吗"><a href="#人的思想可能一致吗" class="headerlink" title="人的思想可能一致吗"></a>人的思想可能一致吗</h3><p>每个人大概都有在不同情景下思想不一致的时候，意识到这一点并非特别困难的事情：尝试回想一下若干年之前的自己就很容易能发现，现在的自己对很多事物都有了不一样的看法。</p><p>在某一时刻，人只能按照一个信念行动，但同时脑后可能存在着暂时被抛在脑后的与其矛盾的信念。正如同时面对母亲和女友很多人无法提供一个该救谁的答案：人脑可以把矛盾的想法暂时放在脑后，但无法在同一时刻按照两个矛盾的想法行动。</p><p>思想在不同时刻的不一致是无法被消除的。人的思想总是在变化，有的时候是在前进，即随着对事物的理解更深刻，更加接近真理，有的时候是在倒退，就连科学界对于真理的认识也是反反复复螺旋式前进的。</p><p>思想在同一时刻的不一致可能也是很难被消除的。一个人的思想纷繁复杂，可能总有什么矛盾的想法深埋在脑海深处、不到某一特殊的时刻不会被激发出来并被意识到。</p><p>不过，只要意识到自己可能忽略自己思想中的矛盾，并在发现自己的思想存在矛盾时尽量调整，就打破了双重思想最重要的一环。努力发现自己的不一致，尽量避免被自己的本能或情绪蒙蔽，也接受自己与过去的自己的不一致，尽力朝着真理前进。这大概是我们能做的事了罢。</p><h3 id="为什么要避免双重思想"><a href="#为什么要避免双重思想" class="headerlink" title="为什么要避免双重思想"></a>为什么要避免双重思想</h3><p>双重思想的特点是对不一致的忽略和对事实的扭曲，这意味着双重思想是真理的敌人。而对真理的追求大概是人类从历史上习得的最重要的教训之一了。</p><blockquote><p>“When you are studying any matter, or considering any philosophy, ask yourself only what are the facts and what is the truth that the facts bear out. Never let yourself be diverted either by what you wish to believe, or by what you think would have beneficent social effects if it were believed. But look only, and solely, at what are the facts.” – Bertrand Russell - Message to Future Generations</p></blockquote><h3 id="写在文后：双重思想-VS-双重标准"><a href="#写在文后：双重思想-VS-双重标准" class="headerlink" title="写在文后：双重思想 VS. 双重标准"></a>写在文后：双重思想 VS. 双重标准</h3><p>最初写这篇文章的原因之一是在思考双重标准与双重思想有什么区别。</p><p>双重思想的核心是忽略矛盾和忽略自己忽略了矛盾，双重标准的核心是在我者和他者的立场转换时的不一致的态度（倾向于美化自己丑化他人）。</p><p>双重思想的“不同情景”在范围上涵盖（⊃）双重标准的“我者和他者的立场转换”，双重思想的“矛盾”在范围上也涵盖（⊃）双重标准的“不一致的态度”，但双重思想相比于双重标准额外要求“忽略矛盾”和“忽略自己忽略矛盾”。所以双重思想和双重标准其实有重叠之处。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/d/da/Set_intersection.svg" alt="alt text"></p><ol><li>A：双重思想</li><li>B：双重标准</li><li>A∩B：“我者和他者的立场转换”+“不一致的态度”+“忽略矛盾”+“忽略自己忽略矛盾”</li><li>A-A∩B：(“不同情景” - “我者和他者的立场转换”)+(“矛盾” - “不一致的态度”)+“忽略矛盾”+“忽略自己忽略矛盾”</li><li>B-A∩B： “我者和他者的立场转换”+“不一致的态度” - “忽略矛盾” - “忽略自己忽略矛盾”</li></ol><p>前面提到的一个人选择救母亲还是女友的双重思想的例子属于（4）双重思想但非双重标准，因为它不涉及“我者和他者的立场转换”。</p><p>如果一个人，在别人选择救母亲的时候谴责他渣男，在别人选择救女友的时候谴责他不孝，自己选的时候却选什么都觉得自己选得好。这是典型的双重标准，因为存在“我者和他者的立场转换”和“不一致的态度”。</p><p>如果这个人意识得到自己在这件事上的观点前后不一致（不满足“忽略矛盾”）、或者被人提醒后认识到自己的观点前后不一致（不满足“忽略自己在忽略矛盾”），那么这个人的行为就仅仅属于（5）双重标准而非双重思想。</p><p>如果他忽略自己对自己和别人观点不一致，并且即使经人提醒也不承认，那么这个人的行为就属于（3）既是双重标准又是双重思想了。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 1984 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于未来的计划</title>
      <link href="sui-bi/guan-yu-wei-lai-de-ji-hua/"/>
      <url>sui-bi/guan-yu-wei-lai-de-ji-hua/</url>
      
        <content type="html"><![CDATA[<p>　　经过上一次的风波，我需要为自己的未来做一番规划，避免自己再次陷入被动？</p><p>　　宏观来看，我只有一个追求，那就是自由。这是一个很宽泛的概念，叠加上我个人的追求，那具体来看就是自由的探索这个世界，可以是周游世界，也可以是感兴趣的学科领域，不断探索和创造，体验这个过程带来的新奇和乐趣，我想这就是我追求的全部了。只是我并非天之骄子，我的梦想没有翅膀，每前进一步，都需要自己创造条件。</p><p>　　首先需要解决的是，金钱问题；曾经在学校的年代，轻易的相信了，“主要努力提升自己的实力，后面的事情自然是水到渠成，金钱也并不例外。” 这套听起来非常有道理的说辞，诚然从人生的时间尺度，这句话并没有什么不对，当然，如果不对，那人生可就是彻底的被一句话给浪费了，但是这样论断有一个比较大的前提条件就是，这个世界是收敛于“大体公平”的。那么，这个世界是朝着越来越公平合理的方向走吗？这个问题过于宏大，而且还是以时代和地域为前提的，我不保证自己把握住了这个世界的宏观整体走向，但是至少在中国这片土地上，我有我自己的看法和论断：相较于不堪回首的过去，中国显然变得更加公平合理了，但是着眼于未来的发展，中国被自己两千年的厚重历史给束缚住了，无法放开手脚，迈向更合理更好的未来，特别是当发展步入深水区，不能正视科学的发展模式和成果，反而用老套的权威思想去接受和包装来自中国之外的科学发展，那么结果自然就是永远都在学习，永远无法超越和创新。 这是不合理的，就如同父辈通过努力和奋斗积累的财力，试图为自己当下的权力背书，在我看来已经完全滑入了傲慢的陷阱，虽然获得了短暂的余晖，但是终将面对来自未来的审判。所以，我并不认为当下的中国是处于一个足够公平合理的年代，特别是近年来，随着房价的上涨，各种奋斗不如买房，努力不如摸鱼的论调横出不穷，也是对于这种基于机遇和运气获得的成功远远高于奋斗这种现象的反抗。毕竟不是每个人都能在人生的时间尺度上沉得住气，很容易被各种偶然的信息和机遇左右，所以我更愿意称这是一个混沌的时代，不要迷信公平和合理，主要精力除了关注发掘自己的优势之外，还应该关注这个时代的优势，努力让这二者的优势更加契合，而非背道而驰。个人在时代面前永远都是渺小的存在，个人的能力和理想难以抵抗时代大潮，虽然听起来仍然很市侩，但是如果能免除一些不必要的烦恼，也不失为一种曲线救国的方法。在当下，困扰我的就是金钱。</p><p>　　如果有一夜暴富，或者短时间暴富的机会，我想我会毫不犹豫的去实践，接着便开始肆无忌惮的活着，学习，探索，实践。不知道何时开始，自己产生并逐渐坚定了这种想法，我想主要原因是认识到，通过努力和自身实力来获取成功的道路，变得越来越不可行的时候开始吧。不知不觉，我的思想就被这样的现实逐渐异化。愈加觉得这个世界魔幻了起来，比特币BTC这种全无价值的游戏也能称的上投资，连带类似的各种新创造的电子货币也都水涨船高；股票市场中起名跟区块链技术沾边的都可以顺势而起；通过房产获益的大都是凭着无知者无畏的精神吃到了先行者的红利，而且这个红利居然能持续数十年，让所有人为之疯狂；互联网企业堂而皇之的垄断市场，且有愈演愈烈之势，反而还得到司法部门的特别优待；技术外行的包工头居然能哄来顶尖的技术团队，骗得政府投资，竟也能顺利脱身。所有人都是如此的浮躁，如此的焦虑，却又这样的急功近利。投机者总是能占得先机，获得时代的青睐。只是这种方式，我不大认同罢了，除了因为自己本质上不是一名投机者之外，在认知上，我更愿意相信随着时代的发展，那些更富于思考的优秀产品和模式则会脱颖而出，那些粗制滥造的跟随者则会慢慢消亡。尽管我是如此相信合理的企业运作模式应当如此，而我却又口嫌体直的被异化成一个急功近利，希望短时间暴富的投机者。一方面是因为当下的时代，从无到有的过程中，投机者发挥功能上的作用，过程粗犷一点无妨，只要目的仍然是这种结构性的转变；反之，如果目的是从有到更好，那么投机者仍然试图复制曾经的先发优势，那么等待他的自然只有被淘汰的命运；另一方面，我从来没有把金钱当作一个目的，只是当成一种实现自我追求的手段而己。如果自己实现财务自由，我想我早就开始满世界游山玩水去了，不断体验新生活新事物，学习新知识，过自由自在的人生，甚至去探索未知的宇宙。不仅仅是意淫，是真的渴望这样的生活并愿意付诸实践。</p><p>　　那么赚取足够财务自由的资金则是当前首要目的，有2种不同的操作思路，一种是常规且保守的上班，升职加薪，循序渐进，业余时间做点理财的投资，优势是持续有资金入账，不需要担心生活问题，日常的生活也会较为平稳，缺点是，可能需要较长的时间才能实现财务自由，而且常常也会面临暂时的薪酬和能力不能匹配的困境，个人职业发展也并不那么可控；另一种思路则是自己单干创业，缺点很明显就是，打通盈利模式之前，都无任何资金入账，甚至还会亏钱，还存在根本无法盈利的风险，除了技术能力之外，还需要开发管理和沟通相关能力，优点是克服种种可预见或不可预见的困难之后，有比较丰厚的回报，能快速积攒资金，个人发展规划也较为自由。我更倾向于后者，因为无论是个人技术发展，还是综合能力的提升，都会在需求的迫切提升的压力下，得到阶梯式的提升，而且能实现自己专心做技术，不被一些非必须的业务琐事干扰。唯二需要担心的问题是，一方面，自己缺乏坚持下去的信心和勇气，尽管平时自己总潜意识里觉得自己未来肯定能成大事，拥有驾驭更高阶平台的能力，但是自己两面派的特性，当自己无法坐下来思考的时候，自己也是一个彻头彻尾的感性动物，难以看清前路的方向；另一方面，在与父母冲突之前，创业之后没有资金入账，甚至亏钱都可以要父母来买单，但是此役之后，我不能获得没有收入来源之后的资金保障，那么如何生存则成为了一个问题，而且还要面临缺乏资金入账之后，父母本身对我的不齿和鄙视。原本是为自己尊严而战去努力，最后却演变成一开始就可能需要放弃尊严的困境，这无论如何让我都有点难以接受。</p><p>　　仔细想想，这2个问题也并不是那么难以克服，找到了原因，这些问题都会迎刃而解！再则，既然想要做更伟大的项目，困难也更多更大，也是理所当然的事情，否则这种只有好处，没有坏处的事情，岂不是人人都可以做的来。我自认为拥有抓住问题核心的能力，只要倾注足够的思考；编程能力是<strong>硬通货</strong>，何必为自己缺乏资金来源而苦恼呢？虽然创业初期，会时常面临不得不接其他项目来补贴生活和项目的困境，这本身对自己也是一种历练，无论是编程能力和沟通能力，其次，这也正是实现了自己能力和酬劳挂钩的目的，为何临到自己身上的时候，对自己抱有侥幸心理呢？基本上来讲，对自己的编程能力和学习能力还是抱有足够的信心的，前提是需要自己合理规划目标和时间，我已经深受之前急功近利之苦，不仅伤害了自信，还浪费许多时间。再则，相比几年前，自己已经足够成熟，来应对自己的慵懒。毕业之后那段时间，确实深受论文折磨，心态上受到的巨大的损伤，只是因为自己表现的足够上进和优秀，就被委以如此重任，时间也非常不充裕，最后落得一副想尽办法偷懒占便宜的毛病。现在想来，仍然有点为当初没搞清楚自己的心态而感到懊恼。经过去年的锤炼，我更好的认识了自己，也能更好的面对自己，未来相信在自律这方面，也无需太多担心。</p><p>　　那么剩下的问题就是缺乏豁出去的勇气了，认真审视自己，我开始有点儿讨厌自己的畏首畏尾，犹犹豫豫，缺乏决断力这样的事情了。当初决定要考研的我，当初决定要去拉萨的我，都没有现在的迷惘，不敢直视自己的内心，瞻前顾后，不敢面对失败的结果。都是毕业之后一步一步养成的心理习惯，自从决定要留学开始，行动上就一直自欺欺人，理所当然的还没开始就失败了，之后工作上虽然渐有起色，然而那只是战术上的勤奋的结果，心底上还是懊恼自己有做选择的勇气，却没有承担责任的胆量。尽管毕业前夕的事情，让自己的心态有点失衡，但无疑是自己一步一步亲手葬送自己的未来。不能再逃避现实，逃避自己的内心了，承认自己失败，肯定自己的努力。过去的失误，就由现在来弥补，未来才有机会朝着渴望的方向发展。失败的历史无法更改，原因或许只是我一开始就认怂了，那不是我愿意成为的样子，我知道我强大的一面，但是近年来的失落让我无法依仗这份强大的能力，这样看来只是处于一些心态上的原因没有有效利用自己的才能，想来确实有点不应该。我不愿意成为一个随波逐流的人，却偏偏在近几年不断的想要察言观色，不敢去主动尝试，由于害怕失败，陷入自卑的心态，实际执行起来，发现自己其实可以做的很好的，这个时候却又过分自大自满起来，目的只是为了补偿心中的那份自卑心理而已；这样得过且过的心态循环往复到如今。其实，我非常厌恶这样的自己，因为始终无法理性的看待自己的能力，总是情绪化的面对一些人和事，导致自己难以正确的评估自己的能力，对未来的预期总是有偏差；结果行动上变得越来越保守和不敢前进，长远来看对自己的发展造成了很大的限制和伤害。认真付出的我，其实可以把想要做的事情做的很优秀，只是我或是懒散或是害怕失败，不愿意前进，失败的经验也是很好的收获，这个道理我早应该理解了，为何却自私的忽略了这一点呢？想做的有趣的事情仍然很多，我需要勇敢的迈出第一步，后面的事情就交给自己的天赋和努力了，这一点，我还是有那么一点自信的。</p><p>　　除了金钱之外，我还有一个很重要的个人追求不得不提，那就是追逐P.H.D，不知道是本性使然，还是小时候的执念，内心中总是有股对学位的追逐，当偶然间意识到，自己其实无论是性格还是能力，其实都非常适合做科研，只是经常会由于自己心态上的因素和周遭环境的影响，无法坚定自己的想法，经常跑偏。比如说，最近诸多科研人员996，辛苦的科研努力沦为高校政绩，科研追求化为泡影，都比较让人寒心，时常会动摇自己的信念。关于这一点的具体探讨，将在另外一篇讨论高校青年教师和内卷相关话题中再做考察。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权力的意志如何影响我的生活</title>
      <link href="sui-bi/quan-li-de-yi-zhi-ru-he-ying-xiang-wo-de-sheng-huo/"/>
      <url>sui-bi/quan-li-de-yi-zhi-ru-he-ying-xiang-wo-de-sheng-huo/</url>
      
        <content type="html"><![CDATA[<blockquote><p> Maybe I’m a Reprobate</p></blockquote><p>　　每年开年时刻，都希望自己在新的一年能改头换面，越来愈好，今年是牛年，除了盼望自己愈来愈牛之外，经过去年疫情的洗礼，这次多少还带着一点行动来支持自己的追求，为此，自己紧锣密鼓的做了很多事情，很快就得到了相应的报应。</p><p>　　我想，若干年后回首今朝，或许这件事对我懒散的人生来说，是一场重要的转折点，因为发现有些事情，并没有看上去那么轻松，特别是关于家庭伦理这方面的事情，总是暗藏一些难以预见的巨大阻力，阻止我改变自己，尽管我在理论上对这些问题耳熟能详，以为自己能轻松应对，结果却遭遇巨大失败，最后不得不回到最初的状态。</p><p>　　简单来说，在自己逐步想要改变家庭内部那种死气沉沉的努力中，与父母间爆发了激烈的冲突，不仅自己情绪失控，完全没能做到理性的应对这些问题，还留下一个烂摊子，根本无力收场。最后禁不住怀疑自己，我这究竟是在做什么？</p><p>　　现在回想起来，自己最大的误判就是，以为自己能通过讲道理的方式来纠正一些父辈们的陈旧观念。经此一役，我想自己应该再也不会做这样天真的妄想吧！也许，营造出他们希望看到的那份假象，才是性价比最高的事情。</p><blockquote><p>正直诚恳的人，看着别人往错的路上走，出力反对，容易坏了感情。而人精什么言行都不反对，和谁都关系好，别人在错误上栽了，自己拂衣而去，又省力又讨好。Nick Carraway 的父亲是老江湖，教他做后一种人，美其名曰宽容，但父子心照不宣，这是市侩。</p><p>​                                                                            了不起的盖茨比书评</p></blockquote><p>　　我本性即使心直口快，追求真实，却在还没认识到这一点的时候，接受了市侩的压迫。此后便开始了漫长的自我怀疑和自我斗争。常常会想，自己是不是在错误的时候和错误的地点来到这个世界。这样分裂的经历直接导致我成为了一个不折不扣的两面派，结果就是两样好处一处都没有占到，一直跌跌撞撞，犹犹豫豫的活到了今天。</p><p>　　就在不久前，我还坚信，相信自己更重要，就算失败，起码不留遗憾，为自己活过。然后等来了真实的来自父母的谩骂和嘲讽，我才发现自己是如此的脆弱和不堪一击，并不是因为父母的话语多么朴实和偏僻入理；而是自己就算在如此对立的场合，仍然试图想要无视这些情绪，想要沟通和对话，结果事与愿违的结果加深了自己的挫败感，随之而来的就是那些言语的无法弥合伤害。宏观来看，这些问题是源于父母的认知水平无法匹配与生俱来的权威和尊严，即德不配位，或者称作识不配位更准确一点，随着我们的成长，这个问题愈来愈明显，我本来的设想是通过平等沟通的方式，将这个事实传达出去；然而在对方的认知中，这个一开始的前提条件也是不存在的。这也难怪事情演变成鸡同鸭讲，对牛弹琴的局面。更甚之处是，<strong>父母依靠的财力优势，仍然牢牢把握着这种绝对的权力</strong>，而这是我暂时无法应对了，直到愤怒的父母扬言要回收之前给予的房产时，我才感受到自己的无能和失落。</p><p>　　我并非天才，也绝非废物，只是目前为止，并没有认真对待工作，只是用玩乐的态度去享受工作和生活，所以并没有追求收入上的绝对提升，只求轻松和开心，毕竟在学术和编程上，自己也是有点个人追求的，只是这种懒散和无欲无求的心态下，自己也只是得过且过的过着每一天，对新事物很有兴趣，尽管有着三分钟热度的问题，但还算是维持着不断学习的习惯，只是执行力欠缺，很多事情做着做着就无疾而终了。错过了一些还算不错的创业的机会，都是因为没有认真对待的原因，连带着错过毕业的就业机会，自己并没有进入大厂，也就失去了填补光鲜履历的机会，也都是归功于我的无谓的浪费青春。偶尔半夜惊醒，懊恼的悔恨莫及，但也无可奈何。我不是那种，意志坚强不屈的，认准了自己的强项，就会闷头前进的人，尽管我无比渴望如此。总是会受到周遭的变化影响，时而自信满满，时而暗自神伤。想来也是多亏了毕业论文的折磨下，我总是会在力所能及的地方隐藏自己的实力，来获得偷闲的机会，为此沾沾自喜。这种恶习一直保留到现在了吧 ！ 无论如何，兜兜转转的几年之后，最终还是认识到，这样固步自封对自己只是一种更加长期的折磨和伤害，我想，现在的我已经做好了成为一个意志坚强的人的准备了。</p><p>　　但是挥霍无度的青春，并不会因此而消失，那些浪费的时间和机会仍然持续对我造成影响，直接的体现就是，我并没有什么积蓄，要么就是为了买心仪的设备和产品，要么就是经常出去旅游。也许，从现在开始存钱，以目前的收入水平，也还可以积攒一些可观的收入；而且随着自己能力的提升，获得一份更好的收入的工作也不是难事。只是这些并不足以抵抗父母的财力优势，我坚信未来的自己能创立属于自己的公司和事业，获得更符合自身能力水平的收入。只是在当下，当父母跟我做出切割，虽然生活水平不会受到太大影响，但是我并无法做出足以让他们反思的同等回应，特别是父亲简单直白的说，你并不如我。试图证明没有他们，我就是一个彻头彻尾的废物。让我承认父母的尊严和权威的时候，我只能选择沉默。</p><p>　　尽管我知道，这样一种极端的对话是不理智的，就算来自父母的财力优势再明显，也无法证明我的人生是失败的，特别是在当下这个暗流涌动的混乱年代，我顶多算是一个浪费了年华的可怜人。只是如若是我拥有足以匹配父母的财力，我想父母也不会妄自动用这个伤敌一千，自损八百的杀招吧！再则，起码能有平等沟通的可能性！只是在面对这样一个核武器打击的时候，我感觉自己的自尊受到了极大的伤害，我没想到我试图沟通的举动，居然会演变为绝对权力的竞争，赢的那一个就能贯彻自己的意志。这看起来分明就是一场追逐权力的政治斗争。而我明显准备不足，妄图用道理，独自应战，却忘了，在这片土地上，诞生的从来只有，胜者为王，败者为寇 的原始戏码，就如同霍布斯所描述的利维坦下的自然状态，只有追逐胜利的斗争，没有文明该有的思考。由于赢者通吃，所以这个斗争过程就显得那么原始，直接，且无所不用其极。</p><p>　　我从来没有相信过父辈那一套虚伪的儒家理论，不是因为其陈旧而腐朽，只是因为其对人性的无端压抑，至于如何个局限法，以目前我的水平，只能做到意会，却难以言传的地步，主要原因还是学识不深，无法把所思所想的核心都融会贯通起来，以为能理解王小波杂文之中的吐槽国学和儒家的妙处，就能走南闯北，天不怕地不怕。殊不知，临到关系到自己利害关系的时刻，也免不了瞻前顾后起来。更何况还要考虑到未来的家庭关系，我并没有办法做到无所畏惧，毕竟就算自己豁出去，无论最终是自己证明自己是对了，还是最终承认自己是个彻头彻尾的废物，对整个家庭而言，都难言有什么好处。</p><p>　　此事虽然到此为止，但是未来的我该何去何从，这是我最应该关心的事情。</p><p>　　这件事除了对我的自尊造成了长期的影响之外，还让我有那么一会儿开始怀疑起自己所谓的自信和坚持的根基，特别是当我发现自己没办法在行为上践行自我的时候，也就是发现自己没办法豁出去的时候；但转念一想，这种固执的坚持知行合一的想法有点幼稚，说起来虽然有点市侩，但是自己的行为虽然是践行自己的意志，但是如果是在无甚多收效的地方浪费太多执行力的话，自己还能一如既往的坚持自我吗？我深表怀疑。虽然无需做到哥白尼那种左右逢源，但是在关键点上默默为自己的坚持积攒实力还是完全做得到的。剩下的就交给时代本身来解决了。</p><p>　　为什么是时代呢？重温王小波的《知识分子的不幸》，我才终于意识到我心中的那份不甘的来源：</p><blockquote><p>什么是知识分子最害怕的事？</p><p>最怕活在不理智的时代</p><p>所谓不理智的时代，就是伽利略低头认罪，承认地球不转的年代；也是拉瓦锡上断头台的年代；是茨威格服毒自杀的年代，也是老舍跳进太平湖的年代。</p><p>知识分子只是会以理服人，假如不讲理，他就没有长处，只有短处，活着没意思，不如死掉</p></blockquote><p>　　至于为什么会不理智？只因为信仰而已，因为狂信，人就不想讲理。这个世界上并不存在可以狂信而无丧失理智危险的信仰。更甚之处在于，</p><blockquote><p>道理这个东西有一定复杂性，不一定是君王所能理解的。再说，假如能和他讲理，他就不是君王。君王总是对的，臣民总是不对。君王的品性不可更改，臣民就得适应这种现实</p></blockquote><p>　　我如梦初醒，明白自己败在何处了！</p><p>　　原来答案我早就曾经看过了，只是被我理解之后就被抛诸脑后给忘记了。无论是思考不够深刻，还是临到发表意见时被环境左右导致无法自如的表达自我，总之，前方的路还有很多困难需要克服，希望未来自己仍然能不忘初心，坚定自己的道路，切不可因为一时的得失而裹足不前，应该着眼于更加长远的理想。</p><p>　　关于未来，我应该做些什么，才能避免自己再次陷入被动呢？</p><p>　　关于这一点，将是下一篇文章的主要内容。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 反思 </tag>
            
            <tag> 哲学 </tag>
            
            <tag> 王小波 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跳出刷题的自我怀疑(转载)</title>
      <link href="algorithms/tiao-chu-shua-ti-de-zi-wo-huai-yi-zhuan-zai/"/>
      <url>algorithms/tiao-chu-shua-ti-de-zi-wo-huai-yi-zhuan-zai/</url>
      
        <content type="html"><![CDATA[<blockquote><p>刷题中总感觉自己是个废物，终于在这篇文章中找到原因</p><p>From <a href="https://zhuanlan.zhihu.com/p/351560331">https://zhuanlan.zhihu.com/p/351560331</a></p></blockquote><p>刚接触 Leetcode 的时候，我经常边刷题边陷入自我怀疑，通常有几个原因：1）想不到最优解：一些简单题目的最优解，我觉得自己不可能想出来，也不太能理解。2）看不懂解法：论坛中被赞最多的解法往往为了追求代码的简短性而忽略可读性，在刷题初期要理解解法都需要耗费大量时间。3）差距太大：网上有不少<a href="https://link.zhihu.com/?target=https://www.youtube.com/watch?v=4ALB5m_Idkk">竞赛直播的视频</a>，他们在 20 分钟之内就能解答四道题目，对比之下，实在自愧弗如。</p><p>这几个原因导致的自我怀疑不仅打压了我刷题的热情，耗费了大量时间，也影响了我对自己真实算法水平的判断。如今刷过一些题之后，我开始了解到一些更深层的原因，希望在此能帮助到刷题中迷茫的各位：</p><h2 id="简单题不简单"><a href="#简单题不简单" class="headerlink" title="简单题不简单"></a>简单题不简单</h2><p>我推测 Leetcode 的题目难度并不是根据最优解的难度来设定的，也就是说一道标记为简单的题目它的次优解可能非常直观，但是最优解却很难想出来。这一点对于当初是刷题新手的我尤其致命，因为在被最优解的美妙所震撼之后，我强迫自己理解和证明它，但是如果在一定时间内还没有成功，我就会陷入深深的自我怀疑，举几道题目为例：</p><p><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/maximum-subarray/">最大子序和</a>（简单）</p><p><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/">官方解答</a>轻描淡写地给出了分治解法以及动态规划解法。这两个解法容易想到吗？《编程珠玑》第八章讨论了这个问题：</p><blockquote><p>“… 1977年的时候，他将该问题叙述给 Michael Shamos 听，结果 Shamos 花一个通宵就设计出了算法3（注：分治解法）。过了没多久，Shamos 向我介绍这个问题，我们一致认为这很可能是最好的算法了，因为研究人员刚刚证明了几个类似的问题需要正比于 O(<em>n</em>log<em>n)</em> 的时间。几天之后，Shamos 在卡内基—梅隆大学研讨会上介绍了该问题及其历史，结果与会的统计学家 Jay Kadane 在一分钟之内就勾勒出了算法4（注：动态规划解法）。好在我们知道不会有更快的算法了：任何正确的算法都必须至少花费 <em>O</em>(<em>n</em>) 的时间“</p></blockquote><p>数学家 Michael Shamos ，花费一个通宵才设计出分治解法。而且他和计算机科学家 Jon Bentley 都没有想到动态规划最优解，我又何必要求自己在两个小时内想到。</p><p><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/linked-list-cycle/">环形链表</a>（简单）</p><p>最优解使用了 Floyd 判圈算法，一般来说，算法带人名的都不是凡夫俗子可以想到的。</p><p><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/majority-element/">多数元素</a>（简单）</p><p>最优解使用了 Boyer-Moore 投票算法，它的一般形式发表了一篇论文，具体可以浏览<a href="https://link.zhihu.com/?target=https://www.cs.ou.edu/~rlpage/dmtools/mjrty.pdf">这里的介绍</a></p><p><a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/find-the-duplicate-number/">寻找重复数</a>（中等）</p><p>最优解是 O(N) 的快慢指针解法，我当初看到这个解法的时候感觉难以置信，不禁让我去查找这个解法的相关资料，最终找到了<a href="https://link.zhihu.com/?target=https://keithschwarz.com/interesting/code/?dir=find-duplicate">这篇文章</a></p><blockquote><p>“This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve and I have only met one person (Keith Amling) who could solve it in less time than this.“</p></blockquote><p>Don Knuth ，算法界的传奇，著作包括《计算机程序设计艺术》这本巨著，花了 24 小时想到快慢指针的解法。</p><p>这样的例子还有不少，我举这些例子并不是让你自我安慰或满足于次优解。而是说某些题目的最优解是很难想出来的，了解这些事实才可以对自己的水平进行更加准确地评估，不会因为花一个小时想不出最优解而自怨自哀。另外，做题过程中若被题目的难度标签所影响，高估或者低估自己的真实水平都对于面试并没有任何帮助，所以我现在都使用自己开发的 Leetcode invisible 插件隐藏了题目的难度。我建议 Leetcode 可以参考 Google Kickstart 进行分级，一道题目可以分两个难度标签和两个测试集，例如，最大子序和这道题目的标签是 <strong>简单 | 困难</strong>，代表次优解比较简单，但是最优解需要一些巧思才能解决。</p><h2 id="熟能生巧"><a href="#熟能生巧" class="headerlink" title="熟能生巧"></a>熟能生巧</h2><p>我在 Leetcode 大概做过 900 题，熟悉了题目的套路之后，仅仅从题目名字就能推测到解法。例如 “石子游戏“ 一看就是 minmax 策略，“ XXX 子序列” 的话可以试试动态规划，“ XXX 最大的最小值” 是二分或者滑动窗口。<strong>但是这并不代表我的算法水平多么厉害，让我去做其他平台的题目我绝不可能从题目名字想到解法。</strong>同样地，竞赛的选手也有这样的优势，在做了大量题目，参加了大量竞赛之后，他们可以从题目名字或者描述中就能找到之前做过题目的影子，快速找到解法。</p><h2 id="大神也会卡题"><a href="#大神也会卡题" class="headerlink" title="大神也会卡题"></a>大神也会卡题</h2><p><a href="https://link.zhihu.com/?target=https://leetcode.com/lee215/">Lee215</a> 是 Leetcode 美区 reputation 分数最高的用户，竞赛成绩也很前，一些题解更是令我醍醐灌顶。<a href="https://link.zhihu.com/?target=https://leetcode.com/cuiaoxiang/">cuiaoxiang</a> 是 Leetcode 国区竞赛前列，经常在 20 分钟能解答四道题目。但是即使优秀如他们，偶尔也会遇到卡题的情况，<a href="https://link.zhihu.com/?target=https://www.youtube.com/watch?v=ZIhhoFQp8H4&t=1030s">推荐这个 Lee215 第一人称解说的竞赛视频</a>，视频中 cuiaoxiang 难得一见使用 30 分钟解答一道中等题。可见，算法涉及的东西非常多，大家熟悉的领域也不同，即使我在 30 分钟内解答了那道题，也绝不代表我比 cuiaoxiang 厉害。</p><h2 id="竞赛不是面试"><a href="#竞赛不是面试" class="headerlink" title="竞赛不是面试"></a>竞赛不是面试</h2><p>大部分人刷题都是为了面试而不是竞赛，而面试和竞赛其实差别很大，William 是非常强的竞赛选手，Leetcode 竞赛拿过几次第一，而且他发布过一个连续 12 小时解答 120 道算法题的视频，直接把我看呆。不过竞赛选手沟通不一定强，他和一位谷歌工程师进行过<a href="https://link.zhihu.com/?target=https://www.youtube.com/watch?v=-tNMxwWSN_M&t=0s">模拟面试</a>，沟通并不比其他人强很多。同样的，面试选手竞赛不一定厉害。竞赛的时候题目会给定所有限制条件，只需要写代码提交，不需要向其他人解释自己的思路。但是面试需要让面试官理解自己的思路和代码，也可以让面试官提供一些帮助，对于沟通的要求要更高。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>刷题离不开坚持和努力，更需要保证良好的心态，我在刷题初期的时候，经常会心态崩溃。现在回过头看，实在是没有必要，最后分享一句话给大家，共勉。</p><p>“If you are not enjoying it, you are doing it wrong.”</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时断时续的执行力反思</title>
      <link href="sui-bi/shi-duan-shi-xu-de-zhi-xing-li-fan-si/"/>
      <url>sui-bi/shi-duan-shi-xu-de-zhi-xing-li-fan-si/</url>
      
        <content type="html"><![CDATA[<p>　　自从去年国庆开始写blog之后，更新过程尤为艰难，兴趣点的转移，执行力时断时续，尽管深知自己有这样三分钟热度的嗜好，但是仍然难以有效利用或者纠正，任由其发展。这与当初设想的定期更新的理想大相径庭，其实要论原因，每一篇随笔里都或多或少有提及，结果上来看，还是执行力不强的问题，心态上看，还是决心和勇气不足。总结出了很多原因，依然无法有效的解决问题，现在打算把这些断断续续的分析成果认真的探讨一下，希望能发现自身存在的根本性的问题。</p><blockquote><p>Desultory :  going constantly from one subject to another in a halfhearted way </p></blockquote><p>　　最近背单词的时候发现了一个单词非常好的描述了发生在我身上的这种现象，不知道是不是中了年少时候教导的，“要么不做，要么就做到最好”，这个毒鸡汤的影响，再加上总是妄想武侠小说或者各种爽文网剧中，那种不鸣则已，一鸣惊人的那种戏剧性的影响，总是幻想着能厚积薄发，一鼓作气的逆袭。结果就是形成了这股略显中二的行事风格，在年少气盛的时候，没看出哪里有什么不对；只是到了重要的分水岭的时候，便开始畏首畏尾了。一般这种情况碰上拖延症，就这么一直搁置下去了。最后积累到一起，让自己无所适从，不知道如何面对。其实我一直都知道，这种人生重要的选择，都需要倾注足够的精力去分析和思考，只是都被我逃避开了。所以，当一些烦恼和麻烦接二连三的到来时，最终归根溯源，都会追查到这份逃避和懒惰上来。这种心态就像是这样：</p><blockquote><p>我在考试该复习前，有时特别想看书闲玩总之是干一切其他的事情。</p><p>考试结束后真到了有时间做上述那些事的时候，往往作个几天就又想搞别的了</p></blockquote><p>　　因为思考这种利弊，很费脑力，尽管这些脑力不用也没干什么有意义的其他的什么事情？我又是个比较怕麻烦的人，所以为了暂且的安定，则选择了逃避并搁置这种疑惑。结果来看，则是带来更多更复杂的烦心事。这让我想起最近看到了关于<a href="https://yonglezh.github.io/2017/01/21/doublethink/">双重思想</a>的文章，关于双重思想形成的4大要素：</p><blockquote><ol><li>相信两种互相矛盾的信念。（并非同时，而是脑袋里具备两种互相矛盾的信念。）</li><li>根据情境来切换自己相信的信念。</li><li>忽略矛盾，认为自己当下的信念就是自己一直以来坚持的信念。</li><li>忽略自己在忽略矛盾，忽略自己在不断地切换信念。（意识不到自己按不同情境做了不同的选择 —— 这是明知两个信念存在矛盾却不认为自己的行为有矛盾的关键。）</li></ol></blockquote><p>　　我相信暂时的搁置能换来更少的麻烦，同时也相信现在投入一定的思考能让自己未来烦恼变得更少。所以秉承着怕麻烦的总体思路，尽管我能隐约察觉到这两种选择的矛盾之处，但是烦恼这种东西，难以量化，如果不去深思这二者的区别的话，就更加难以分辨。所以，我在快要发现矛盾的时候，及时的选择的忽略矛盾，这便是上述要素3；再则，在不断的切换兴趣点和日常琐事中，完全意识不到自己是在忽略矛盾，因为彻底了忘记了这些问题了，也正好达成了要素4。</p><p>　　现实是公平且残酷的，当我都快要忘记这些不想面对的抉择的时候，这些乱七八糟的事情像是约好似的集中朝我走来。小到上班摸鱼，摸到自己都开始厌恶自己，不知道整天在做些什么，开始后悔不如一开始就认真做事，还能有所成长和收获，落得个习惯性的无所事事，还要花费很多精力去纠正这种不良习惯，何况还有没能成长的自信还需要去弥补；大到面对人生的道路的时候，犹犹豫豫，不敢前进，最后拖拖拉拉，搞得自己都没勇气去踏出应该走出的那一步，还不如一开始就走出去，白白积累一段不愉快的自卑的经历。</p><p>　　经过这些问题和失败才感同身受的明白了，认真合理的规划自己的人生，才是最省心和麻烦最少的一种方式。就跟写代码一样，以前做OJ的时候，总是爱盲目的开始敲代码，经常发现凭借直觉的代码总是会犯一些最基础的错误，看到这些稚嫩的代码，连自己都为之汗颜；后来才明白，做OJ最主要的部分其实并不是敲代码，反而是思考的过程才是最需要去实践和锻炼的。这么简单的道理，怎么自己却不明白呢？合理的构思代码结构，划分功能模块，化繁为简，分区而治才是简洁高效并优雅的代码的基本保障，明明在学习《算法4》的时候，对这种优雅的API结构化写代码流程极为推崇，为什么到了自己实践的 时候，却也犯糊涂了呢？之后无论是看设计模式，还是学习一些知名的开源项目，都是把这种模块化的思维贯彻到底的一种实践方式，曾经觉得，这些开源项目都是可望不可及的存在，必定是每一行代码都是非常牛逼的存在，学习后才发现，其实功能被切分到非常具体的时候，这些代码就算是我也能轻松写出来；厉害的地方其实在项目架构的模块切分和接口的定义。自己照着这个设计思路一走就会发现，这样的架构其实有很多其他的变种，都能实现大体相同的功能，之所以成为目前的这个架构，都是有很多细节和稳定性以及扩展性的考量的，朝着这个方向去理解，就会发现很多结构和接口的设计就显得合理多了。总之，无论是代码架构还是人生规划，随意的搁置和逃避是非常不划算的选择，因为相比决策阶段的投入，失败成本显然高太多，况且自己并非不愿意去做决策，只是非常单纯的懒继而拖延症愈发严重而导致的，认真去思考，其实自己还是愿意去做的；况且我还是非常享受生活朝着自己规划的方向走的过程的，一点点收益和成果，都会让自己非常满足；就跟写出很棒的代码一样，规划得当，小小的努力就能获得非常巨大的AC快感。</p><p>　　所以，发现矛盾要正视，投入一点分析和思考去解决，认真执行，接下来的一点点收获和成果就能指导自己朝着希望的方向前进。任何时候都不要吝惜自己的思考，认识自己，发现自己，认知这个世界，释放自己能量，那才是我想要成为的自我。</p><p>　　规划之外，还有执行力的一些习惯问题需要纠正，总的来说，就是自己不够自律。</p><p>　　三联生活周刊公众号的一篇关于<a href="https://mp.weixin.qq.com/s/EjPk_1csVjxQFr9PWJABxQ">自律的文章</a>启发了我，里面所描述的种种现象完美的击中了我，我之所以不敢轻易开启我的自由职业，最大的忧虑就是担心自己不够自律，无论是学英文，学架子鼓，学新的编程语言，学新的开源架构，无一例外都是刚接触的时候信心满满，没坚持几天就开始逃避并放弃，学的好一点，只是因为某些领域天赋还行，短时间内就可以达到可堪够用的程度，但是最后也是由于自满自足，逃不过被搁置的命运。不能否认的是，这些事物中，在经历最初的新鲜感之后，很容易进入一个枯燥无味的瓶颈期，我想，我的兴趣基本都没有逃过瓶颈阶段的围追堵截，除了形势所迫被逼无奈不得不去面对，其他时候基本都停在了这个阶段。回想起来，其实就算在学鼓的瓶颈期，我也并不是很反感重复的基本功练习，顶多就是不那么好玩，只是需要训练的时候，自己习惯性的逃避起来，就开始为不练习寻找理由，就只想到了练鼓的不好玩的那一面，结果就没能坚持下去。对于架子鼓，我还是抱有持续的热情的。只是被更高一级的懒拖给掩盖了。从这个角度来看，保持一幅清醒理智的头脑才是这之中最重要的，也许在电脑前，我更想要去玩游戏，更想要去看电影，吃饭的时候，也愿意无聊的看看游戏直播，虽然我其实并没有那么喜欢看直播。但是，<strong>我本质上，还是喜欢一段时间内，只专注做一件事的人</strong>，所以这段时间内的成果，就显得至关重要。做的很好，那么就有坚持继续下去的动力，如果做得不好，那么很可能就会被搁置下去。以前都是漫不经心的执行着，所以只有一些零星的事情才坚持下来了，现在看来，着实有点可惜，因为这些坚持的下来的事情，要么就是偶然做的很好，要么就是天赋很好，轻松就搞定了。根本还没有轮到努力发挥的空间，特别是对于自己非常渴望的事情，就没能通过努力有所精进。</p><blockquote><p>在和乔布斯聊了5分钟后，库克就决定跳槽到苹果。2010年，库克在母校奥本大学的毕业典礼以嘉宾身份发表讲话，他说“我的直觉告诉我，加入苹果是一个千载难逢的机会，可以为这位创意天才工作，也可以加入一个能够重振的伟大的管理团队。”</p><p>如果不是对想做的事真心热爱，很难放弃自己稳妥到手的利益，投身到一家岌岌可危的公司。</p><p><strong>不是自律让库克成功，而是找到了自己热爱的事情，自己愿意用“苦行僧”式的自律方式把热爱的事变得更好。</strong></p></blockquote><p>　　对于热爱的事情，我不乏对其想要认真做好的热情，只是没能有效利用自律来把热爱的事情做的更好，只是单纯的觉得热爱的事情会自然的变好。这种天真的想法，似曾相识，恰如当年觉得爱情，只要有满腔热情，后面的事情就自然而然的就会变好。事实并非如此，对于热爱的事情，不仅要有热情，还要合理利用自律的方式来让其变得更好，否则只是无根之木，无源之水，难以为继，白白消耗一番心血。</p><p>　　这样想来，其实自己做事一贯如此，总是以为关注最主要的部分，其他的次要问题就会迎刃而解。但是或许我对迎刃而解这个理解是有偏差的，我以为的情况是，什么都不做，这个事情自己会随着主要问题一并被解决；而实际情况，需要为次要问题做一些基本的准备和关注，甚至为了万无一失，需要投入同样重要的资源。似乎我在做事的时候，从来没有思考过，这件事情要做好，需要牵涉到哪几方面的内容，以及需要在这几方面应该如何分配资源做准备。所有的精力完全只放到事情本身上，如果是比较单纯的事情，那么自然就没必要为其他的事情分心；但是，目前面临的事情，很少是比较单纯的，很多事情都会牵涉到很多方面， 这还不包括自己在分析问题的关键点上存在偏差这个可能，所以，成熟可靠的做法，是仔细分析事情的各个方面，判断重点，合理的划分资源。在热爱的事情这个问题上，还需要自律来为其添砖加瓦。</p><p>　　在看王小波的杂文的时候，在看哲学经典的时候，在看费曼的《物理学讲义》的时候，在看《算法4》的时候，在看3Blue1Brown的数学视频的时候，在看优雅的开源代码的时候，心中都会涌现出对热爱的事情的渴望，这些内容其实在理解之后，都变得不那么晦涩难懂，反而激发出自己想要做出这样成果的热情。因为我觉得，这些都是非常优秀的成就，我希望自己能在这个方向上走出那怕一小步，我也就心满意足了。</p><blockquote><p>当下我们很多人的自律纯属一时兴起，因为缺乏目标感、因为想要逃避真正的困难、或者仅仅觉得自己的生活单调，所以才妄图抓住自律这根救命稻草来把自己拉出泥泞。</p><p>结果就是陷入恶性循环：下定决心自律→因为真正目标不清晰而难以坚持不下去→鄙视自己意志力脆弱、厌恶自己→妄图再靠“一时兴起”的自律来拯救自己</p></blockquote><p>　　之前在自律方面一直陷入这样一时兴起的恶性循环中，目标感虽然还算比较明确，但是缺乏一定要去达成的使命感，所以才会想方设法的逃避困难，虽然真正做起来，没有那么复杂，至于长期以往的摸鱼，确实会导致生活单调，想要反弹，跟习惯的斗争，确实是旷日持久，这也当然属于失败成本，而且是属于非常难以纠正的那种。也只能怪自己过分骄傲自大，明明是自己失败了，却还妄图自欺欺人的来在虚荣心上来进行补偿，真是本末倒置，首尾都没能兼顾。</p><p>　　摆平心态，自己一手造成的恶果，就要自己努力去修正。自律不是一时兴起，不需要心血来潮的补救，找到自己热爱的事情，发现自己愿意为这份渴望付出到什么程度，用相对应的自律方式将这份热爱的事变的更好，我也就知足了。</p><p>　　相信自己，坚定自我。不达目的，誓不罢休。</p><p>　　使命感之外，还有一个来自于之前毒鸡汤的后续影响不那么容易察觉，就是内心深处的完美主义。我不知道应该如何正确的看待完美主义这个特质， 有时候觉得完美主义的强迫症会让事情变得更好；有时候却又发现，自己只是无形之中被完美主义给束缚住，感觉自己无法做到理想的高度，就会不停的打退堂鼓。本质上来讲，这应该是自己做事没有明确目标导致的，因为如果自己预定的目标并不是做到最好，那么就算不是完美达成，也不至于丧气，虽然心里多少还是对自己没尽全力感到不快。大部分时候做事，都是看到日程表里有这件事，或者是发现此时此刻应该要做这个事情，糊里糊涂的毫无目的的就上阵了。最明显的案例是，自己以前每次学习新的框架的时候，总是想事无巨细，从框架结构到代码细节都想掌握，再开始使用；结果发现，捣鼓一阵子之后，似乎很久之后都不会再用到这部分知识，直到遇到问题，再回头来看的时候，发现这个框架已经陌生得仿佛之前从来没有用过一样。再回想起当初的目的，只不过是想要用上这个框架而已，深究原理和细节似乎并没有提供太多有用的帮助，这是影响一；其次，有了多次这样的无用功的经验之后，自己明显学乖了，一碰到可能要遇到这样工作量的事情，就本能的开始回避起来，这是影响二。</p><p>　　如果影响一还可以通过合理规划目标来解决，那么影响二则是现在困扰自己最大的难题。不知道是不是因为年龄的增长，还是失败的经历让自己情绪过分低落，面对一些挑战的时候，自己开始变得保守和本能的回避起来。比如，每次想要跳槽的时候，总是会想复习算法题，复习深度学习的概念，尽管自己对算法题平时也有在积累，深度学习的工具平时也有在用，但是总是感觉没有全面的学习，总是会有一些遗漏，难以覆盖所有可能的情况。把面试当作综合性测试一样来看待，所以每次准备都会耗费大量的精力，然而却只是经过几次面试就没再派上用场了。这其中自然有自己多少还是有点社交恐惧症，面对陌生的面试者，拼命的想要通过丰富的知识储备来对抗内心的胆怯，但是我似乎有点迷失了重点，因为我开始发现，技术上的储备并不是面试的全部，特别是发现很多技术面，自认为回答的很好，却仍然没能通过，而这后来深思之下，可能只是职位的需求和自身的能力不一定匹配有关，比如说这个职位可能只需要普通能力的即可，或者是薪酬或者是HR等非技术因素导致的。我太执着于技术反而会认为没通过的原因多少还是自己不够完美，尽管我目前这种得过且过的状态，似乎也难言技术上是无可挑剔的。但是胜任工作，我自以为还是绰绰有余的。不过这其中还是有内卷的因素，导致面试造火箭，上班拧螺钉的情况愈来愈严重。总之，种种因素，让自己产生了面试一定要完美准备的倾向，结果反而让自己对频繁的面试产生了抗拒感。这也是为什么，当发现不错的职位的时候，自己并没有忙着投简历，反而只是观望，结果只是平白无故的搁置这件事而已。</p><p>　　从这个角度，解决这个问题的方式很明显，其一，就是把浮躁的技术能力进行本质上的提升，无论是工作还是科研，这都是非常核心的能力，不需要通过临时抱佛脚的方式来死记硬背一些深度学习的概念，尽管面试的时候还是经常碰到这些类似八股文的程式化的问题，但是自己并不需要纠结一定要全面的回答出来，毕竟兴趣点和精力决定了，自己只能对某些特定的领域精通，专注于自己曾经做过的项目和内容即可。抓住理论模型和算法实践这两个核心能力，理解为主，实践为辅，不骄不躁，荣辱不惊；无论曾经做的多么半途而废，多么浮躁不堪，现在开始，踏踏实实的看理论，看源码，写代码，获取实实在在的编程能力才是最核心的部分。其次，就是算法题的复习的时间误区，基于平时都在刷题的基础，其实复习起来只需要较短的时间，特别在很多轮的算法题的复习之后，更多的精力需要放到总结上，而非盲目的刷题。最后，除开技术储备，就是正确的看待面试这个问题，除了职位技术的匹配之外，还有公司本身的需求和机遇等因素的影响，很多时候技术以外的影响反而更大一点，虽然我并非那种天赋异禀的人才，能逢面必过。所以我也没必要纠结于那些没有拿到offer的面试，试图在自身上寻找原因，然后再暗自神伤。首先，技术的盲点，面试环节就能马上知道，之后再补上就可以了；其次非技术因素，就算自己怎么苦思冥想也不会有一个可靠的结论，所以与其在这里胡思乱想，还不如积极的投入到下一次面试中去；最后，面试其实并没办法全面的考察能力，有很多偶然的因素在其中，没必要太纠结于自己无法办到的事情，从更加宏观的层面来要求自己，有足够的底气做支撑，做到，不卑不亢，荣辱不惊。我想自己也能心平气和面试了，那样的自己也才算是真正的成长和进步了。</p><p> 　　最后，关于做事情的正确心态的问题，前面也说到过，糊里糊涂的蛮干的方式多少还是不行的，起码无法掌握做事情的度，也缺乏一个实际的目标感。更有效率的做事心态应该是在开始做事前，考虑清楚，这件事的目的，需要做到什么效果，牵涉到哪些方面，这些资源是否都准备就绪。。。等等之类的做一番简单的思考，觉得条件都具备了，再开始执行。总的来说，是需要有一个宏观的思考之后，再开始做事，我想那样执行力应该更加游刃有余吧。尽管不一定能每件事都做到这样，但是至少重要的事情，希望自己能有这样一个思考，也算有一个不错的开端。这也正印证了前面的关于规划和执行的讨论。<strong>倾注足够的思考的执行，才是更有效率的达成目标的方式</strong></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 总结 </tag>
            
            <tag> 反思 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>147/148 merge sort</title>
      <link href="algorithms/147-148-merge-sort/"/>
      <url>algorithms/147-148-merge-sort/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Given the <code>head</code> of a linked list, return <em>the list after sorting it in <strong>ascending order</strong></em>.</p><p><strong>Follow up:</strong> Can you sort the linked list in <code>O(n logn)</code> time and <code>O(1)</code> memory (i.e. constant space)?</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="img"></p><pre><code>Input: head = [4,2,1,3]Output: [1,2,3,4]</code></pre><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" alt="img"></p><pre><code>Input: head = [-1,5,3,4,0]Output: [-1,0,3,4,5]</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: head = []Output: []</code></pre><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the list is in the range <code>[0, 5 * 104]</code>.</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul></blockquote><p>　　排序类别的题目应该是所有排序算法的基础了，不过用单链表形式出现的还比较新颖，147是插入排序则是比较熟悉的，很轻松的就AC了，然后148则遇到了一点困难，扫完题目就发现当初比较偏爱的三向快速排序法完美适配，论速度应该没有比快排更快的了，但是意外没能通过OJ，可能是跟单链表形式的数组跟快排本身还是存在适配问题，如果是堆排序，明显树结构更合理一点，剩下的就只有归并排序了，奈何，自己从一开始就对归并排序不是特别来电，一直以来并没有太深入研究其算法原理，所以这里实现起来遇到了一点困难，更不知道除了自顶向下的归并排序之外，还有一个自底向上的归并排序，这样不仅算法复杂度满足O(nlogn)，空间复杂度也可以做到O(1)</p><h3 id="解法一：自顶向下归并排序"><a href="#解法一：自顶向下归并排序" class="headerlink" title="解法一：自顶向下归并排序"></a>解法一：自顶向下归并排序</h3><p>　　虽然归并基本是以分治为主，递归的切分数组，最后合并2个已经排好序的数组，所以只需要处理初始化的状态就可以了，但是不是很确定这个初始化应该放在归并中还是放到切分的函数中，理论上应该是在切分函数里，因为主要的递归调用是调用的切分函数的，但是自己无时不刻总是担心的性能问题作祟，在这个问题上犹豫不决，更加犹豫的是，心理上有点怀疑这么粗暴的递归，真的能达到O(nlogn)的性能吗？结果证明是自己多虑了，真实的递归就是如此，枉费当初还从算法复杂的上推理过分治的原理公式，这么快就忘记了。</p><p>　　单链表下的分支惟一需要处理的问题就是切分了，需要手动切段单链表，同时处理递归的初始化状态，接下来专心写归并的递归即可，如果合并2个已经排序的单链表，这个实现起来还是比较简单的。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> head <span class="token operator">==</span> None <span class="token operator">or</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        mid<span class="token punctuation">,</span> tail <span class="token operator">=</span> head<span class="token punctuation">,</span> head<span class="token punctuation">.</span>next        <span class="token keyword">while</span> tail <span class="token operator">and</span> tail<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            tail <span class="token operator">=</span> tail<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            mid <span class="token operator">=</span> mid<span class="token punctuation">.</span>next        start <span class="token operator">=</span> mid<span class="token punctuation">.</span>next        mid<span class="token punctuation">.</span>next <span class="token operator">=</span> None        left<span class="token punctuation">,</span> right <span class="token operator">=</span> self<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>start<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>mergeSort<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">:</span>        root <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token punctuation">)</span>        tail <span class="token operator">=</span> root        <span class="token keyword">while</span> l1 <span class="token operator">and</span> l2<span class="token punctuation">:</span>            <span class="token keyword">if</span> l1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                tail<span class="token punctuation">.</span>next <span class="token operator">=</span> l1                l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                tail<span class="token punctuation">.</span>next <span class="token operator">=</span> l2                l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next            tail <span class="token operator">=</span> tail<span class="token punctuation">.</span>next        tail<span class="token punctuation">.</span>next <span class="token operator">=</span> l1 <span class="token operator">or</span> l2        <span class="token keyword">return</span> root<span class="token punctuation">.</span>next</code></pre><h3 id="解法二：自底向上归并排序"><a href="#解法二：自底向上归并排序" class="headerlink" title="解法二：自底向上归并排序"></a>解法二：自底向上归并排序</h3><p>　　主要原理基本就是把递归的代码改写成迭代的代码，方法跟希尔排序类似，递增已经排序的size大小，初始size=1，也即是单个元素默认是已排序状态，随后依次合并2个已排序链表，这里主要的改写部分都是和单链表的切分有关，因为跟数组列表可以在O(1)时间内获取任意索引的元素不同，单链表有些繁琐的细节处理，这里的技巧是，根据size大小，获取需要合并的2个链表的头，然后在merge阶段，返回合并后的链表的tail，因为这个tail在下一轮的merge的时候需要用到，因为需要把上一个合并后的tail.next = 合并后的LinkList的head。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># buttom up merget</span>    <span class="token keyword">def</span> <span class="token function">getSize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        count <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> head<span class="token punctuation">:</span>            count <span class="token operator">+=</span> <span class="token number">1</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next        <span class="token keyword">return</span> count    <span class="token keyword">def</span> <span class="token function">splitLink</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">:</span>        cur <span class="token operator">=</span> head        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> cur<span class="token punctuation">:</span>                <span class="token keyword">break</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next        <span class="token keyword">if</span> <span class="token operator">not</span> cur<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        next_start <span class="token operator">=</span> cur<span class="token punctuation">.</span>next        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> None        <span class="token keyword">return</span> next_start    <span class="token keyword">def</span> <span class="token function">mergeSort_bottomup</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">,</span> l2<span class="token punctuation">,</span> pre_tail<span class="token punctuation">)</span><span class="token punctuation">:</span>        cur <span class="token operator">=</span> pre_tail        <span class="token keyword">while</span> l1 <span class="token operator">and</span> l2<span class="token punctuation">:</span>            <span class="token keyword">if</span> l1<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>l2<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> l1                l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> l2                l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> l1 <span class="token operator">or</span> l2        <span class="token keyword">while</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next        <span class="token keyword">return</span> cur    <span class="token comment" spellcheck="true"># bottom up sort</span>    <span class="token keyword">def</span> <span class="token function">sortList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> head <span class="token operator">==</span> None <span class="token operator">or</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        length <span class="token operator">=</span> self<span class="token punctuation">.</span>getSize<span class="token punctuation">(</span>head<span class="token punctuation">)</span>        root <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token punctuation">)</span>        root<span class="token punctuation">.</span>next <span class="token operator">=</span> head        <span class="token comment" spellcheck="true"># pre_tail = None</span>        start <span class="token operator">=</span> None        size <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> size <span class="token operator">&lt;</span> length<span class="token punctuation">:</span>            pre_tail <span class="token operator">=</span> root            start <span class="token operator">=</span> pre_tail<span class="token punctuation">.</span>next            <span class="token keyword">while</span> start<span class="token punctuation">:</span>                left <span class="token operator">=</span> start                right <span class="token operator">=</span> self<span class="token punctuation">.</span>splitLink<span class="token punctuation">(</span>left<span class="token punctuation">,</span> size<span class="token punctuation">)</span>                start <span class="token operator">=</span> self<span class="token punctuation">.</span>splitLink<span class="token punctuation">(</span>right<span class="token punctuation">,</span> size<span class="token punctuation">)</span>                pre_tail <span class="token operator">=</span> self<span class="token punctuation">.</span>mergeSort_bottomup<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">,</span>pre_tail<span class="token punctuation">)</span>            size <span class="token operator">*=</span> <span class="token number">2</span>        <span class="token keyword">return</span> root<span class="token punctuation">.</span>next</code></pre><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>　　关于归并的性能还是不太熟悉，所以针对这么精准需要用到归并的时候，遇到了一点困难，不过好在大体的原理还是知道的，只是实现上卡在一些小地方；此外我还是始终认为快排才是最快的，只是无法满足O(1)的空间复杂度，所以在个别测试用例上，很容易TLE，而且快排的代码真的简洁明了很多，相对于归并来说。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>146 LRU Cache</title>
      <link href="uncategorized/146-lru-cache/"/>
      <url>uncategorized/146-lru-cache/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Design a data structure that follows the constraints of a <strong><a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU">Least Recently Used (LRU) cache</a></strong>.</p><p>Implement the <code>LRUCache</code> class:</p><ul><li><code>LRUCache(int capacity)</code> Initialize the LRU cache with <strong>positive</strong> size <code>capacity</code>.</li><li><code>int get(int key)</code> Return the value of the <code>key</code> if the key exists, otherwise return <code>-1</code>.</li><li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if the <code>key</code> exists. Otherwise, add the <code>key-value</code> pair to the cache. If the number of keys exceeds the <code>capacity</code> from this operation, <strong>evict</strong> the least recently used key.</li></ul><p><strong>Follow up:</strong><br>Could you do <code>get</code> and <code>put</code> in <code>O(1)</code> time complexity?</p><p><strong>Example 1:</strong></p><pre><code>Input[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]Output[null, null, null, 1, null, -1, null, -1, 3, 4]ExplanationLRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // cache is &#123;1=1&#125;lRUCache.put(2, 2); // cache is &#123;1=1, 2=2&#125;lRUCache.get(1);    // return 1lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is &#123;1=1, 3=3&#125;lRUCache.get(2);    // returns -1 (not found)lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is &#123;4=4, 3=3&#125;lRUCache.get(1);    // return -1 (not found)lRUCache.get(3);    // return 3lRUCache.get(4);    // return 4</code></pre><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= capacity &lt;= 3000</code></li><li><code>0 &lt;= key &lt;= 3000</code></li><li><code>0 &lt;= value &lt;= 104</code></li><li>At most <code>3 * 104</code> calls will be made to <code>get</code> and <code>put</code>.</li></ul></blockquote><p>　　Meidum难度，没想到的是用单链表实现起来，很多琐碎的细节需要填补，磕磕碰碰的AC了，查看Discuss发现直接就用双链表实现即可，这才发现题设并没有要求只用单链表来实现，此题用双向链表会省去之前的繁琐操作。</p><h3 id="解法一：-单链表"><a href="#解法一：-单链表" class="headerlink" title="解法一： 单链表"></a>解法一： 单链表</h3><p>　　在AC之前，用单链表实现会有一个比较繁琐的细节就是，获取node的pre索引用作删除node用，最开始懒得扩展结果，准备接口都混在 get/put 内部去实现，最后发现非常不利于debug；最后发现还是需要抽象出更基础的接口，pop,append,getPreNode，保证这几个接口的正确性，后面的get/put实现起来就非常轻松了，结果也证实了这一点，一次就AC</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> capacity<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>key2prenode <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125;</span>        self<span class="token punctuation">.</span>node2key <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125;</span>        self<span class="token punctuation">.</span>root <span class="token operator">=</span>  ListNode<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>tail <span class="token operator">=</span> self<span class="token punctuation">.</span>root        self<span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        cur <span class="token operator">=</span> self<span class="token punctuation">.</span>root<span class="token punctuation">.</span>next        post <span class="token operator">=</span> cur<span class="token punctuation">.</span>next        self<span class="token punctuation">.</span>root<span class="token punctuation">.</span>next <span class="token operator">=</span> post        <span class="token keyword">if</span> cur <span class="token keyword">in</span> self<span class="token punctuation">.</span>node2key<span class="token punctuation">:</span>            key <span class="token operator">=</span> self<span class="token punctuation">.</span>node2key<span class="token punctuation">[</span>cur<span class="token punctuation">]</span>            self<span class="token punctuation">.</span>key2prenode<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>key<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>node2key<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>cur<span class="token punctuation">)</span>        <span class="token keyword">if</span> post <span class="token keyword">in</span> self<span class="token punctuation">.</span>node2key<span class="token punctuation">:</span>            post_key <span class="token operator">=</span> self<span class="token punctuation">.</span>node2key<span class="token punctuation">[</span>post<span class="token punctuation">]</span>            self<span class="token punctuation">.</span>key2prenode<span class="token punctuation">[</span>post_key<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>root        <span class="token keyword">return</span>    <span class="token keyword">def</span> <span class="token function">append</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        node <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>value<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>key2prenode<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>tail        self<span class="token punctuation">.</span>node2key<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> key        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>next <span class="token operator">=</span> node        self<span class="token punctuation">.</span>tail <span class="token operator">=</span> node        <span class="token keyword">return</span>    <span class="token keyword">def</span> <span class="token function">getPreNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>key2prenode<span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>key2prenode<span class="token punctuation">[</span>key<span class="token punctuation">]</span>        <span class="token keyword">return</span> None    <span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prenode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> prenode <span class="token operator">==</span> None <span class="token operator">or</span> prenode<span class="token punctuation">.</span>next <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span>         cur <span class="token operator">=</span> prenode<span class="token punctuation">.</span>next        post <span class="token operator">=</span> cur<span class="token punctuation">.</span>next        <span class="token keyword">if</span> cur <span class="token operator">==</span> self<span class="token punctuation">.</span>tail<span class="token punctuation">:</span>            <span class="token keyword">return</span>        tail_old <span class="token operator">=</span> self<span class="token punctuation">.</span>tail        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>next <span class="token operator">=</span> cur        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> None        self<span class="token punctuation">.</span>tail <span class="token operator">=</span> cur        <span class="token keyword">if</span> cur <span class="token keyword">in</span> self<span class="token punctuation">.</span>node2key<span class="token punctuation">:</span>            key <span class="token operator">=</span> self<span class="token punctuation">.</span>node2key<span class="token punctuation">[</span>cur<span class="token punctuation">]</span>            self<span class="token punctuation">.</span>key2prenode<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> tail_old        prenode<span class="token punctuation">.</span>next <span class="token operator">=</span> post        <span class="token keyword">if</span> post <span class="token keyword">in</span> self<span class="token punctuation">.</span>node2key<span class="token punctuation">:</span>            post_key <span class="token operator">=</span> self<span class="token punctuation">.</span>node2key<span class="token punctuation">[</span>post<span class="token punctuation">]</span>            self<span class="token punctuation">.</span>key2prenode<span class="token punctuation">[</span>post_key<span class="token punctuation">]</span> <span class="token operator">=</span> prenode        <span class="token keyword">return</span>    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        pre <span class="token operator">=</span> self<span class="token punctuation">.</span>getPreNode<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">if</span> pre <span class="token operator">==</span> None <span class="token operator">or</span> pre<span class="token punctuation">.</span>next <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            val <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val            self<span class="token punctuation">.</span>update<span class="token punctuation">(</span>pre<span class="token punctuation">)</span>            <span class="token keyword">return</span> val    <span class="token keyword">def</span> <span class="token function">put</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">:</span> int<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        pre <span class="token operator">=</span> self<span class="token punctuation">.</span>getPreNode<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">if</span> pre <span class="token operator">==</span> None <span class="token operator">or</span> pre<span class="token punctuation">.</span>next <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>size <span class="token operator">==</span> self<span class="token punctuation">.</span>capacity<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                self<span class="token punctuation">.</span>append<span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>append<span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>size <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">=</span> value            self<span class="token punctuation">.</span>update<span class="token punctuation">(</span>pre<span class="token punctuation">)</span>        <span class="token keyword">return</span></code></pre><p>由于没想过用双向链表，在单链表的限制下，不得的面临获取pre node索引的繁琐问题，而且这个复杂的比想象中麻烦</p><h3 id="解法二：-双向链表"><a href="#解法二：-双向链表" class="headerlink" title="解法二： 双向链表"></a>解法二： 双向链表</h3><p>　　如果是双向链表的话，问题就很简单了，而且可以在构建双向列表的元素直接从value变成key+value，简化之前的key2Prenode , node2key的复杂索引。由于自己并没有接触过Python下的双向链表，所以这里也没有打算自建双向链表，怕有坑，瞻前顾后不愿意尝试。实际上，双向链表的数据结构只是多了一个pre而已。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">BiListNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token operator">=</span>None<span class="token punctuation">,</span> value<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>key <span class="token operator">=</span> key        self<span class="token punctuation">.</span>value <span class="token operator">=</span> value        self<span class="token punctuation">.</span>pre <span class="token operator">=</span> None        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">LRUCache_Bi</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">:</span>        self<span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity        self<span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>hash <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>head <span class="token operator">=</span> BiListNode<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>tail <span class="token operator">=</span> BiListNode<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>pre<span class="token punctuation">,</span> self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token punctuation">,</span> self<span class="token punctuation">.</span>tail        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>pre<span class="token punctuation">,</span> self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>head<span class="token punctuation">,</span> None    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        value <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">if</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>hash<span class="token punctuation">:</span>            node <span class="token operator">=</span> self<span class="token punctuation">.</span>hash<span class="token punctuation">[</span>key<span class="token punctuation">]</span>            value <span class="token operator">=</span> node<span class="token punctuation">.</span>value            self<span class="token punctuation">.</span>remove_node<span class="token punctuation">(</span>node<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>add_to_head<span class="token punctuation">(</span>node<span class="token punctuation">)</span>        <span class="token keyword">return</span> value    <span class="token keyword">def</span> <span class="token function">put</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>capacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>hash<span class="token punctuation">:</span>            node <span class="token operator">=</span> self<span class="token punctuation">.</span>hash<span class="token punctuation">[</span>key<span class="token punctuation">]</span>            self<span class="token punctuation">.</span>remove_node<span class="token punctuation">(</span>node<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>add_to_head<span class="token punctuation">(</span>node<span class="token punctuation">)</span>            node<span class="token punctuation">.</span>value <span class="token operator">=</span> value            <span class="token keyword">return</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size <span class="token operator">==</span> self<span class="token punctuation">.</span>capacity<span class="token punctuation">:</span>            node <span class="token operator">=</span> self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>pre            self<span class="token punctuation">.</span>remove_node<span class="token punctuation">(</span>node<span class="token punctuation">)</span>        newNode <span class="token operator">=</span> BiListNode<span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>add_to_head<span class="token punctuation">(</span>newNode<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token keyword">def</span> <span class="token function">add_to_head</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        post <span class="token operator">=</span> self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next        post<span class="token punctuation">.</span>pre <span class="token operator">=</span> node        node<span class="token punctuation">.</span>next <span class="token operator">=</span> post        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next <span class="token operator">=</span> node        node<span class="token punctuation">.</span>pre <span class="token operator">=</span> self<span class="token punctuation">.</span>head        self<span class="token punctuation">.</span>hash<span class="token punctuation">[</span>node<span class="token punctuation">.</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> node        self<span class="token punctuation">.</span>size <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span>    <span class="token keyword">def</span> <span class="token function">remove_node</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        pre<span class="token punctuation">,</span> post <span class="token operator">=</span> node<span class="token punctuation">.</span>pre<span class="token punctuation">,</span> node<span class="token punctuation">.</span>next        pre<span class="token punctuation">.</span>next<span class="token punctuation">,</span> post<span class="token punctuation">.</span>pre <span class="token operator">=</span> post<span class="token punctuation">,</span> pre        self<span class="token punctuation">.</span>hash<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>size <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span></code></pre><p>这里在get/put之外，重新抽象出add_to_head , remove_node 接口，对应单链表版本的append, remove ，然后在get/put直接调用即可，简单明了，这里需要注意的是，实现过程中，单链表的tail代表的是最新访问的node，而在这里双链表版本插好相反，head才是最新访问的node；此外，这里额外添加了一个hash字段，实际完成的就是key2node的功能。</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>　　双向链表实际上是学生时代学的非常透彻的数据结构了，遗憾的是，当初没能从代码级别去理解，现在只是重新完成当初未完成的事情。奇怪的是，当初的二叉树和树结构理论基础也比较好，很顺畅的就可以切换到现在的代码；反而是更简单的链表，无论是理论还是实践都学的没有树结构好，可能是链表递归并不是常用方法，反而是树结构一般无脑递归就能解决绝大多数问题。最后，通过此题发现，在写数据结构和类的之前，一个好的抽象接口将会带来非常多的收益，这是自己一直不重视的，往往会看完题目就忙着开始动手写代码，这在往常的LeetCode中不是什么大问题，但是在这在类似架构搭建和设计的问题上，很容易自己给自己埋坑，以后自己在程序架构设计上，还需要多下功夫。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>139 Word Break</title>
      <link href="algorithms/139-word-break/"/>
      <url>algorithms/139-word-break/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em>containing a list of <strong>non-empty</strong> words, determine if <em>s</em> can be segmented into a space-separated sequence of one or more dictionary words.</p><p><strong>Note:</strong></p><ul><li>The same word in the dictionary may be reused multiple times in the segmentation.</li><li>You may assume the dictionary does not contain duplicate words.</li></ul><p><strong>Example 1:</strong></p><pre><code>Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]Output: trueExplanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]Output: trueExplanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.             Note that you are allowed to reuse a dictionary word.</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]Output: false</code></pre></blockquote><p>　　Medium难度，入手时第一个想到的是DFS，之前Tree相关的题目做的多了，上手就忍不住用DFS练一下手，虽然正确性没问题，但是性能不行，最终卡在TLE始终无法优化。或许是被DFS卡的有点心烦，也可能是自己懒得从头开始分析此题的其他解法，也没有打算另辟蹊径去分析此题，最后发现简单的DP就可以解决，什么时候DFS好用，什么时候DP更有优势，自己还是没能找到这二者的辨别方法。</p><h3 id="解法一：DP"><a href="#解法一：DP" class="headerlink" title="解法一：DP"></a>解法一：DP</h3><p>　　能用DP的关键要素是最优子结构，但是自己常常跟DFS的递归搞混，不知道哪种递归是可以运用递归子结构，哪种无法用，所以此题虽然DFS解法比较直接，但是并没有立刻想到可以用DP来解的。实际上，此题是可以转化成递归子结构的，而且跟DFS递推式基本一致，只需要根据起点的wordBreak： True or False 以及 后续的substring是否在wordDict来判断即可：</p><p>$dp[i] = dp[i-j] \cap (s[j:i] \in wordDict), j \in [0:i]$</p><p>起点初始化为True，否则后面没有机会变成True</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> wordDict<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>    length <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token keyword">if</span> length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">False</span>    set_words <span class="token operator">=</span> set<span class="token punctuation">(</span>wordDict<span class="token punctuation">)</span>    set_words<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>    dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">True</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span> <span class="token operator">*</span> length <span class="token comment" spellcheck="true"># dp[i] mean s[ :i] can split in wordDict</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>j<span class="token punctuation">:</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> set_words<span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>                <span class="token keyword">break</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span></code></pre><h3 id="思路二：-DFS-（TLE）"><a href="#思路二：-DFS-（TLE）" class="headerlink" title="思路二： DFS （TLE）"></a>思路二： DFS （TLE）</h3><p>　　首先想到的是DFS，递归的切分substring，如果substring在wordDict中，那么就继续递归下去，思路简单明了，但是隐隐感觉肯定还是有优化的地方，只是现在还没找到。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> wordDict<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>set<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> len<span class="token punctuation">(</span>set<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>wordDict<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">False</span>    set_words <span class="token operator">=</span> set<span class="token punctuation">(</span>wordDict<span class="token punctuation">)</span>    r <span class="token operator">=</span> self<span class="token punctuation">.</span>helper<span class="token punctuation">(</span>s<span class="token punctuation">,</span> set_words<span class="token punctuation">)</span>    <span class="token keyword">return</span> r<span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">,</span> set_words<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> s <span class="token keyword">in</span> set_words<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        sub <span class="token operator">=</span> s<span class="token punctuation">[</span> <span class="token punctuation">:</span>i<span class="token punctuation">]</span>        <span class="token keyword">if</span> sub <span class="token keyword">in</span> set_words<span class="token punctuation">:</span>            <span class="token keyword">if</span>  self<span class="token punctuation">.</span>helper<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">:</span> <span class="token punctuation">]</span><span class="token punctuation">,</span> set_words<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token keyword">return</span> <span class="token boolean">False</span></code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>　　Tree类的题目DFS做的有点多了，甚至都忘了，DFS，分治，贪心算法都是又可能转化为DP的，毕竟DP才是目前算法题的核心且比较有意思的部分。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>135 Candy</title>
      <link href="algorithms/135-candy/"/>
      <url>algorithms/135-candy/</url>
      
        <content type="html"><![CDATA[<blockquote><p>There are <em>N</em> children standing in a line. Each child is assigned a rating value.</p><p>You are giving candies to these children subjected to the following requirements:</p><ul><li>Each child must have at least one candy.</li><li>Children with a higher rating get more candies than their neighbors.</li></ul><p>What is the minimum candies you must give?</p><p><strong>Example 1:</strong></p><pre><code>Input: [1,0,2]Output: 5Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: [1,2,2]Output: 4Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.             The third child gets 1 candy because it satisfies the above two conditions.</code></pre></blockquote><p>　　比较容易理解的题目，但是却是Hard难度。比较好入手，却是卡了好几天，最后依赖Discuss才勉强总结出结果，此为解法一；之后在其他 LeetCode的题解上发现了一个很简单的思路，却无法证明正确性，希望这里可以将其证明出来。</p><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>　　此题最先想到的思路就是，利用凹函数/凸函数的极小值和极大值的特性，来搜索上坡下坡，遇到上坡理所当然的将所分配的candy数目相较于左边的candy数目+1，如果是下坡，那么就当作上坡的逆序列，反向上坡，思路并没有问题，但是卡在一个非常奇怪的点，那就是峰值Peak 的选取，回头来看，只需要选择上坡和下坡之中的最大值即可，但是实现过程中，这个思路始终得不到重视，反而遇到了诸多乱七八糟的实现困难，最终卡了数天之后不得不放弃，这其中主要就是迟迟无法实现，导致对这个思路的自我怀疑，总是想投机取巧般的小改一下函数，来尝试新方法，结果有不断产生新问题，最后自己都有点迷失方向了。现在想来，似乎在无意义的实践上浪费了很多时间，相反真正应该关注的思路分析上，甚少得到进步。多少有点试图用战术上的勤奋来掩盖战略上的懒惰，情绪上，思路卡顿的时候，自己过分急躁，有点考场上，答不出来，弃之可惜的感觉，没找到正确的打开方式，却慌不择路，心态濒临崩溃，这种感觉无论是当时还在现在都是不愿想起的，看来我还是无法坦然面对自己，一点儿小挫折，就呼天喊地的，真是缺乏意志的考验。</p><p>　　回到上坡/下坡，其实关于上坡可以仅仅根据上坡的长度来计算分配的总candy数目，因为起点是1颗，接下来则是递增为1的等差数列，亦即是起点为1的连续递增数量，可以轻松得到candy_sum,下坡也是一样的，唯一不确定的就是peak_candy，在同时拥有上坡和下坡的长度的时候，也可以推断出是 max(left,right) + 1；最后需要解决的是相邻的rating相同的情况，2个相同的rating可以把序列分割成2个独立的序列，分别计算candy_sum ，最后合并；相同的相邻区间长度大于2的情况，除开首尾部分，中间的candy都可以被置为1。</p><p>　　归纳起来，可以把数组模式当作 bottom -&gt; peak -&gt; bottom -&gt; equal 的组合，如果只出现bottom -&gt; peak -&gt; equal ，那么就当作前述模式的特例，这是一个比较有技巧性的归纳，因为针对此题，这个模式基本覆盖所有可能的上坡/下坡情况，特别是equal 可能出现在任何位置的时候，这个模式就被递归的细分下去了，这也是此解法正确性的核心。接下来只需要统计这个模式每一部分的长度即可，根据长度就能轻松计算出此序列的candy_sum</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">candy</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ratings<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    length <span class="token operator">=</span> len<span class="token punctuation">(</span>ratings<span class="token punctuation">)</span>    <span class="token keyword">if</span> length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span>    start <span class="token operator">=</span> <span class="token number">0</span>    sum_candy <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment" spellcheck="true"># init previous round bottom sum =1, because -1 each round to correct bottom double count problem</span>    i <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> i <span class="token operator">&lt;</span> length<span class="token number">-1</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># cur = i, next = i+1</span>        <span class="token comment" spellcheck="true"># botton -> peak : peak not included</span>        <span class="token keyword">while</span> i<span class="token operator">&lt;</span>length<span class="token number">-1</span> <span class="token operator">and</span> ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> ratings<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        left <span class="token operator">=</span> i <span class="token operator">-</span> start        start <span class="token operator">=</span> i        <span class="token comment" spellcheck="true"># peak -> next bottom : peak not included</span>        <span class="token keyword">while</span> i<span class="token operator">&lt;</span>length<span class="token number">-1</span> <span class="token operator">and</span> ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> ratings<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        right <span class="token operator">=</span> i <span class="token operator">-</span> start        start <span class="token operator">=</span> i        <span class="token comment" spellcheck="true"># count peak_candy and sum_candy</span>        peak_candy <span class="token operator">=</span> max<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>        sum_candy <span class="token operator">+=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>left<span class="token operator">//</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token punctuation">(</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>right<span class="token operator">//</span><span class="token number">2</span> <span class="token operator">+</span> peak_candy <span class="token operator">-</span> <span class="token number">1</span> <span class="token comment" spellcheck="true"># - 1 because left bottom included by previous round</span>        <span class="token comment" spellcheck="true"># handle equal </span>        <span class="token keyword">while</span> i<span class="token operator">&lt;</span>length<span class="token number">-1</span> <span class="token operator">and</span> ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> ratings<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            i <span class="token operator">+=</span> <span class="token number">1</span>            sum_candy <span class="token operator">+=</span> <span class="token number">1</span>        start <span class="token operator">=</span> i    <span class="token keyword">return</span> sum_candy</code></pre><p>　　需要注意的地方是，每次识别bottom -&gt; peak -&gt; bottom -&gt; equal 模式的时候，第一个bottom 会被当作前一个模式的第二个bottom重复计算，所以每轮sum_candy最后都需要减去bottom的candy数目，也就是1，同时初始化的时候，前一轮的模式sum_candy初值为1，就是为了抵消前一轮重复计算的bottom，也就是把第一轮当作只包含一个值rating[0]来计算。</p><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>　　一个非常简单明了的算法是，所有小朋友初始的candy都是1，从左至右，只针对上坡的情况，递增candy；接着从右至左，把原本下坡的情况变成上坡，继续递增candy。这样就轻松的得到了正确的candy分配方案，由于初值都是1，使得相邻相同rating的小朋友candy一直是1。</p><p>　　这个算法正确性完全依赖于上坡，而针对此题，最确定的candy分配方案就是上坡，因为下坡可能回面临不知道应该candy应该减到多少的不确定性问题，全部变成上坡，那问题就迎刃而解了。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">candy</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ratings<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    length <span class="token operator">=</span> len<span class="token punctuation">(</span>ratings<span class="token punctuation">)</span>    <span class="token keyword">if</span> length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span>    candys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>length    pre <span class="token operator">=</span> ratings<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">:</span>        cur <span class="token operator">=</span> ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">if</span> cur <span class="token operator">></span> pre<span class="token punctuation">:</span>            candys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> candys<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span>        pre <span class="token operator">=</span> cur    post <span class="token operator">=</span> ratings<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>length<span class="token number">-2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        cur <span class="token operator">=</span> ratings<span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token keyword">if</span> cur <span class="token operator">></span> post <span class="token operator">and</span> candys<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> candys<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            candys<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> candys<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>        post <span class="token operator">=</span> cur    <span class="token keyword">return</span> sum<span class="token punctuation">(</span>candys<span class="token punctuation">)</span></code></pre><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>　　此题的关键是发现上坡的计算的确定性，遗憾的是，虽然我发现上坡时稳定正确的，但是却没有好好利用起来，反而将上坡作为一种情况单独讨论，遇到下坡和平坡的时候，单独讨论也还好，只是合并结果的时候遇到了很大的困扰，而且下坡和平坡的时候很多candy无法确定的问题没找到根本原因；没有发现在这多种情况中，上坡的唯一性，错失突破口。</p><p>　　此外，在遇到难关的时候，迟迟无法突破的局面，使得自己试图把注意力从思路解析转移到实践的方法，注定是自欺欺人，核心的地方，还是需要多一点耐心，急躁的心态往往是饮鸩止渴；另一方面，自己的这个多少有点急躁的性格，也要多加利用，比如说，预料得到自己在过久的无法打开局面下，极为容易滋生出放弃的习惯，尽量不要让自己在一个进度上卡的太久，积极持续采取措施让自己的进度运转起来，否则放弃的后果是自己难以接受的，也容易白费了之前的一片苦心。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 下的多进程和多线程编程</title>
      <link href="algorithms/python-xia-de-duo-jin-cheng-he-duo-xian-cheng-bian-cheng/"/>
      <url>algorithms/python-xia-de-duo-jin-cheng-he-duo-xian-cheng-bian-cheng/</url>
      
        <content type="html"><![CDATA[<p>　　之前在并发写日志文件的时候简单的梳理了一下同步和异步的机制，不过对于Python的并发实践涉及还是比较浅显，现在这篇文章希望能彻底从代码角度来重新理解并发编程。</p><h2 id="什么是进程-Process-和-线程-Thread"><a href="#什么是进程-Process-和-线程-Thread" class="headerlink" title="什么是进程(Process) 和 线程(Thread)"></a>什么是进程(Process) 和 线程(Thread)</h2><blockquote><p>进程是操作系统分配资源的最小单元</p><p>线程是操作系统调度的最小单元</p><p>一个应用至少包括一个进程，而一个进程包含至少一个线程</p></blockquote><p>　　通常来说，多进程和多线程都是实现多任务的方式，而多任务的设计无论是进程还是线程，都遵循Master-Worker 模式，Master负责分配任务，Worker负责执行任务。在Python编程模型下，这二者的实践方法也非常类似。</p><p>　　从效果上来看，进程间的独立性更高一点，这体现在一个进程崩溃，不会影响其他进程和主进程的执行，比如，Apache的多进程模式。另一方面，进程由于是OS直接创建和调度的，所以相同的代码可能在不同OS下效果会有差异，这体现在OS对同时并发的进程数目是有一个数目限制的，一般情况下，这是一个经验数目的限制，并不是你的系统无法承载这么多的进程数，虽然在大部分情况下，这个限制都是日常使用中无法达到的上界，但是我认为这就跟IPv4 和 32 位系统类似，只是在当时的条件下，定下的一个无法轻易达到的上限标准，在高速的发展迭代下，成为的日后亟待解决的遗留问题。其次，进程的创建开销也因OS不同也有所差异，比如Unix/Linux 的fork开销就远小于WIndows的进程创建。</p><p>　　多线程模式则是多进程的精细化调度，我的理解是，这源于超线程技术的发展，使得一个CPU内核通过常用的寄存器和Cache等CPU内部常用部件的堆叠，达到模拟出2个CPU内核的效果，这当然是一个很优秀的技术，因为确实从软件层面可以把一个CPU线程当作内核直接调用，同时性能上也获得了几乎线性的提升，甚至在Unix/Linux查看CPU参数的指令lscpu下，CPU(s)都是直接显示的内核的线程数目，而非内核数目，常常让初识Linux的我感到非常迷惑。我相信，基于超线程的性能提升，编译器和各种软件的迭代是不可能忽视这么重要且好用的技术的。不过对于一个没有经历过这个技术更迭的人来说，什么多线程，多进程，本质上不是一个东西吗？搞得神神叨叨的。除此之外，大部分进程和线程的介绍，都基于定义的扩展，认真来讲，光看定义，就完全看不出这二者的差异，何况扩展。所以关于线程，虽然我知道的很多，比如说，线程是进程的执行单元，一个线程崩溃，进程则直接挂掉，所有线程共享进程的内存等等，但是却有完全不明白为什么会有这些设置。现在看来，当初没有搞明白这些，着实是有点遗憾，除了教育方式和教材的原因，自己的求知欲也被这些陡峭的学习曲线给淹没了，因为在一个每一个术语都不大理解的地方，哪有好奇心和求知欲的容身之处，早就被从小被训练好的敬畏心给覆盖了，不懂，可是我又不敢问！扯远了，回到线程上，从线程的起源来理解，这一些的设置就豁然开朗了，线程作为执行单元，和CPU提供的线程接口强相关的，而CPU本身就是整个计算机系统的最主要的执行部件，理所当然的线程更接近执行向，而当线程执行失败的时候，整个进程的执行理所当然的受阻挂掉，线程的作为执行者，应当获得进程所有的资源，所以进程下的线程都具备进程的全部资源权限。</p><p>　　在OS层面，线程的实现是有区别的，Windows的多线程效率是比多进程要高的，所以微软的IIS服务器基于多线程，显而易见的稳定性问题不如Apache。不够随着逐步的发展，现在又都是多进程+多线程的混合模式，搞得确实头大。不过参照，RISC 和 CISC的发展，Intel 后来的x86 和x64虽然都仍然维持的了 CISC的接口，但是在微指令层面，仍然是RISC的技术，这也使得其仍然可以从RISC的发展中获益，想到，当初的计算机组成的教材，也是突兀的抛出了微指令的概念，最后学完微指令也摸不着头，直到看到计算机体系结构中关于RISC和CISC的部分，才从重新理解的微指令架构。这次层面上，进程和线程的在Apache和IIS的表现形式或许多少能得到一点启示。不过当今Nginx的事件驱动的异步IO设计大行其道，Python的协程多少还算是找对了方向。</p><p>　　一个很好的关于进程和线程的比喻解释，形象的道出了二者的关系</p><blockquote><ul><li>计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。</li><li>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。编者注: 多核的CPU就像有了多个发电厂，使多工厂(多进程)实现可能。</li><li>进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。</li><li>一个车间里，可以有很多工人。他们协同完成一个任务。</li><li>线程就好比车间里的工人。一个进程可以包括多个线程。</li><li>车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。</li><li>可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</li><li>一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</li><li>还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。</li><li>这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。</li><li>不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</li></ul></blockquote><p>来自阮一峰的博客<a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html">进程和线程的简单解释</a></p><h2 id="Python的多进程编程-multiprocessing"><a href="#Python的多进程编程-multiprocessing" class="headerlink" title="Python的多进程编程 multiprocessing"></a>Python的多进程编程 multiprocessing</h2><p>　　首先给出单进程顺序执行的测试代码，给出一个计算$8^{20}$的任务，同时辅以sleep 2s的任务。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> os<span class="token keyword">def</span> <span class="token function">long_time_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'当前进程: &amp;#123;&amp;#125;'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"结果: &amp;#123;&amp;#125;"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">8</span> <span class="token operator">**</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'当前母进程: &amp;#123;&amp;#125;'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        long_time_task<span class="token punctuation">(</span><span class="token punctuation">)</span>    end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"用时&amp;#123;&amp;#125;秒"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>当前母进程<span class="token punctuation">:</span> <span class="token number">33121</span>当前进程<span class="token punctuation">:</span> <span class="token number">33121</span>结果<span class="token punctuation">:</span> <span class="token number">1152921504606846976</span>当前进程<span class="token punctuation">:</span> <span class="token number">33121</span>结果<span class="token punctuation">:</span> <span class="token number">1152921504606846976</span>用时<span class="token number">4.004350185394287</span>秒</code></pre><p>　　基本是sleep 的4s，计算任务基本不耗时间</p><p>　　接下来是多进程改写</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token keyword">import</span> os<span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">long_time_task</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'子进程: &amp;#123;&amp;#125; - 任务&amp;#123;&amp;#125;'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"结果: &amp;#123;&amp;#125;"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">8</span> <span class="token operator">**</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'当前母进程: &amp;#123;&amp;#125;'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    p1 <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>long_time_task<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    p2 <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>long_time_task<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'等待所有子进程完成。'</span><span class="token punctuation">)</span>    p1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    p2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    p1<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    p2<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"总共用时&amp;#123;&amp;#125;秒"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>当前母进程<span class="token punctuation">:</span> <span class="token number">33121</span>等待所有子进程完成。子进程<span class="token punctuation">:</span> <span class="token number">34270</span> <span class="token operator">-</span> 任务<span class="token number">1</span>子进程<span class="token punctuation">:</span> <span class="token number">34271</span> <span class="token operator">-</span> 任务<span class="token number">2</span>结果<span class="token punctuation">:</span> <span class="token number">1152921504606846976</span>结果<span class="token punctuation">:</span> <span class="token number">1152921504606846976</span>总共用时<span class="token number">2.009559392929077</span>秒</code></pre><p>　　并行的效率得到体现，执行时间减半。</p><p>　　p.join()的理解是，主进程会等待子进程执行完毕，才开始继续从p.join()之后开始执行，否则主进程会直接输出总共用时，然后子进程接着执行完再输出。</p><pre><code>当前母进程: 33121等待所有子进程完成。子进程: 34669 - 任务1总共用时0.002809762954711914秒子进程: 34670 - 任务2结果: 1152921504606846976结果: 1152921504606846976</code></pre><p>　　最后就是对进程管理调度，由于OS的不同以及提高CPU利用率的需求，更是因为程序员懒得一个一个手动启动Process进程，产生的一个统一的进程管理的接口的需求，这就诞生的进程池Pool的接口。</p><p>　　Pool类可以提供指定数量的进程供用户调用，当有新的请求提交到Pool中时，如果进程池还没有满，就会创建一个新的进程来执行请求。如果池满，请求就会告知先等待，直到池中有进程结束，才会创建新的进程来执行这些请求。</p><p>下面介绍一下multiprocessing 模块下的Pool类的几个方法：</p><ol><li>apply_async</li></ol><p>函数原型：apply_async(func[, args=()[, kwds={}[, callback=None]]])</p><p>其作用是向进程池提交需要执行的函数及参数， 各个进程采用非阻塞（异步）的调用方式，即每个子进程只管运行自己的，不管其它进程是否已经完成。这是默认方式。</p><ol start="2"><li>map()</li></ol><p>函数原型：map(func, iterable[, chunksize=None])</p><p>Pool类中的map方法，与内置的map函数用法行为基本一致，它会使进程阻塞直到结果返回。 注意：虽然第二个参数是一个迭代器，但在实际使用中，必须在整个队列都就绪后，程序才会运行子进程。</p><ol start="3"><li>map_async()</li></ol><p>函数原型：map_async(func, iterable[, chunksize[, callback]])<br>与map用法一致，但是它是非阻塞的。其有关事项见apply_async。</p><ol start="4"><li>close()</li></ol><p>关闭进程池（pool），使其不在接受新的任务。</p><ol start="5"><li>terminate()</li></ol><p>结束工作进程，不在处理未处理的任务。</p><ol start="6"><li>join()</li></ol><p>主进程阻塞等待子进程的退出， join方法要在close或terminate之后使用。</p><p>　　这里设计一个有意思设计用例，来验证并观察进程的行为模式是否按照理论上的理解运行，即是创建大小为4的Pool，却同时启动5个计算任务，最后观察运行时间，理论上应该是开始的4个进程是并行，后面的任务等前面的进程空出来之后，再开始安排进程来计算。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Pool<span class="token punctuation">,</span> cpu_count<span class="token keyword">import</span> os<span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">long_time_task</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'子进程: &amp;#123;&amp;#125; - 任务&amp;#123;&amp;#125;'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"结果: &amp;#123;&amp;#125;"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">8</span> <span class="token operator">**</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"CPU内核数:&amp;#123;&amp;#125;"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'当前母进程: &amp;#123;&amp;#125;'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    p <span class="token operator">=</span> Pool<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        p<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>long_time_task<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'等待所有子进程完成。'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"总共用时&amp;#123;&amp;#125;秒"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>CPU内核数<span class="token punctuation">:</span><span class="token number">64</span>当前母进程<span class="token punctuation">:</span> <span class="token number">33121</span>等待所有子进程完成。子进程<span class="token punctuation">:</span> <span class="token number">37454</span> <span class="token operator">-</span> 任务<span class="token number">0</span>子进程<span class="token punctuation">:</span> <span class="token number">37455</span> <span class="token operator">-</span> 任务<span class="token number">1</span>子进程<span class="token punctuation">:</span> <span class="token number">37456</span> <span class="token operator">-</span> 任务<span class="token number">2</span>子进程<span class="token punctuation">:</span> <span class="token number">37457</span> <span class="token operator">-</span> 任务<span class="token number">3</span>结果<span class="token punctuation">:</span> <span class="token number">1152921504606846976</span>结果<span class="token punctuation">:</span> <span class="token number">1152921504606846976</span>子进程<span class="token punctuation">:</span> <span class="token number">37454</span> <span class="token operator">-</span> 任务<span class="token number">4</span>结果<span class="token punctuation">:</span> <span class="token number">1152921504606846976</span>结果<span class="token punctuation">:</span> <span class="token number">1152921504606846976</span>结果<span class="token punctuation">:</span> <span class="token number">1152921504606846976</span>总共用时<span class="token number">4.115360736846924</span>秒</code></pre><p>结果跟预想的基本一致，是并行的4个任务的2s+后续一个任务的2s，总共4s+</p><p>由于Python的GIL（全局解释器锁）的存在，多线程的代码实际上一个时刻只有一个线程在执行，所以如果要充分利用多核CPU资源，一般都是通过多进程来实现的。</p><p>　　Add，多进程的数据共享和通信，multiprocessing.Queue 使用实例</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token punctuation">,</span> Queue<span class="token keyword">import</span> os<span class="token punctuation">,</span> time<span class="token punctuation">,</span> random<span class="token comment" spellcheck="true"># 写数据进程执行的代码:</span><span class="token keyword">def</span> <span class="token function">write</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Process to write: &amp;#123;&amp;#125;'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> value <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Put %s to queue...'</span> <span class="token operator">%</span> value<span class="token punctuation">)</span>        q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>value<span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 读数据进程执行的代码:</span><span class="token keyword">def</span> <span class="token function">read</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Process to read:&amp;#123;&amp;#125;'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        value <span class="token operator">=</span> q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Get %s from queue.'</span> <span class="token operator">%</span> value<span class="token punctuation">)</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 父进程创建Queue，并传给各个子进程：</span>    q <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>    pw <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>write<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    pr <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>read<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 启动子进程pw，写入:</span>    pw<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 启动子进程pr，读取:</span>    pr<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 等待pw结束:</span>    pw<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># pr进程里是死循环，无法等待其结束，只能强行终止:</span>    pr<span class="token punctuation">.</span>terminate<span class="token punctuation">(</span><span class="token punctuation">)</span>Process to write<span class="token punctuation">:</span> <span class="token number">39190</span>Put A to queue<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Process to read<span class="token punctuation">:</span><span class="token number">39191</span>Get A <span class="token keyword">from</span> queue<span class="token punctuation">.</span>Put B to queue<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Get B <span class="token keyword">from</span> queue<span class="token punctuation">.</span>Put C to queue<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Get C <span class="token keyword">from</span> queue<span class="token punctuation">.</span></code></pre><p>##</p><h2 id="Python-的多线程编程-Threading"><a href="#Python-的多线程编程-Threading" class="headerlink" title="Python 的多线程编程 Threading"></a>Python 的多线程编程 Threading</h2><p>　　接口其实跟多进程一样</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">long_time_task</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'当前子线程: &amp;#123;&amp;#125; - 任务&amp;#123;&amp;#125;'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"结果: &amp;#123;&amp;#125;"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">8</span> <span class="token operator">**</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span>    start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'这是主线程：&amp;#123;&amp;#125;'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>    t1 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>long_time_task<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    t2 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>long_time_task<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    t1<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    t2<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"总共用时&amp;#123;&amp;#125;秒"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>这是主线程：MainThread当前子线程<span class="token punctuation">:</span> Thread<span class="token number">-1316</span> <span class="token operator">-</span> 任务<span class="token number">1</span>当前子线程<span class="token punctuation">:</span> Thread<span class="token number">-1317</span> <span class="token operator">-</span> 任务<span class="token number">2</span>结果<span class="token punctuation">:</span> <span class="token number">1152921504606846976</span>结果<span class="token punctuation">:</span> <span class="token number">1152921504606846976</span>总共用时<span class="token number">2.0029757022857666</span>秒</code></pre><p>连结果都跟多进程一样，不是说GIL导致始终是单线程的性能吗？观察任务的组成会发现，计算任务基本不耗时间，主要是sleep ,但是sleep在运行中是会被当作类似IO的操作，被识别为闲置的线程，这时候GIL直接就开始切换线程了，所以sleep的时间实际上是并行执行的，因为不依赖CPU计算，依此推测计算部分还是应该是单线程的，因为依赖CPU，那只需要增加计算任务的时间即可，那就加大指数为 $8^{1000000}$</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">long_time_task</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'当前子线程: &amp;#123;&amp;#125; - 任务&amp;#123;&amp;#125;'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    t <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"结果: &amp;#123;&amp;#125;"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">8</span> <span class="token operator">**</span> <span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'计算用时： '</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>t<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 单独执行时间 long_time_task(1)</span>计算时间 <span class="token punctuation">:</span> <span class="token number">11.462863683700562</span>总共用时<span class="token number">13.43696641921997</span>秒<span class="token comment" spellcheck="true"># 多线程时间 </span>计算时间 <span class="token punctuation">:</span> <span class="token number">22.85654377937317</span>计算时间 <span class="token punctuation">:</span> <span class="token number">23.088494300842285</span>总共用时<span class="token number">25.10121512413025</span>秒</code></pre><p>结果上，总计算时间是翻倍的，但是每个线程的输出时间却是翻倍后的22s，而不是单线程的11s，考虑到并发执行，每个线程执行到任何一个时间，都有可能被中断，切换到其他进程，这里的单线程输出时间就可以理解了，那就是线程1执行玩计算任务，还没输出时间，就被切换到线程2的计算来了，最后统一输出线程1和线程2的时间，那么结果二者都是22s左右。总之，可以确定的计算密集型任务，Python的GIL充分保证的单线程的性能。</p><p>　　多线程的数据共享和通信，寻找线程安全的数据结构即可，queue.Queue就是的</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> queue <span class="token keyword">import</span> Queue<span class="token keyword">import</span> random<span class="token punctuation">,</span> threading<span class="token punctuation">,</span> time<span class="token comment" spellcheck="true"># 生产者类</span><span class="token keyword">class</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">:</span>        threading<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token operator">=</span>name<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>queue <span class="token operator">=</span> queue    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&amp;#123;&amp;#125; is producing &amp;#123;&amp;#125; to the queue!"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>self<span class="token punctuation">.</span>getName<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>randrange<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">5</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s finished!"</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>getName<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 消费者类</span><span class="token keyword">class</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">:</span>        threading<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token operator">=</span>name<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>queue <span class="token operator">=</span> queue    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            val <span class="token operator">=</span> self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&amp;#123;&amp;#125; is consuming &amp;#123;&amp;#125; in the queue."</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>self<span class="token punctuation">.</span>getName<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">)</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>randrange<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s finished!"</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>getName<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    queue <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>    producer <span class="token operator">=</span> Producer<span class="token punctuation">(</span><span class="token string">'Producer'</span><span class="token punctuation">,</span> queue<span class="token punctuation">)</span>    consumer <span class="token operator">=</span> Consumer<span class="token punctuation">(</span><span class="token string">'Consumer'</span><span class="token punctuation">,</span> queue<span class="token punctuation">)</span>    producer<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    consumer<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    producer<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    consumer<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'All threads finished!'</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="计算密集型-vs-IO密集型"><a href="#计算密集型-vs-IO密集型" class="headerlink" title="计算密集型 vs IO密集型"></a>计算密集型 vs IO密集型</h2><p>　　对于计算密集型任务，python下的多线程改写是不会有性能提升的，只有多进程才能利用多核CPU，这是明显区别于其他语言的特点，因为在其他高效语言中，多进程和多线程都是作为并发的手段，同时改善程序性能的，而且本身Python作为脚本语言，在计算密集型任务面前运行效率就不高，此时更高阶的手段是用C语言重构 或者 引入高效的其他库来代替。</p><p>　　对于IO密集型，Python本身的多线程就能较好的应对，因为线程调度保证了IO任务的并行执行，此时就算是CPU有多个线程资源，任务本身就无法充分利用，所以Python的单线程限制并不构成瓶颈，就算用其他语言改写成真多线程，提升也不明显，所以类似web应用的IO密集型任务，Python足矣。</p><h2 id="异步IO-，事件驱动模型，-协程，单进程单线程模型"><a href="#异步IO-，事件驱动模型，-协程，单进程单线程模型" class="headerlink" title="异步IO ，事件驱动模型， 协程，单进程单线程模型"></a>异步IO ，事件驱动模型， 协程，单进程单线程模型</h2><p>　　考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，才需要多进程模型或者多线程模型来支持多任务并发执行。</p><p>　　现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。</p><p>　　对应到Python语言，单线程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。</p><h2 id="Conclude"><a href="#Conclude" class="headerlink" title="Conclude"></a>Conclude</h2><p>　　用代码完整的梳理了一下并发下的进程和线程，同时总结了一下使用场景，很多知识都连接起来了，接下来一个重要的部分就是Python的核心部分，异步IO编程模型-协程</p><p>　　关于协程的实践部分，写篇文章会主要介绍。</p><p>References:</p><p><a href="https://zhuanlan.zhihu.com/p/46368084">一文看懂Python多进程与多线程编程</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017631469467456">进程 vs 线程 廖雪峰</a></p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p03_communicating_between_threads.html">线程间通信 Python3 CookBook</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>132. Palindrome Partitioning II</title>
      <link href="algorithms/132-palindrome-partitioning-ii/"/>
      <url>algorithms/132-palindrome-partitioning-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Given a string <code>s</code>, partition <code>s</code> such that every substring of the partition is a palindrome.</p><p>Return <em>the minimum cuts needed</em> for a palindrome partitioning of <code>s</code>.</p><p><strong>Example 1:</strong></p><pre><code>Input: s = &quot;aab&quot;Output: 1Explanation: The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut.</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: s = &quot;a&quot;Output: 0</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: s = &quot;ab&quot;Output: 1</code></pre><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 2000</code></li><li><code>s</code> consists of lower-case English letters only.</li></ul></blockquote><p>　　初识回文字符串的时候，觉得这是个很棘手的问题，毕竟涉及到正序逆序的检索问题，光是字符串匹配和正则表达式都能整出DFA和NFA这种复杂的状态机，何况是回文字符这种感觉状态机似乎都没什么办法的问题。没想到的是，回文字符的识别手段如此简单粗暴，就是寻找中心点，然后从中点向外的边扩展边匹配，原理上是没问题的，但是一般在讲解玩暴力解法之后，都会给出更加优雅精妙的优化版算法，但是在回文字符串的问题上，似乎到这里就戛然而止了，可能跟自己接触回文字符串的方式有关，因为自己并不是在教材上看到这个问题的，而是直接在OJ上面临这个问题的，最初理所当然的用暴力解法先过一遍，没想到居然AC了，后面就没有对这个问题进行过更多的思考了，直到遇到这个加强版的回文字符问题，检测substring是否是回文字符，并且暴力解法完全无法AC，这才逼迫自己想办法优化暴力解法。</p><h3 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h3><p>　　substring 回文字符检测，在132题之前，其实有一个131 Palindrome Partitioning I 的 medium版本，要求输出所有可能的s 的 substring 切分，并且以列表的形式返回所有可能的切分，原理上此问题是131问题的子集，因为既然都已经输出了所有可能的切分，那么搜索最短切分只需要列出所有切分的长度，取最小即可；然而在OJ的设置上，这样是没办法在132上AC的，因为我在131用的仍然是暴力的解法小改版，只不过在切分的时候发现可能会面临重复递归调用的问题，也就是动态规划DP常常解释的，重复子结构的问题，我采取的备忘录的方式来缓解自顶向下调用时的重复调用问题，在完全没有构思出DP递推式 的前提下，就这样压线AC了，搞得我自己都不知道，这个AC的代码究竟用的是递归还是DP。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 131 Palindrome Partitioning I</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        memo <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125;</span>        self<span class="token punctuation">.</span>splitPalindrome<span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">,</span> memo<span class="token punctuation">)</span>        <span class="token keyword">return</span> res    <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">if</span> s <span class="token keyword">in</span> memo<span class="token punctuation">:</span>            <span class="token keyword">return</span> memo<span class="token punctuation">[</span>s<span class="token punctuation">]</span>        news <span class="token operator">=</span> <span class="token string">'_'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        mid <span class="token operator">=</span> len<span class="token punctuation">(</span>news<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            pre <span class="token operator">=</span> mid <span class="token operator">-</span> i            post <span class="token operator">=</span> mid <span class="token operator">+</span> i             <span class="token keyword">if</span> news<span class="token punctuation">[</span>pre<span class="token punctuation">]</span> <span class="token operator">!=</span> news<span class="token punctuation">[</span>post<span class="token punctuation">]</span><span class="token punctuation">:</span>                memo<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        memo<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token keyword">def</span> <span class="token function">splitPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">,</span> rs<span class="token punctuation">,</span> res<span class="token punctuation">,</span>memo<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>rs<span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>rs<span class="token operator">+</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>isPalindrome<span class="token punctuation">(</span>s<span class="token punctuation">[</span> <span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>splitPalindrome<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">:</span> <span class="token punctuation">]</span><span class="token punctuation">,</span> rs <span class="token operator">+</span> <span class="token punctuation">[</span>s<span class="token punctuation">[</span> <span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">,</span> memo<span class="token punctuation">)</span>        <span class="token keyword">return</span></code></pre><p>　　主要思路还是围绕DFS为主，通过不断的切分s，达到给rs添加成员的目的，直到最后s划分完毕，添加到res中，围绕一个s不断划分是有指数级别的可能性，针对不同的切分区域可能会有相同的substring出现，用memo来缓存，最终AC.</p><p>　　相同的思路在此题是行不通的，这也是这题是Hard的缘由，故意设置的陷阱，所以就需要找到可以优化的点。</p><p>　　首先，搜索最小切分次数和遍历所有切分可能，其实还是有比较大的优化空间，因为前者的达到最小切分条件即可立即返回，后者则是需要遍历所有可能才返回。难点就是如何定义最小切分条件，其实最小切分条件这个定义似乎跟最优子结构的定义很相似，比如，算法导论 讲到 动态规划时，解释最优子结构的核心的时候用到的切钢筋的示例，给定一个长度为n的钢筋，其最优的切割方法实际是确定的，这个确定的切割方法就可以作为一个结果供后续上层调用，即是，最优解一定由子问题的最优解组成。问题是，除了长度n的约束外，最主要的约束条件是string的起点和终点，即$s[i][j]$ ，因为不同于切钢筋，不同部位的的钢筋，只需要长度一样，就看作同样的；这里不同的substring，是否是回文字符的可能性不同，那么这就涉及到是否可以的切分的一个约束条件，也就是作为最优子结构，还有一个前提的是否是回文字符的条件，这就需要知道所有可能的$s[i][j]$是否是回文字符串的情况，貌似这个问题本身也是一个至少需要$O(N^2)$的复杂度的问题，因为遍历所有可能的substring 至少需要$O(N^2)$；其实当初分析到这里，心里觉得多少有点没底，所以也就没朝着这个方向努力，还在想各种其他Trick，最后都没有成功，还是回到了先如何实现判断所有substring是否是回文的方向上来。</p><h4 id="最长回文子串问题-Longest-Palindrome-Substring"><a href="#最长回文子串问题-Longest-Palindrome-Substring" class="headerlink" title="最长回文子串问题 Longest Palindrome Substring"></a>最长回文子串问题 Longest Palindrome Substring</h4><p>　　曾经看过一篇<a href="https://segmentfault.com/a/1190000003914228">最长回文子串的博文</a>，除了1.暴力解法和2.在间隙中添加标记字符来作为对称中点来解决奇数和偶数字符串对称轴不同的问题的$O(N^2)$解法，还有一种在解法2的基础上寻找非常细微的优化点的Manacher算法，不过这个算法过于精细，以至于我只记得大概的算法优化点，完全不记得细节了，所以没办法用上，这个之后再讨论；但是篇博文最后的动态规划解法比较好理解，直接就是遍历$s[i][j]$的上三角部分，然后根据dp递推式$dp[i][j] = dp[i+1][j-1] ,if \quad s[i]==s[j] $ ，由于$dp[i][j]==dp[j][i]$，所以只需要求出上三角即可</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># dp 求substring 上三角是否是 回文字符</span>    <span class="token keyword">def</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        length <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span><span class="token operator">*</span>length <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">:</span>            j <span class="token operator">=</span> i            <span class="token keyword">while</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">and</span> <span class="token punctuation">(</span>i<span class="token operator">-</span>j<span class="token operator">&lt;</span><span class="token number">2</span> <span class="token operator">or</span> dp<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>                j <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> dp</code></pre><p>时间复杂度$O(N^2)$，似乎和改进后的暴力解法差不多，不过够用了。</p><p>后来受到这个启发，发现改进的暴力解法$O(N^2)$也可以AC，这里也直接给出</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 普通 O(N**2) 解法</span>    <span class="token keyword">def</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        length <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        d <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span><span class="token operator">*</span>length <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span>        news <span class="token operator">=</span> <span class="token string">'_'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>news<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            d<span class="token punctuation">[</span>i<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>            end <span class="token operator">=</span> min<span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">(</span>news<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token punctuation">)</span>            flag <span class="token operator">=</span> <span class="token boolean">True</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                pre <span class="token operator">=</span> i<span class="token operator">-</span>j                post <span class="token operator">=</span> i<span class="token operator">+</span>j                <span class="token keyword">if</span> news<span class="token punctuation">[</span>pre<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'_'</span> <span class="token operator">and</span>  flag<span class="token punctuation">:</span>                    <span class="token keyword">if</span>  news<span class="token punctuation">[</span>pre<span class="token punctuation">]</span> <span class="token operator">==</span> news<span class="token punctuation">[</span>post<span class="token punctuation">]</span><span class="token punctuation">:</span>                        d<span class="token punctuation">[</span>pre<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>post<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        flag <span class="token operator">=</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> d</code></pre><h4 id="DFS搜索最短切分"><a href="#DFS搜索最短切分" class="headerlink" title="DFS搜索最短切分"></a>DFS搜索最短切分</h4><p>　　接下来就是常规的，DFS来切分并累加切分次数，跟131题套路类似，都需要判断切分前是否直接本身就是回文，必须满足这个条件之后才能继续切分</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># s2-1 自顶向下 备忘录dp AC 456ms</span>    <span class="token keyword">def</span> <span class="token function">calLength</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> start<span class="token punctuation">,</span> s<span class="token punctuation">,</span> dp<span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> start <span class="token operator">==</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> start <span class="token operator">==</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            memo<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>            <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token keyword">if</span> dp<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            memo<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>            <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token keyword">if</span> memo<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> memo<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> float<span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>start<span class="token punctuation">,</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> dp<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">:</span>                res <span class="token operator">=</span> min<span class="token punctuation">(</span>res<span class="token punctuation">,</span> self<span class="token punctuation">.</span>calLength<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> dp <span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">)</span>        memo<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> res <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> memo<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span></code></pre><p>　最后成功AC</p><p>　除了DFS，还在想是否可以改造成DP算法，顺便把之前没有写成的递推公式也顺便推导一下，这个阶段的DP和前面求最长回文子串不是一个问题，所以递推式需要重新归纳总结：</p><p>$dp[i][j] = min(dp[i][k] + dp[k+1][j] + 1) ,if \quad s[i:j+1]$不是回文字符串</p><p>由于需要用到 dp 中i-j 之间的所有值，可以采用类似希尔排序的类似的逐渐递增gap的方式，每个新的gap计算之前，旧的更小的gap的所有片段dp值都已经计算出来</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">calLength</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">,</span> dp <span class="token punctuation">)</span><span class="token punctuation">:</span>        length <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        dp_2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>length <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>length<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            dp_2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">return</span> dp_2        <span class="token comment" spellcheck="true"># s1 gap dp</span>        <span class="token keyword">for</span> gap <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>length<span class="token operator">-</span>gap<span class="token punctuation">)</span><span class="token punctuation">:</span>                j <span class="token operator">=</span> i<span class="token operator">+</span>gap                <span class="token keyword">if</span> <span class="token operator">not</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    r <span class="token operator">=</span> float<span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span>                    <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>                        r <span class="token operator">=</span> min<span class="token punctuation">(</span>r<span class="token punctuation">,</span> dp_2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dp_2<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>                    dp_2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> r                <span class="token keyword">return</span> dp_2</code></pre><p>时间复杂度$O(N^3)$，结果自然也是TLE，不过目前至少没看到算法层面的错误，或许能有办法优化成$O(N^2)$的算法，目前还没看出怎么改进。</p><h3 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h3><p>　　从原来上来讲，其实这应该是很微妙的一个优化，就是一步一步计算每一个字符包括间隙为中心点的回文字符的最大长度RL[i]，由于i之前的RL都是已经计算出来的，寻找某个包括i的pos为中心的最长RL[pos]，此时以pos为对称轴，寻找i的对称点j</p><p><img src="1.png" alt="1"></p><p><img src="2.png" alt="2"></p><p>由于RL[j]已知，那么这个RL[j]就可以做RL[i]的起点，这样RL[i]就不需要从0开始计算，但是由于RL[j]的长度可能会超过pos，这样就需要分2种情况来寻找R[i]的起点,一种是较短的情况，如上图，另一种是超过pos，如下图，就需要降低RL[i]的起点为从蓝色部分开始</p><p><img src="3.png" alt="3"></p><p>当然还有最后一种情况，就是i已经超过了maxRight ，则需要从0开始计算<img src="4.png" alt="4"></p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">manacher</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>  s <span class="token operator">=</span> <span class="token string">'_'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>s<span class="token punctuation">)</span>  rl <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>  maxRight <span class="token operator">=</span> <span class="token number">0</span>  pos <span class="token operator">=</span> <span class="token number">0</span>  maxLen <span class="token operator">=</span> <span class="token number">0</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> i <span class="token operator">&lt;</span> maxRight<span class="token punctuation">:</span>      rl<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">(</span>rl<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>pos<span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> maxRight<span class="token operator">-</span>i<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>      rl<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>    <span class="token comment" spellcheck="true"># 尝试扩展边界rl[i]</span>    <span class="token keyword">while</span> i<span class="token operator">-</span>rl<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">and</span> i<span class="token operator">+</span>rl<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>i<span class="token operator">-</span>rl<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>i<span class="token operator">+</span>rl<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>      rl<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">if</span> rl<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>i<span class="token number">-1</span><span class="token operator">></span>maxRight<span class="token punctuation">:</span>      maxRight <span class="token operator">=</span> rl<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> i <span class="token operator">-</span><span class="token number">1</span>      pos <span class="token operator">=</span> i    maxLen <span class="token operator">=</span> max<span class="token punctuation">(</span>maxLen<span class="token punctuation">,</span> rl<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> maxLen<span class="token number">-1</span></code></pre><p>虽说声称时间复杂度是$O(N)$，但是我看代码怎么都像是$O(N^2)$，起码最坏的情况下我想应该是的，假如每次求得的对称RL[j]都接近0，那么RL[i]就得从头遍历，但是另一方面，RL[j]本身就很快的返回了，如果RL[j]很长，那么对应的RL[i]就收益，可以高起点开始计算；从这个角度来看，起码能节省一半的时间，正常情况下应该介于$O(N)$和$O(N^2)$之间，真实情况如何，我也不是很确定。</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>　　终于有机会把回文字符这块好好的补习了一下，初识manacher算法认真来讲，是有点失望的，相比于NFA还有最短路径之类的神奇算法，这个有点小打小闹的优化改进，不过还是不得不佩服，就这么一个$O(N^2)$的算法，硬是被人找到机会给优化掉了，真的不能小看程序员想要改进算法的决心啊！</p><p>Reference:</p><p><a href="https://segmentfault.com/a/1190000003914228">最长回文子串-Manacher算法</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 126. Word Ladder II</title>
      <link href="algorithms/leetcode-126-word-ladder-ii/"/>
      <url>algorithms/leetcode-126-word-ladder-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find all shortest transformation sequence(s) from <em>beginWord</em> to <em>endWord</em>, such that:</p><ol><li>Only one letter can be changed at a time</li><li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li></ol><p><strong>Note:</strong></p><ul><li>Return an empty list if there is no such transformation sequence.</li><li>All words have the same length.</li><li>All words contain only lowercase alphabetic characters.</li><li>You may assume no duplicates in the word list.</li><li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li></ul><p><strong>Example 1:</strong></p><pre><code>Input:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Output:[  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]]</code></pre><p><strong>Example 2:</strong></p><pre><code>Input:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]Output: []Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation</code></pre></blockquote><p>　　这是一道似曾相识的Hard题，却意外的卡了好几天，好在最后还是凭借自己完成的算法方案，差一点AC，TLE的程度，最后试图优化无果，搜索Discuss，发现Python高赞方案跟自己的如出一辙，只不过在最费时的状态图构建上，做了很好的优化，借助这个优化思路，也很快获得了AC，学到了很好的优化经验。</p><p>　　说到似曾相识，是因为自己曾经做过的Frog Jump 也是一道Hard题，现在回想起来，那可能是自己独立实现AC的第一道Hard，这才有了后来渐渐想要不借助提示挑战Hard的勇气。虽说Frog Jump 是一道Hard，但是解题过程意外的轻松，很容易的就找到了算法方案，基本就是常规的思路，然后实现代码过程也没遇到很多问题，最后一次AC，倍感意外。彼时就有点反思道，是不是自己高估了Hard，所以被这个束缚，才一直觉得自己搞不定才没有去尝试。现在想来，可能只是因为经验不足，用于解题的算法工具不够充足才会有Hard无法突破的心理障碍，比如，Frog Jump , Jump Game 的多种变种以及这题Word Ladder 基本都跟算法（第四版）中的 确定有穷状态自动机DFA 和 不确定有穷状态自动机 NFA的解法一致，无论是最初AC，还是后来的Debug优化，基本都是围绕Pattern 构建的状态图流转即可。此题甚至都无需构建状态图，只需要寻找合适的数据结构来标记状态即可，多少跟图论算法比较相似。</p><h3 id="算法思路分析"><a href="#算法思路分析" class="headerlink" title="算法思路分析"></a>算法思路分析</h3><p>　　本质上，这其实是一道图论题目，在wordList提供的图之中，搜索从beginWord 到 endWord 的最短路径，最短路径可以直接用BFS求解，因为题设只需要输出最短路径的可能值即可，所以找到终点之后，程序即可中止。</p><p>　　算法上，还是延续之前的各种Jump的变种思路，难点应该还是在于实现上，毕竟这些变种题会有各种约束条件的变化导致代码上会有些许不同，这个恐怕要在写代码的时候才能意识得到。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>　　跟DFA/NFA类似，先把wordList转化成图表达，搜索所有的有连接关系的单词对，并保存起来。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 判断 字符串 s1 s2 是否有边连接</span><span class="token keyword">def</span> <span class="token function">isPair</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">:</span>    c <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span>j <span class="token keyword">in</span> zip<span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> c <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> i <span class="token operator">!=</span> j<span class="token punctuation">:</span>            c <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> c <span class="token operator">==</span> <span class="token number">1</span><span class="token comment" spellcheck="true"># word 在wordList 搜索所有可能的边</span><span class="token keyword">def</span> <span class="token function">constructidx</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word<span class="token punctuation">,</span> wordList<span class="token punctuation">,</span> des2src<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> w <span class="token keyword">in</span> wordList<span class="token punctuation">:</span>    <span class="token keyword">if</span> w <span class="token operator">!=</span> word <span class="token operator">and</span> self<span class="token punctuation">.</span>isPair<span class="token punctuation">(</span>w<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">:</span>        des2src<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>word<span class="token punctuation">)</span>        des2src<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>w<span class="token punctuation">)</span>    <span class="token keyword">return</span></code></pre><p>　　自己虽然知道在搜索连接边的isPair写的有点简单粗暴，有很大的优化空间，因为随着wordList的length增大，这个调用次数也是呈指数上升的，所以isPair的一点小优化能极大的降低TLE概率，事实也确实如此。无奈自己面对这样的基础优化，还是有点无能无力，似乎陷入了这个第一想法就得到结果的算法思路限制，无法彻底的想到新思路，最后在Discuss找到了这一段的简洁实现，利用wordList_set的在搜索阶段的改进很明显，除此之外以word为基础重新构建的方法会快一点，毕竟一个单词每一个位置都用26个字母重新替换一下，也需要$O(N)$的时间复杂度，综合起来$O(MN)$；而上述的代码可能需要$O(M^2)$， 其中M代表wordList 长度，N代表word本身的长度，这个角度来看，M较大的可能性还是比较高的。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">constructidx_1</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word<span class="token punctuation">,</span> wordList_set<span class="token punctuation">,</span> des2src<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> char <span class="token keyword">in</span> string<span class="token punctuation">.</span>ascii_lowercase<span class="token punctuation">:</span>            tmp <span class="token operator">=</span> word<span class="token punctuation">[</span> <span class="token punctuation">:</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> char <span class="token operator">+</span> word<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">]</span>            <span class="token keyword">if</span> tmp <span class="token keyword">in</span> wordList_set<span class="token punctuation">:</span>                des2src<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># des2src[tmp].add(word)</span>    <span class="token keyword">return</span></code></pre><p>　　也是这一段的优化最终将TLE的代码转化为AC的代码</p><p>　　接下来就是BFS搜索的过程了，自己在写这段代码的时候，不知道是不是脑子抽风了，又犯了还没想好整体构思，就提枪上阵的毛病，本来是一段很基础的BFS搜索的过程，结果由于访问状态标记的代码没想明白，就随意的放置访问状态的代码，结果调试了1天，才发现问题所在，期间出现了各种匪夷所思的访问状态变化的问题，搞得自己经常莫名其妙，各种怀疑是不是其他地方出了问题。实在是有点不应该。</p><p>　　可能是以前的BFS都需要遍历所有的节点之后，自动返回，所以直接采用queue的方式，queue为空自动返回即可，不需要标记BFS目前在第几层，然而此题是需要求最短路径，显然是需要采取层次遍历的方式依此进行，所以用q, q_next依此交替的方式，q是目前的遍历层次，q_next是接下来需要遍历的层次；其次，状态标记visited 的问题，此题由于要输出所有可能的最短路径，所以不仅进入q_next的新节点需要标记回溯路径，有可能q_next中的某个节点a，在此层被2个不同的节点b和c连接，此时需要把这2条路径需要标记回溯路径，之前这种可能性被自己忽略了，所以每当有多条的路径的时候，自己的代码只输出了一条，最后发现是遍历b和c的时候，b-a 使a 进入q_next, 并且visited[a] = True,标记b-a的回溯路径， 而当 c-a 需要标记回溯路径的时候，却由于visited[a]==True 被跳过了，所以才有那段不伦不类的if elif 的分支判断</p><pre class=" language-python"><code class="language-python">q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>endWord<span class="token punctuation">)</span>visited <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;endWord:True&amp;#125;</span>bp <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#res = defaultdict(list)</span><span class="token comment" spellcheck="true">#res[endWord] = [ [endWord] ]</span><span class="token keyword">while</span> len<span class="token punctuation">(</span>q<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">:</span>    q_next <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> e <span class="token keyword">in</span> q<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># self.constructidx(e, wordList_set, des2src)</span>        self<span class="token punctuation">.</span>constructidx_1<span class="token punctuation">(</span>e<span class="token punctuation">,</span> wordList_set<span class="token punctuation">,</span> des2src<span class="token punctuation">)</span>        <span class="token keyword">for</span> src <span class="token keyword">in</span> des2src<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> visited<span class="token punctuation">.</span>get<span class="token punctuation">(</span>src<span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span>  <span class="token punctuation">:</span>                visited<span class="token punctuation">[</span>src<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>                q_next<span class="token punctuation">.</span>append<span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#                r = [ [src] ]if len(res[e]) == 0 else [[src] + re for re in res[e]]</span><span class="token comment" spellcheck="true">#                res[src].extend(r)</span>                bp<span class="token punctuation">[</span>src<span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>e<span class="token punctuation">)</span>            <span class="token keyword">elif</span> src <span class="token keyword">in</span> q_next<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#                r = [ [src] ]if len(res[e]) == 0 else [[src] + re for re in res[e]]</span><span class="token comment" spellcheck="true">#                res[src].extend(r)</span>                bp<span class="token punctuation">[</span>src<span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>e<span class="token punctuation">)</span>    <span class="token keyword">if</span> beginWord <span class="token keyword">in</span> q_next<span class="token punctuation">:</span>        <span class="token keyword">break</span>    wordList_set <span class="token operator">=</span> wordList_set <span class="token operator">-</span> set<span class="token punctuation">(</span>bp<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    q <span class="token operator">=</span> q_next<span class="token comment" spellcheck="true"># return res[beginWord]</span>res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>self<span class="token punctuation">.</span>backPath<span class="token punctuation">(</span>beginWord<span class="token punctuation">,</span> endWord<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">,</span> bp<span class="token punctuation">)</span><span class="token keyword">return</span> res<span class="token comment" spellcheck="true"># 回溯还原最短路径</span><span class="token keyword">def</span> <span class="token function">backPath</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> start<span class="token punctuation">,</span>endWord<span class="token punctuation">,</span> r <span class="token punctuation">,</span>res<span class="token punctuation">,</span>bp<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> start <span class="token operator">==</span> endWord<span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>r<span class="token operator">+</span><span class="token punctuation">[</span>endWord<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token keyword">for</span> st <span class="token keyword">in</span> bp<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>backPath<span class="token punctuation">(</span>st<span class="token punctuation">,</span> endWord<span class="token punctuation">,</span> r<span class="token operator">+</span><span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">,</span> bp<span class="token punctuation">)</span>        <span class="token keyword">return</span></code></pre><p>上述注释的代码，是除了回溯之外，另一种BFS中，直接保存结果的方法，当初以为是TLE的主因，最后证明其实不是，所以也是一种输出结果的方法，原理是用字典res，保存所有以word开头的可能的路径列表。</p><h3 id="BFS优化"><a href="#BFS优化" class="headerlink" title="BFS优化"></a>BFS优化</h3><p>　　Discuss Python高赞解法大体BFS跟我的一致，但是我前面也分析过，我这个奇怪的if/elif分支其实还是有很大的优化空间，再则自己的状态划分不佳其实也是导致这么奇怪分支的一个原因，所以高赞的解法直接把这二者完美的统一了，窃以为也是一个简洁优雅的解法，值得学习。这里res 跟我上述的res相反，是保存以word结尾的路径列表的字典</p><pre class=" language-python"><code class="language-python">q <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>list<span class="token punctuation">)</span>q<span class="token punctuation">[</span>beginWord<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>beginWord<span class="token punctuation">]</span><span class="token punctuation">]</span>wordList_set <span class="token operator">=</span> set<span class="token punctuation">(</span>wordList<span class="token punctuation">)</span>res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">while</span> len<span class="token punctuation">(</span>q<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>  q_next <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>list<span class="token punctuation">)</span>  <span class="token keyword">for</span> word <span class="token keyword">in</span> q<span class="token punctuation">:</span>    <span class="token keyword">if</span> word <span class="token operator">==</span> endWord<span class="token punctuation">:</span>      res<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>k <span class="token keyword">for</span> k <span class="token keyword">in</span> q<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">for</span> char <span class="token keyword">in</span> string<span class="token punctuation">.</span>ascii_lowercase<span class="token punctuation">:</span>        tmp <span class="token operator">=</span> word<span class="token punctuation">[</span> <span class="token punctuation">:</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> char <span class="token operator">+</span> word<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 未访问状态的列表中搜索拼接的可能的值，逐渐减少搜索空间，</span>        <span class="token comment" spellcheck="true">#也是一种很好的优化方法，即逻辑上实现了 visited 状态验证，</span>        <span class="token comment" spellcheck="true">#同时一层一更新减少了搜索空间，用set实现极大的优化了搜索时间</span>        <span class="token keyword">if</span> tmp <span class="token keyword">in</span> wordList_set<span class="token punctuation">:</span>                    q_next<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token punctuation">[</span>tmp<span class="token punctuation">]</span> <span class="token keyword">for</span> r <span class="token keyword">in</span> q<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># wordList_set 实际上是保存了所有未访问状态的列表，</span>  <span class="token comment" spellcheck="true">#BFS的时候每一层更新一次，避免奇怪的if/elif 分支判断，</span>  <span class="token comment" spellcheck="true">#是更准确的状态划分方法</span>    wordList_set <span class="token operator">=</span> wordList_set <span class="token operator">-</span> set<span class="token punctuation">(</span>q_next<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  q <span class="token operator">=</span> q_next<span class="token keyword">return</span> res</code></pre><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>　　算法优化阶段的时间复杂度分析做的不是很到位，其实似乎还是懒居多，细想一下，M和N之间的对比，似乎也能找到一点蛛丝马迹；其次，BFS状态划分没有因地制宜，还是想以套路直接鲁莽上阵，其实在发现应该按照层次BFS的时候，此题应该已经解决了，解析之后的后续优化工作还是需要多积累一些套路经验，特别是Python本来就比较慢的基础上，时间复杂度分析的重要性可能会越来越大。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 115. Distinct Subsequences</title>
      <link href="algorithms/leetcode-115-distinct-subsequences/"/>
      <url>algorithms/leetcode-115-distinct-subsequences/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Given two strings <code>s</code> and <code>t</code>, return <em>the number of distinct subsequences of <code>s</code> which equals <code>t</code></em>.</p><p>A string’s <strong>subsequence</strong> is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).</p><p>It’s guaranteed the answer fits on a 32-bit signed integer.</p><p><strong>Example 1:</strong></p><pre><code>Input: s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;Output: 3Explanation:As shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.rabbbitrabbbitrabbbit</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: s = &quot;babgbag&quot;, t = &quot;bag&quot;Output: 5Explanation:As shown below, there are 5 ways you can generate &quot;bag&quot; from S.babgbagbabgbagbabgbagbabgbagbabgbag</code></pre><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= s.length, t.length &lt;= 1000</code></li><li><code>s</code> and <code>t</code> consist of English letters.</li></ul></blockquote><p>　　或许是由于之前做过这个题目的原因，所以面对这道Hard题目，心态比较冷静；再加上100题前后的几乎都是二叉树类别的题目，自己面对链表和树类别的题目基本没碰到困难，所以DFS用的手软，到这里有点停不下来的感觉。所以此时第一想法就想到用DFS，虽然预感对于字符串匹配类别的题目，DFS肯定会出现性能问题，但是作为验证算法思想的先导思路，还是打算先实现出来再看，毕竟用DFS写代码，代码真的很短，AC的时候更是有种 吊炸天的 爽快感；结果还是差一点AC；其次，可能是之前做过的原因，虽然第一时间没写出dp递推公式，但是写出了递推矩阵，演算了一番，没想到居然是对的，很容易的转换成了算法代码，结果干净利落的AC了，甚至比之前的AC的时候还要快一倍以上。虽然这不是自己第一次独立解决Hard题目，但是这题没有借鉴之前的代码，而且从构思算法道实践成功基本没遇到什么障碍，还是值得自己兴奋一阵子了。</p><h3 id="解法一：DFS"><a href="#解法一：DFS" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h3><p>　　此题如果要用递归的方法，那么就可以从最简单的字符串匹配入手，就是s和t都是单字符，直接就可以快速返回结果，这就可以精简成3种情况：</p><ol><li>s == ‘’ 即待匹配的模式t还没有消耗完，就直接没有s可供匹配了，返回0</li><li>t == ‘’ 即待匹配的模式t消耗完，返回1</li><li>s==t 直接返回1</li><li>递归处理</li></ol><p>　　接下来，就开始要做递推式的处理，t的首字符t[0]如果在s中，那么就可以进行递归处理，考虑到s中可能有多个t[0]相同的字符，就要对s和t做不同的切分处理来交给递归处理，最后把所有返回的结果sum一下，就可以了</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># DFS</span>    <span class="token keyword">def</span> <span class="token function">numDistinct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> s <span class="token operator">==</span> t<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        r <span class="token operator">=</span> <span class="token number">0</span>        t0 <span class="token operator">=</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        pos <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        news <span class="token operator">=</span> s<span class="token punctuation">[</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">]</span>        <span class="token keyword">while</span> t0 <span class="token keyword">in</span> news<span class="token punctuation">:</span>            pos <span class="token operator">=</span> news<span class="token punctuation">.</span>index<span class="token punctuation">(</span>t0<span class="token punctuation">)</span>            news <span class="token operator">=</span> news<span class="token punctuation">[</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">]</span>            r <span class="token operator">+=</span> self<span class="token punctuation">.</span>numDistinct<span class="token punctuation">(</span>news<span class="token punctuation">,</span> t<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> r</code></pre><p>测试用例通过率：106/116， 离AC只有一步之遥，目测发现是超长的字符串s导致递归性能急剧下降，那么可以确定的是算法思路是没有问题的。接着开始转入DP的算法构思。</p><h3 id="解法二：-动态规划-Dynamic-Programming-DP"><a href="#解法二：-动态规划-Dynamic-Programming-DP" class="headerlink" title="解法二： 动态规划 Dynamic Programming (DP)"></a>解法二： 动态规划 Dynamic Programming (DP)</h3><p>　　由于之前做过这个题，所以非常确定有一个DP算法存在，但是对于这个DP是怎么构建最优子结构的，完全想不起来了。所以，接下来就完全需要自己朝着DP思路构思DP矩阵了。</p><p>　　字符串匹配的DP算法有一个非常有名的最长公共子序列(LCS)问题，几乎所有讲解DP的教材都拿这个题目做过示例分析，当时自己对这个递推式还是很不理解，为什么$dp[i][j]$在$s[i]!=t[j]$的时候，可以由$dp[i-1][j]$和$dp[i][j-1]$构成？当初还是理解了好久，才想明白。或许是当初对这个分解的情况思索的很久的原因，所以但凡遇到DP算法的，都会潜意识的往LCS靠；而此题恰好也是字符串匹配的题目，思路方向似乎没什么太大问题。</p><table><thead><tr><th align="center"></th><th align="center">r</th><th align="center">a</th><th align="center">b</th><th align="center">b</th><th align="center">b</th><th align="center">i</th><th align="center">t</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">a</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">b</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">b</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">i</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">3</td><td align="center">0</td></tr><tr><td align="center">t</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">3</td></tr></tbody></table><p>对$dp[i][j]$的定义开始还是不太明确，最初以为是本层i和上层i-1的累加，最后发现不对，最后从意义上的分析，最终确定是来自上一层之前所有可能性的累加，因为$dp[i-1][ :j]$中累加表示上层匹配结束之后，所有可供下层提供入口的数量，而且这个入口只有在$s[i]==t[j]$的时候，才有效，否则直接置为0，最后的返回的结果应该是$sum(dp[-1])$。</p><p>最关键的步骤就是正确性验证，在提供的2个测试用例都无误之后，基本就可以开始步入写代码的过程了.</p><table><thead><tr><th align="center"></th><th align="center">b</th><th align="center">a</th><th align="center">b</th><th align="center">g</th><th align="center">b</th><th align="center">a</th><th align="center">g</th></tr></thead><tbody><tr><td align="center">b</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">a</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">3</td><td align="center">0</td></tr><tr><td align="center">g</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">4</td></tr></tbody></table><p>由于只需要上层的数据就可以计算本层， 但是并不是完全copy上层的数据，所以没办法用dp常用的边更新数据边覆盖的方式复用同一个List， 所以这里采用了2个List交替使用的方式来逐层更新</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># dp</span>    <span class="token keyword">def</span> <span class="token function">numDistinct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">:</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span>char <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> char <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> char <span class="token keyword">in</span> t<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">]</span><span class="token punctuation">:</span>            count <span class="token operator">=</span> <span class="token number">0</span>            dp_next <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> char<span class="token punctuation">:</span>                    dp_next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> count                count <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            dp <span class="token operator">=</span> dp_next        <span class="token keyword">return</span> sum<span class="token punctuation">(</span>dp<span class="token punctuation">)</span></code></pre><p>36ms AC， 比之前AC的DP还快上一倍，这是最初没想到的。</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>　　这次顺利AC的主要原因还是思路方向的偶然正确性，这跟学生时代做数学题似乎有着异曲同工的地方，就是尝试的手段恰好是对的。如果尝试的手段恰好不对呢？无论是实践还是算法，我领悟到的结论是，多思考问题和事物的本质，才是快速接近正确答案有效的方式。上面的过程也可以发现，在有了正确的递归矩阵的引导下，代码的实现其实很轻松；反倒是，没抓住问题本质的随意和胡乱的尝试，才是导致心态急躁的根源，因为这种胡乱的尝试，似乎给了一种正在接近解决问题的错觉，虽然积累一点关于问题的经验，但是很多时候似乎只是积累无意义的失败经验而已；在适当的失败经验的基础上，更多的思考原因，在发现问题和原因的基础上的尝试，才是有价值和意义的，也才是最有效率的方式。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1-100 刷题有感</title>
      <link href="sui-bi/leetcode-1-100-shua-ti-you-gan/"/>
      <url>sui-bi/leetcode-1-100-shua-ti-you-gan/</url>
      
        <content type="html"><![CDATA[<p>　　跌跌撞撞终于在前几天完成的LeetCode 100题，刷题过程印证了之前对自我的一个论断，起了个大早，干了个晚集。 早在2012年，自己就开始了解到LeetCode 刷完前100题的神迹，这时LeetCode应该还没创立多久吧！当时国内只有北大的POJ可用，那曲高和寡的界面和难度，着实有点劝退！自己的编程学习之路从来没有一个类似引路人之类的角色，全凭自学，再加上我三分钟热度的神奇特性，所以对ACM之类的算法竞赛全然不知也就毫无意外。彼时，复现数据结构的排序等级实践水平就足以让自己沾沾自喜半天了，毕竟身边有大把无法做到这一点的人，而且还是靠背代码的方式，二叉树倒是无论是理论学习阶段还是代码实现阶段都没有遇到过太大的挑战，图论则是看算法（第四版）就收获了巨大的理论学习上的满足感，听信了据说实践基本不会出现这种级别的题目的话，就止步于此，毕竟图的数据结构确实有点繁琐，代码复杂度也有点棘手，但是在已经完全理解算法理论的基础上，实现起来也至多花一点时间而已。再加上当时眼界受限，以为排序，搜索以及图论之类就已经是算法的全部了。现在的我才真正意识到，理解算法理论和实现算法代码，在学习上是截然不同的2种境界，所幸自己就算没有在电脑上实现代码，也还是保持了记笔记的好习惯，很多自己觉得精妙和优雅的算法，忍不住在笔记本下写下来了，也算是另一种维度的代码实践吧！</p><p>　　回到了LeetCode上来，2012年记得是硕士复试需要准备OJ，当时觉得还是颇为新奇，所以比较重视，刷了很多OJ题目，其中就有LeetCode，不过当时光理解题目意思都有点费劲，刷了不到10题的Easy难度的题目就劝退了；复试结束之后，习惯性的放弃了，直到看完算法（第四版），重新理解了Java之后，忍不住想要做点什么，就又开始重新开始刷LeetCode，用Java 勉强刷了几十道medium和easy的题目，虽然大部分都还是做不出来，不清楚常规解题套路，Hard题目一想就是一整天都没什么头绪，最后还是看Discuss才能找到一点感觉，甚至很多时候光理解代码就需要大半天时间。由于LeetCode OJ系统的易用性，免去了调试环境的很多烦恼，能专注于算法编码和Debug，其次社区讨论都非常活跃，遇到不会做的题目或者是思路受阻，基本都能在Discuss下面找到解答，当时虽然抱着模仿性质的想法，试图想要刷完LeetCode 100题，但是止步于好几个Hard题目，记得有一道计算城市天际线面积的题目，整整想了一周，总是感觉算法上，似乎已经找到解决算法，但是编码时候总是磕磕碰碰，自己的想法还没到验证的阶段，就被茫茫然的细节问题给淹没了。最后不得不求助社区，最后理解完正确的代码之后，就这么弃置不顾。完全放弃了在LeetCode中寻找乐趣的想法了。</p><p>　　以现在的角度回顾分析之前为什么放弃 LeetCode 刷题，或许会有不错的收获！首先，也是老生常谈的问题，就是自己三分钟热度的问题，也不过多展开了，直接给出结论就是，中立的来看，自己既然有这样不算好也不算坏的特质，别像以前那样，说到三分钟热度，大部分时候都是带着点贬义和自我批判意味。再说，三分钟热度起码给了自己一种不断变换角度来看周遭和自己的机会，抱有对世界最单纯的好奇心。缺点自然也很明显，也就是浅尝辄止。最后的一句话点醒了梦中人，<strong>有三分钟热度，就有三分钟收获</strong>。其次，就是自己刷题时候的无知者无畏的盲目自信，想要试图跳级做题，而不是惯常的循序渐进，徒增难度，却发现自己完全没有做好准备，浪费了很多时间，还严重打击了自信，于是便开始自暴自弃，顺带连之前积累的理论知识都被荒废了。这可能是学生思维的弊端，不够谦卑，更不够自信，这其中的度，没有拿捏得当。诚然，数据结构和算法的理论支撑下，很多算法题都会变的比较容易用常规的套路解答，特别是很多算法笔试和考试中，都已经把最难点给精确的给出来了，照本宣科就可以了。那么，这是否意味着解决了核心难点之后，其他方面是否不值一提呢？真实情况并不是这样的，很多时候并没有意识到这个难点为什么是难点，只是被动的接受知识而已，这理所当然的导致另一个重要的能力的缺失，学会如何灵活的运用这些算法理论，也就是融会贯通。只有当无论什么算法题目，都能很准确的分析出问题本质，根据分析结果找到相应的数据结构工具和手段解决问题，才能完成编码的核心，就是算法伪代码的初步构思；但是是否真的能在OJ中AC，只有代码才能验证。这跟数学证明题一样，在证明过程顺利铺开之前，一切构思都只是可能的解决方案而已，能不能达到预想的目的，还需要证明过程来验证，况且，这个构思可能会被证明过程自我否定掉。这些内容总结起来，其实就是<strong>执行力</strong>。回顾自己大部分的学生时代，遗憾的发现，自己执行力可能是属于非常拉胯的级别。也就勉强仗着的天赋好，和某些时候的灵光乍现以及为数不多的树立并确信要去达成的目标的时候，才能走到现在。近年来，终于能心平气和的分析自己的优缺点的时候，才意识到，循序渐进的构思-行动，小步快走的达成目标的重要性和难能可贵。这一点可能是当初年轻气盛的时候不具备的。再则，其实也是上一个原因派生出来的问题，就是Java本身的标准库和数据结构的不熟悉，谁能想到，自学了Java这么久，居然还是懒得看Java的标准文档，尽管算法（第四版）实现了简化版的，堆栈，队列，二叉树等数据结构，文件I/O也大幅简化，增强了易用性，也让自己缺乏去看繁杂的Java标准实现的动力，所以很多时候都是现学现用，这当然无可厚非，因为熟记这些库是没有必要的，只需要知道是堆栈等这些数据结构的接口就可以了，用的时候再去查就行了，无非就是低效一点，并不至于无法实现的地步，但是结果就是不用就不学，导致直到现在对Java的标准库还是一知半解，前段时间打包个Jar还老费劲了。这样做的当时可能觉得没啥，但是一旦实践起来，就很容易出现问题，在做LeetCode OJ的时候，就集中爆发出来了，就是自己是算法构思，迟迟没办法得到代码验证，常常会卡在Java的实现细节上，当时也没有对构思和实践分的这么开，觉得有个构思好像能解决问题，就硬着头强上，以至于最后败兴而归都没能整明白，究竟是算法构思的问题，还是代码实现的问题；以至于虽然刷了很久的题目，收获不大，反倒是积累了很多Java的问题没有解决。以上的一些做的不够好的地方，基本解释了当初为什么没能坚持刷LeetCode ？ </p><p>　　还有一个重要的需要解释的问题就是，为什么刷过的LeetCode 过段时间回头来看，仍然解不出来或者是一知半解？譬如说，现在回去做城市天际线的题目，自己似乎没有自信能100%解出来。主要原因应该是自己并没有规划性的做复习工作，很多算法题做完，并没有留下一个可供复习的笔记和资料为后续复习做准备，也就是在之前Blog做反思的过程中提到的，没有系统行的整理和复习自己的学习笔记和资料，导致每次复习的时候，都不得不重头开始做题，把之前踩过的坑又重新踩了一遍，这在几年后，也就是最近几年开始用Python重做这些题的时候都渐渐体现出来了，这其实完全没有必要，因为发生这样的事情主要原因仅仅只是遗忘了而已，思维过程其实还是在没有复习的情况仍然保有印象。所以，定期的记录刷题方法并整理和复习在这个阶段就变的很重要了，这也是自己强调过很多次的问题了，也是努力在改进，就不多细说了。</p><p>　　用Python重刷题的时候，就显得有效率了很多，一来很多题目都比较熟悉了，只需要用Python相对应的数据结构重新实现即可，这个过程其实也加深了很多经常用的数据结构的理解，不常用的类和编程模式也熟悉了不少，也算是一个不错的收获吧，毕竟曾经对实践编码的忽视缺失导致自己眼高手低，失去了很多提升编码能力的机会，编码之后，才真实的认识到编程原本就是一项工程实践，自己怎么会天真到仅仅满足于算法构思，而不是脚踏实地的实现出来；再则，其实也算是一种复习，对之前理解不深刻，一知半解的方法做一个完整的梳理。 这也解释为什么，上周某天下午半天不到的时间，就把最后20题，一次性全部刷完，高效的自己都觉得不可思议。其中甚至包含2道Hard，自己原以为需要借助一些提示才做的出来的题目，也比较顺利的完成了。 刷完100题的时候，感觉真的很兴奋，曾经以为很厉害，遥不可及的神迹，现在自己也站在这里达成了这个目标，虽然耗时比较久，过程断断续续，其实过程基本是大部分时间没怎么刷，突然心血来潮就刷很多题那样，也算是达成一个不大不小的成就吧！</p><p>　　接下来该怎么做呢？ 这也是最最重要和需要关注的问题，毕竟尽管自己可以一下午刷几十道题，停不下来，但是我还是会开个小差，摸鱼一整天，更是停不下来的那种。我已经渐渐摸索出应对这种情况的解决办法，就是合理的做规划，给出目标，不多不少，不偏不倚。因为从刷题过程来看，我还是非常享受刷题带来的乐趣的，特别是那些觉得有点困难的题目，AC的时候，可以开心好一阵子了，以至于都忘记要整理自己的代码和笔记了。设想中的刷完100题之后，应该是需要整理一下100题的笔记和要点，作为刷题总结的方式，一篇一篇的成为Blog的主要内容来源，现在看来，似乎这项工作并没有开展起来，因为很多注释都写在代码里面了，现在回过头来一个一个的去复习和整理，觉得有点没必要，似乎只需要关注最主要和核心的题目整理出笔记即可，更主要的原因可能是担心这项工作可能会延误自己刷100-200题的进度，毕竟比起回头复习旧题目，我似乎更喜欢做新题。现在回想一下，其实很多代码注释的内容，都足以作为Blog的文字内容存在了，只需要稍加排版即可成为一份笔记，所以对于刷题的笔记模版，应该无需过于担忧。更值得关注的应该是要求自己刷100之后的新题的时候，务必要求自己必须整理出一份代码说明出来，定期排版成Blog，将定期刷题变成一个习惯，这样就有精力去迎接下一个挑战了，毕竟对自己来说是一件很开心的事情。</p><p>　　LeetCode 刷完100题有感就这么多，接下来还是希望自己能贯彻自己的日常目标，现阶段坚持刷题和背单词，再坚持锻炼身体，不要避重就轻的断断续续的逃避，相信有了这几项准备和积累，面对以后的工作和生活的挑战，自己能应对的更加自如，处理的更加高效！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPU in Pytorch  并行和分布式实践</title>
      <link href="pytorch/gpu-in-pytorch-bing-xing-he-fen-bu-shi-shi-jian/"/>
      <url>pytorch/gpu-in-pytorch-bing-xing-he-fen-bu-shi-shi-jian/</url>
      
        <content type="html"><![CDATA[<p>　　虽然还没有机会用到CUDA集群，但是前段时间对协程和并行化的研究，让我忍不住想要探索一下如何在多个GPU下利用Pytorch加快训练的实践方法，算是为之后并行训练优化一个理论参考吧！</p><p>　　Pytorch 大体上有3种实现并行的接口（另外还有一种不利用接口的拼接模型的技巧，之后再单独讨论），分别是：torch.multiprocessing, nn.DataParallel, nn.parallel.DistributedDataParallel，如果是是GPU多卡运行，最佳实践是 nn.parallle.DistributedDataParallel,官方文档 <a href="https://pytorch.org/docs/stable/notes/cuda.html#cuda-nn-ddp-instead">CUDA SEMANTIC</a> 是这么描述的：</p><blockquote><p><strong>Use nn.parallel.DistributedDataParallel instead of multiprocessing or nn.DataParallel</strong></p><p>Most use cases involving batched inputs and multiple GPUs should default to using <a href="https://pytorch.org/docs/stable/generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel"><code>DistributedDataParallel</code></a> to utilize more than one GPU.</p><p>There are significant caveats to using CUDA models with <a href="https://pytorch.org/docs/stable/multiprocessing.html#module-torch.multiprocessing"><code>multiprocessing</code></a>; unless care is taken to meet the data handling requirements exactly, it is likely that your program will have incorrect or undefined behavior.</p><p>It is recommended to use <a href="https://pytorch.org/docs/stable/generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel"><code>DistributedDataParallel</code></a>, instead of <a href="https://pytorch.org/docs/stable/generated/torch.nn.DataParallel.html#torch.nn.DataParallel"><code>DataParallel</code></a> to do multi-GPU training, even if there is only a single node.</p><p>The difference between <a href="https://pytorch.org/docs/stable/generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel"><code>DistributedDataParallel</code></a> and <a href="https://pytorch.org/docs/stable/generated/torch.nn.DataParallel.html#torch.nn.DataParallel"><code>DataParallel</code></a> is: <a href="https://pytorch.org/docs/stable/generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel"><code>DistributedDataParallel</code></a> uses multiprocessing where a process is created for each GPU, while <a href="https://pytorch.org/docs/stable/generated/torch.nn.DataParallel.html#torch.nn.DataParallel"><code>DataParallel</code></a> uses multithreading. By using multiprocessing, each GPU has its dedicated process, this avoids the performance overhead caused by GIL of Python interpreter.</p><p>If you use <a href="https://pytorch.org/docs/stable/generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel"><code>DistributedDataParallel</code></a>, you could use torch.distributed.launch utility to launch your program, see <a href="https://pytorch.org/docs/stable/distributed.html#distributed-launch">Third-party backends</a>.</p></blockquote><h3 id="torch-multiprocessing"><a href="#torch-multiprocessing" class="headerlink" title="torch.multiprocessing"></a>torch.multiprocessing</h3><p>　　torch.multiprocessing 是 Python下 multiprocessing 的替代品，接口基本一致，并根据情况进行扩张，建议使用 python: multiprocessing.Queue 在进程中传递Pytorch对象。除此之外，还有很多坑，详见官方笔记 <a href="https://pytorch.org/docs/stable/notes/multiprocessing.html">MULTIPROCESSING BEST PRACTICES</a>, <a href="https://pytorch.apachecn.org/docs/1.4/64.html">并行处理最佳实践</a></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token punctuation">.</span>multiprocessing <span class="token keyword">as</span> mp<span class="token keyword">from</span> model <span class="token keyword">import</span> MyModel<span class="token keyword">def</span> <span class="token function">train</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># Construct data_loader, optimizer, etc.</span>    <span class="token keyword">for</span> data<span class="token punctuation">,</span> labels <span class="token keyword">in</span> data_loader<span class="token punctuation">:</span>        optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        loss_fn<span class="token punctuation">(</span>model<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># This will update the shared parameters</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    num_processes <span class="token operator">=</span> <span class="token number">4</span>    model <span class="token operator">=</span> MyModel<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># NOTE: this is required for the ``fork`` method to work</span>    model<span class="token punctuation">.</span>share_memory<span class="token punctuation">(</span><span class="token punctuation">)</span>    processes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> rank <span class="token keyword">in</span> range<span class="token punctuation">(</span>num_processes<span class="token punctuation">)</span><span class="token punctuation">:</span>        p <span class="token operator">=</span> mp<span class="token punctuation">.</span>Process<span class="token punctuation">(</span>target<span class="token operator">=</span>train<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>        processes<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">)</span>    <span class="token keyword">for</span> p <span class="token keyword">in</span> processes<span class="token punctuation">:</span>        p<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="DataParallel"><a href="#DataParallel" class="headerlink" title="DataParallel"></a>DataParallel</h3><p>　　DataParallel原理是，把model 副本copy到所有GPU上，其中每个GPU消耗数据的不同分区，相当于SIMD，把数据条目根据GPU数量重新分配</p><h4 id="单机DataParallel并行"><a href="#单机DataParallel并行" class="headerlink" title="单机DataParallel并行"></a>单机DataParallel并行</h4><pre class=" language-python"><code class="language-python">model <span class="token operator">=</span> nn<span class="token punctuation">.</span>DataParallel<span class="token punctuation">(</span>model<span class="token punctuation">)</span></code></pre><p>　　代码验证 outside model 数据维度  和 inside model 维度</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Model</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># Our model</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> input_size<span class="token punctuation">,</span> output_size<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>Model<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>input_size<span class="token punctuation">,</span> output_size<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> input<span class="token punctuation">)</span><span class="token punctuation">:</span>        output <span class="token operator">=</span> self<span class="token punctuation">.</span>fc<span class="token punctuation">(</span>input<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\tIn Model: input size"</span><span class="token punctuation">,</span> input<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>              <span class="token string">"output size"</span><span class="token punctuation">,</span> output<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> outputmodel <span class="token operator">=</span> Model<span class="token punctuation">(</span>input_size<span class="token punctuation">,</span> output_size<span class="token punctuation">)</span><span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>device_count<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Let's use"</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>device_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"GPUs!"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># dim = 0 [30, xxx] -> [10, ...], [10, ...], [10, ...] on 3 GPUs</span>  model <span class="token operator">=</span> nn<span class="token punctuation">.</span>DataParallel<span class="token punctuation">(</span>model<span class="token punctuation">)</span>model<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token keyword">for</span> data <span class="token keyword">in</span> rand_loader<span class="token punctuation">:</span>    input <span class="token operator">=</span> data<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>    output <span class="token operator">=</span> model<span class="token punctuation">(</span>input<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Outside: input size"</span><span class="token punctuation">,</span> input<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token string">"output_size"</span><span class="token punctuation">,</span> output<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 2 GPUs</span><span class="token comment" spellcheck="true"># on 2 GPUs</span>Let's use <span class="token number">2</span> GPUs!    In Model<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    In Model<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Outside<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output_size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    In Model<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    In Model<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Outside<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output_size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    In Model<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    In Model<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Outside<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output_size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    In Model<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    In Model<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Outside<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output_size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>优点是，通过消耗输入数据不同分区的方式加快训练过程，缺点是，如果单个模型太大，无法放入单个GPU，就无法运行，这时有个Trick可以把模型分段载入不同GPU，利用拼接的方式完成并行训练，该模型将单个模型拆分到不同的 GPU 上，而不是在每个 GPU 上复制整个模型(具体来说， 假设模型<code>m</code>包含 10 层：使用<code>DataParallel</code>时，每个 GPU 都具有这 10 层中每个层的副本，而当在两个 GPU 上并行使用模型时，每个 GPU 可以承载 5 层）</p><h4 id="单机模型拼接并行"><a href="#单机模型拼接并行" class="headerlink" title="单机模型拼接并行"></a>单机模型拼接并行</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">import</span> torch<span class="token punctuation">.</span>optim <span class="token keyword">as</span> optim<span class="token keyword">class</span> <span class="token class-name">ToyModel</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>ToyModel<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>net1 <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">'cuda:0'</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>relu <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>net2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">'cuda:1'</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>net1<span class="token punctuation">(</span>x<span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">'cuda:0'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>net2<span class="token punctuation">(</span>x<span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">'cuda:1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>对于模型太大而无法放入单个 GPU 的情况，上述实现解决了该问题。 但是，分析原理的时候可能已经注意到，如果模型单个GPU可以载入，它将比在单个 GPU 上运行它要慢。 这是因为在任何时间点，两个 GPU 中只有一个在工作，而另一个在那儿什么也没做。 由于中间输出需要在<code>layer2</code>和<code>layer3</code>之间从<code>cuda:0</code>复制到<code>cuda:1</code>，因此性能进一步恶化。</p><p>除此之外，还有通过异步方式构建流水线的手段加速，这个Trick比较精巧和优雅，思想可以学习一下</p><h4 id="单机Pipeline-并行"><a href="#单机Pipeline-并行" class="headerlink" title="单机Pipeline 并行"></a>单机Pipeline 并行</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">PipelineParallelResNet50</span><span class="token punctuation">(</span>ModelParallelResNet50<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> split_size<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>PipelineParallelResNet50<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>split_size <span class="token operator">=</span> split_size    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        splits <span class="token operator">=</span> iter<span class="token punctuation">(</span>x<span class="token punctuation">.</span>split<span class="token punctuation">(</span>self<span class="token punctuation">.</span>split_size<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        s_next <span class="token operator">=</span> next<span class="token punctuation">(</span>splits<span class="token punctuation">)</span>        s_prev <span class="token operator">=</span> self<span class="token punctuation">.</span>seq1<span class="token punctuation">(</span>s_next<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">'cuda:1'</span><span class="token punctuation">)</span>        ret <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> s_next <span class="token keyword">in</span> splits<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># A. s_prev runs on cuda:1</span>            s_prev <span class="token operator">=</span> self<span class="token punctuation">.</span>seq2<span class="token punctuation">(</span>s_prev<span class="token punctuation">)</span>            ret<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc<span class="token punctuation">(</span>s_prev<span class="token punctuation">.</span>view<span class="token punctuation">(</span>s_prev<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># B. s_next runs on cuda:0, which can run concurrently with A</span>            s_prev <span class="token operator">=</span> self<span class="token punctuation">.</span>seq1<span class="token punctuation">(</span>s_next<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">'cuda:1'</span><span class="token punctuation">)</span>        s_prev <span class="token operator">=</span> self<span class="token punctuation">.</span>seq2<span class="token punctuation">(</span>s_prev<span class="token punctuation">)</span>        ret<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc<span class="token punctuation">(</span>s_prev<span class="token punctuation">.</span>view<span class="token punctuation">(</span>s_prev<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span>ret<span class="token punctuation">)</span>setup <span class="token operator">=</span> <span class="token string">"model = PipelineParallelResNet50()"</span>pp_run_times <span class="token operator">=</span> timeit<span class="token punctuation">.</span>repeat<span class="token punctuation">(</span>    stmt<span class="token punctuation">,</span> setup<span class="token punctuation">,</span> number<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> repeat<span class="token operator">=</span>num_repeat<span class="token punctuation">,</span> globals<span class="token operator">=</span>globals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>pp_mean<span class="token punctuation">,</span> pp_std <span class="token operator">=</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>pp_run_times<span class="token punctuation">)</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>std<span class="token punctuation">(</span>pp_run_times<span class="token punctuation">)</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span>mp_mean<span class="token punctuation">,</span> rn_mean<span class="token punctuation">,</span> pp_mean<span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token punctuation">[</span>mp_std<span class="token punctuation">,</span> rn_std<span class="token punctuation">,</span> pp_std<span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token punctuation">[</span><span class="token string">'Model Parallel'</span><span class="token punctuation">,</span> <span class="token string">'Single GPU'</span><span class="token punctuation">,</span> <span class="token string">'Pipelining Model Parallel'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token string">'mp_vs_rn_vs_pp.png'</span><span class="token punctuation">)</span></code></pre><p>在2 GPUs上能有50%的提速，离100%还是有点差距，加速对比如下</p><p>###<img src="1.png" alt="1"> </p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>依次是 2-GPU并行， 1-GPU运行， 2-GPU Pipelining 并行 的运行时间对比</p><h3 id="nn-parallel-DistributedDataParallel"><a href="#nn-parallel-DistributedDataParallel" class="headerlink" title="nn.parallel.DistributedDataParallel"></a>nn.parallel.DistributedDataParallel</h3><p>　　基于torch.distributed 的分布式数据并行，原理和DataParallel类似，但是是跨机器和跨设备级别的数据并行，在每台机器和每台设备上复制，并且每个这样的副本处理一部分输入， 在向后传递过程中，将平均每个节点的梯度，总之，是按批处理维度分块指定设备之间的输入来并行化给定模块的应用程序。</p><p><code>DistributedDataParallel</code>可以通过以下两种方式使用：</p><h4 id="单进程多GPU"><a href="#单进程多GPU" class="headerlink" title="单进程多GPU"></a>单进程多GPU</h4><pre class=" language-python"><code class="language-python">torch<span class="token punctuation">.</span>distributed<span class="token punctuation">.</span>init_process_group<span class="token punctuation">(</span>backend<span class="token operator">=</span><span class="token string">"nccl"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># device_ids will include all GPU devices by default</span>model <span class="token operator">=</span> DistributedDataParallel<span class="token punctuation">(</span>model<span class="token punctuation">)</span> </code></pre><h4 id="多进程多GPU"><a href="#多进程多GPU" class="headerlink" title="多进程多GPU"></a>多进程多GPU</h4><p>　　强烈推荐的使用方式，在单机多GPU的情况下，单进程很容易由于GIL出现利用率不足的问题，这时候多进程就是唯一解决办法。最佳实践是，将DDP(DistributedDataParallel)配合多进程一起使用，每个GPU分配一个进程，会比torch.nn.DataParallel快得多，也是目前Pytorch最快的训练方法。</p><p>使用步骤：</p><ol><li>在N个GPU的单机上生成N个进程，这个过程可以交给torch.distributed.launch完成</li></ol><pre class=" language-bash"><code class="language-bash">python -m torch.distributed.launch --nproc_per_node<span class="token operator">=</span>n distributed_data_parallel.py</code></pre><ol start="2"><li>在代码中绑定GPU 编号，同时并行化model</li></ol><pre class=" language-python"><code class="language-python">parser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># FOR DISTRIBUTED:  Parse for the local_rank argument, which will be supplied</span><span class="token comment" spellcheck="true"># automatically by torch.distributed.launch.</span>parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">"--local_rank"</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> type<span class="token operator">=</span>int<span class="token punctuation">)</span>args <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 进程内绑定 GPU rank id</span>torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>set_device<span class="token punctuation">(</span>args<span class="token punctuation">.</span>local_rank<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 构造model</span>torch<span class="token punctuation">.</span>distributed<span class="token punctuation">.</span>init_process_group<span class="token punctuation">(</span>backend<span class="token operator">=</span><span class="token string">'nccl'</span><span class="token punctuation">,</span> world_size<span class="token operator">=</span>n<span class="token punctuation">,</span> init_method<span class="token operator">=</span><span class="token string">'env://'</span><span class="token punctuation">)</span>model <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>parallel<span class="token punctuation">.</span>DistributedDataParallel<span class="token punctuation">(</span>                                      model<span class="token punctuation">,</span>                                        device_ids<span class="token operator">=</span><span class="token punctuation">[</span>args<span class="token punctuation">.</span>local_rank<span class="token punctuation">]</span><span class="token punctuation">,</span>                                        output_device<span class="token operator">=</span>args<span class="token punctuation">.</span>local_rank<span class="token punctuation">)</span></code></pre><p>Note:</p><ol><li>nccl 后端是分布式训练使用的推荐的最快后端，适用于单节点和多节点分布式训练</li><li>nccl同时支持混合精度分布式训练</li><li>no_sync 用于禁用DDP进程之间的梯度同步，直到退出此上下文区域的第一个梯度Forward-Backward中进行梯度同步</li></ol><pre class=" language-python"><code class="language-python">ddp <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>DistributedDataParallel<span class="token punctuation">(</span>model<span class="token punctuation">,</span> pg<span class="token punctuation">)</span><span class="token keyword">with</span> ddp<span class="token punctuation">.</span>no_sync<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">for</span> input <span class="token keyword">in</span> inputs<span class="token punctuation">:</span>    ddp<span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># no synchronization, accumulate grads</span>ddp<span class="token punctuation">(</span>another_input<span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># synchronize grads</span></code></pre><h3 id="apex-parallel-DistributedDataParallel"><a href="#apex-parallel-DistributedDataParallel" class="headerlink" title="apex.parallel.DistributedDataParallel"></a>apex.parallel.DistributedDataParallel</h3><p>　　基本上是torch.nn.parallel.DistributedDataParallel的wrapper，同时调用的时候优化了NCCL的使用和简化了参数</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 调用的时候，注意 n &lt;= 每个节点的GPU数量 同时默认 1个GPU对应1进程</span>torch.distributed.launch --nproc_per_node<span class="token operator">=</span>n distributed_data_parallel.py<span class="token comment" spellcheck="true"># 会自动提供的参数目前已知的是:</span><span class="token comment" spellcheck="true"># args.local_rank</span><span class="token comment" spellcheck="true"># os.environ['WORLD_SIZE']</span></code></pre><p>简化的要点：</p><ol><li><p>model = DDP(model) 即可，无需再传递 devices_ids output_device</p></li><li><p>init_process_group 中的 init_method=’env://‘</p><pre class=" language-python"><code class="language-python">torch<span class="token punctuation">.</span>distributed<span class="token punctuation">.</span>init_process_group<span class="token punctuation">(</span>backend<span class="token operator">=</span><span class="token string">'nccl'</span><span class="token punctuation">,</span>init_method<span class="token operator">=</span><span class="token string">'env://'</span><span class="token punctuation">)</span></code></pre></li></ol><p>直接给出示例代码</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># distributed_data_parallel.py</span><span class="token keyword">import</span> torch<span class="token keyword">import</span> argparse<span class="token keyword">import</span> os<span class="token keyword">from</span> apex <span class="token keyword">import</span> amp<span class="token comment" spellcheck="true"># FOR DISTRIBUTED: (can also use torch.nn.parallel.DistributedDataParallel instead)</span><span class="token keyword">from</span> apex<span class="token punctuation">.</span>parallel <span class="token keyword">import</span> DistributedDataParallelparser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># FOR DISTRIBUTED:  Parse for the local_rank argument, which will be supplied</span><span class="token comment" spellcheck="true"># automatically by torch.distributed.launch.</span>parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">"--local_rank"</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> type<span class="token operator">=</span>int<span class="token punctuation">)</span>args <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># FOR DISTRIBUTED:  If we are running under torch.distributed.launch,</span><span class="token comment" spellcheck="true"># the 'WORLD_SIZE' environment variable will also be set automatically.</span>args<span class="token punctuation">.</span>distributed <span class="token operator">=</span> <span class="token boolean">False</span><span class="token keyword">if</span> <span class="token string">'WORLD_SIZE'</span> <span class="token keyword">in</span> os<span class="token punctuation">.</span>environ<span class="token punctuation">:</span>    args<span class="token punctuation">.</span>distributed <span class="token operator">=</span> int<span class="token punctuation">(</span>os<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">'WORLD_SIZE'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token keyword">if</span> args<span class="token punctuation">.</span>distributed<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># FOR DISTRIBUTED:  Set the device according to local_rank.</span>    torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>set_device<span class="token punctuation">(</span>args<span class="token punctuation">.</span>local_rank<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># FOR DISTRIBUTED:  Initialize the backend.  torch.distributed.launch will provide</span>    <span class="token comment" spellcheck="true"># environment variables, and requires that you use init_method=`env://`.</span>    torch<span class="token punctuation">.</span>distributed<span class="token punctuation">.</span>init_process_group<span class="token punctuation">(</span>backend<span class="token operator">=</span><span class="token string">'nccl'</span><span class="token punctuation">,</span>                                         init_method<span class="token operator">=</span><span class="token string">'env://'</span><span class="token punctuation">)</span>torch<span class="token punctuation">.</span>backends<span class="token punctuation">.</span>cudnn<span class="token punctuation">.</span>benchmark <span class="token operator">=</span> <span class="token boolean">True</span>N<span class="token punctuation">,</span> D_in<span class="token punctuation">,</span> D_out <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token comment" spellcheck="true"># Each process receives its own batch of "fake input data" and "fake target data."</span><span class="token comment" spellcheck="true"># The "training loop" in each process just uses this fake batch over and over.</span><span class="token comment" spellcheck="true"># https://github.com/NVIDIA/apex/tree/master/examples/imagenet provides a more realistic</span><span class="token comment" spellcheck="true"># example of distributed data sampling for both training and validation.</span>x <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>N<span class="token punctuation">,</span> D_in<span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token string">'cuda'</span><span class="token punctuation">)</span>y <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>N<span class="token punctuation">,</span> D_out<span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token string">'cuda'</span><span class="token punctuation">)</span>model <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>D_in<span class="token punctuation">,</span> D_out<span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span>model<span class="token punctuation">,</span> optimizer <span class="token operator">=</span> amp<span class="token punctuation">.</span>initialize<span class="token punctuation">(</span>model<span class="token punctuation">,</span> optimizer<span class="token punctuation">,</span> opt_level<span class="token operator">=</span><span class="token string">"O1"</span><span class="token punctuation">)</span><span class="token keyword">if</span> args<span class="token punctuation">.</span>distributed<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># FOR DISTRIBUTED:  After amp.initialize, wrap the model with</span>    <span class="token comment" spellcheck="true"># apex.parallel.DistributedDataParallel.</span>    model <span class="token operator">=</span> DistributedDataParallel<span class="token punctuation">(</span>model<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># torch.nn.parallel.DistributedDataParallel is also fine, with some added args:</span>    <span class="token comment" spellcheck="true"># model = torch.nn.parallel.DistributedDataParallel(model,</span>    <span class="token comment" spellcheck="true">#                                                   device_ids=[args.local_rank],</span>    <span class="token comment" spellcheck="true">#                                                   output_device=args.local_rank)</span>loss_fn <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>MSELoss<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> t <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>    y_pred <span class="token operator">=</span> model<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    loss <span class="token operator">=</span> loss_fn<span class="token punctuation">(</span>y_pred<span class="token punctuation">,</span> y<span class="token punctuation">)</span>    <span class="token keyword">with</span> amp<span class="token punctuation">.</span>scale_loss<span class="token punctuation">(</span>loss<span class="token punctuation">,</span> optimizer<span class="token punctuation">)</span> <span class="token keyword">as</span> scaled_loss<span class="token punctuation">:</span>        scaled_loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>    optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> args<span class="token punctuation">.</span>local_rank <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"final loss = "</span><span class="token punctuation">,</span> loss<span class="token punctuation">)</span></code></pre><p>更复杂的多精度调用见 <a href="https://github.com/NVIDIA/apex/tree/master/examples/imagenet">mixed precision training with DDP</a></p><h3 id="DDP-保存和加载检查点"><a href="#DDP-保存和加载检查点" class="headerlink" title="DDP 保存和加载检查点"></a>DDP 保存和加载检查点</h3><p>　　一般是使用torch.save 和 torch.load 来完成，但是在多进程下，优化方法是，仅在一个进程中保存，然后在其他所有进程中加载。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> tempfile<span class="token keyword">import</span> torch<span class="token keyword">import</span> torch<span class="token punctuation">.</span>distributed <span class="token keyword">as</span> dist<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">import</span> torch<span class="token punctuation">.</span>optim <span class="token keyword">as</span> optim<span class="token keyword">import</span> torch<span class="token punctuation">.</span>multiprocessing <span class="token keyword">as</span> mp<span class="token keyword">from</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>parallel <span class="token keyword">import</span> DistributedDataParallel <span class="token keyword">as</span> DDP<span class="token keyword">def</span> <span class="token function">demo_checkpoint</span><span class="token punctuation">(</span>rank<span class="token punctuation">,</span> world_size<span class="token punctuation">)</span><span class="token punctuation">:</span>    setup<span class="token punctuation">(</span>rank<span class="token punctuation">,</span> world_size<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># setup devices for this process, rank 1 uses GPUs [0, 1, 2, 3] and</span>    <span class="token comment" spellcheck="true"># rank 2 uses GPUs [4, 5, 6, 7].</span>    n <span class="token operator">=</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>device_count<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">//</span> world_size    device_ids <span class="token operator">=</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span>rank <span class="token operator">*</span> n<span class="token punctuation">,</span> <span class="token punctuation">(</span>rank <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>    model <span class="token operator">=</span> ToyModel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device_ids<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># output_device defaults to device_ids[0]</span>    ddp_model <span class="token operator">=</span> DDP<span class="token punctuation">(</span>model<span class="token punctuation">,</span> device_ids<span class="token operator">=</span>device_ids<span class="token punctuation">)</span>    loss_fn <span class="token operator">=</span> nn<span class="token punctuation">.</span>MSELoss<span class="token punctuation">(</span><span class="token punctuation">)</span>    optimizer <span class="token operator">=</span> optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>ddp_model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">)</span>    CHECKPOINT_PATH <span class="token operator">=</span> tempfile<span class="token punctuation">.</span>gettempdir<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"/model.checkpoint"</span>    <span class="token keyword">if</span> rank <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># All processes should see same parameters as they all start from same</span>        <span class="token comment" spellcheck="true"># random parameters and gradients are synchronized in backward passes.</span>        <span class="token comment" spellcheck="true"># Therefore, saving it in one process is sufficient.</span>        torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>ddp_model<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> CHECKPOINT_PATH<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Use a barrier() to make sure that process 1 loads the model after process</span>    <span class="token comment" spellcheck="true"># 0 saves it.</span>    dist<span class="token punctuation">.</span>barrier<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># configure map_location properly</span>    rank0_devices <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token operator">-</span> rank <span class="token operator">*</span> len<span class="token punctuation">(</span>device_ids<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> device_ids<span class="token punctuation">]</span>    device_pairs <span class="token operator">=</span> zip<span class="token punctuation">(</span>rank0_devices<span class="token punctuation">,</span> device_ids<span class="token punctuation">)</span>    map_location <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;'cuda:%d' % x: 'cuda:%d' % y for x, y in device_pairs&amp;#125;</span>    ddp_model<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>        torch<span class="token punctuation">.</span>load<span class="token punctuation">(</span>CHECKPOINT_PATH<span class="token punctuation">,</span> map_location<span class="token operator">=</span>map_location<span class="token punctuation">)</span><span class="token punctuation">)</span>    optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>    outputs <span class="token operator">=</span> ddp_model<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    labels <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device_ids<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    loss_fn <span class="token operator">=</span> nn<span class="token punctuation">.</span>MSELoss<span class="token punctuation">(</span><span class="token punctuation">)</span>    loss_fn<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>    optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Use a barrier() to make sure that all processes have finished reading the</span>    <span class="token comment" spellcheck="true"># checkpoint</span>    dist<span class="token punctuation">.</span>barrier<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> rank <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        os<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>CHECKPOINT_PATH<span class="token punctuation">)</span>    cleanup<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="DDP-与模型拼接并行"><a href="#DDP-与模型拼接并行" class="headerlink" title="DDP 与模型拼接并行"></a>DDP 与模型拼接并行</h3><p>　　DDP 还可以与多 GPU 模型一起使用，但是不支持进程内的复制。 您需要为每个模块副本创建一个进程，与每个进程的多个副本相比，通常可以提高性能。 当训练具有大量数据的大型模型时，DDP 包装多 GPU 模型特别有用。 使用此功能时，需要小心地实现多 GPU 模型，以避免使用硬编码的设备，因为会将不同的模型副本放置到不同的设备上。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ToyMpModel</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dev0<span class="token punctuation">,</span> dev1<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>ToyMpModel<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dev0 <span class="token operator">=</span> dev0        self<span class="token punctuation">.</span>dev1 <span class="token operator">=</span> dev1        self<span class="token punctuation">.</span>net1 <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>dev0<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>relu <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>net2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>dev1<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> x<span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>dev0<span class="token punctuation">)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>net1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>        x <span class="token operator">=</span> x<span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>dev1<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>net2<span class="token punctuation">(</span>x<span class="token punctuation">)</span></code></pre><p>将多 GPU 模型传递给 DDP 时，不得设置<code>device_ids</code>和<code>output_device</code>。 输入和输出数据将通过应用程序或模型<code>forward()</code>方法放置在适当的设备中。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">demo_model_parallel</span><span class="token punctuation">(</span>rank<span class="token punctuation">,</span> world_size<span class="token punctuation">)</span><span class="token punctuation">:</span>    setup<span class="token punctuation">(</span>rank<span class="token punctuation">,</span> world_size<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># setup mp_model and devices for this process</span>    dev0 <span class="token operator">=</span> rank <span class="token operator">*</span> <span class="token number">2</span>    dev1 <span class="token operator">=</span> rank <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span>    mp_model <span class="token operator">=</span> ToyMpModel<span class="token punctuation">(</span>dev0<span class="token punctuation">,</span> dev1<span class="token punctuation">)</span>    ddp_mp_model <span class="token operator">=</span> DDP<span class="token punctuation">(</span>mp_model<span class="token punctuation">)</span>    loss_fn <span class="token operator">=</span> nn<span class="token punctuation">.</span>MSELoss<span class="token punctuation">(</span><span class="token punctuation">)</span>    optimizer <span class="token operator">=</span> optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>ddp_mp_model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">)</span>    optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># outputs will be on dev1</span>    outputs <span class="token operator">=</span> ddp_mp_model<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    labels <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>dev1<span class="token punctuation">)</span>    loss_fn<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>    optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>    cleanup<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    run_demo<span class="token punctuation">(</span>demo_basic<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    run_demo<span class="token punctuation">(</span>demo_checkpoint<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>device_count<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">8</span><span class="token punctuation">:</span>        run_demo<span class="token punctuation">(</span>demo_model_parallel<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span></code></pre><p>注意上述setup 是通过 torch.multiprocessing.spawn 来完成多线程启动的，所以初始化方法也需要通过setup单独来指定</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> tempfile<span class="token keyword">import</span> torch<span class="token keyword">import</span> torch<span class="token punctuation">.</span>distributed <span class="token keyword">as</span> dist<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">import</span> torch<span class="token punctuation">.</span>optim <span class="token keyword">as</span> optim<span class="token keyword">import</span> torch<span class="token punctuation">.</span>multiprocessing <span class="token keyword">as</span> mp<span class="token keyword">from</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>parallel <span class="token keyword">import</span> DistributedDataParallel <span class="token keyword">as</span> DDP<span class="token keyword">def</span> <span class="token function">setup</span><span class="token punctuation">(</span>rank<span class="token punctuation">,</span> world_size<span class="token punctuation">)</span><span class="token punctuation">:</span>    os<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">'MASTER_ADDR'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'localhost'</span>    os<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">'MASTER_PORT'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'12355'</span>    <span class="token comment" spellcheck="true"># initialize the process group</span>    dist<span class="token punctuation">.</span>init_process_group<span class="token punctuation">(</span><span class="token string">"gloo"</span><span class="token punctuation">,</span> rank<span class="token operator">=</span>rank<span class="token punctuation">,</span> world_size<span class="token operator">=</span>world_size<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Explicitly setting seed to make sure that models created in two processes</span>    <span class="token comment" spellcheck="true"># start from same random weights and biases.</span>    torch<span class="token punctuation">.</span>manual_seed<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    dist<span class="token punctuation">.</span>destroy_process_group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">ToyModel</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>ToyModel<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>net1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>relu <span class="token operator">=</span> nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>net2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>net2<span class="token punctuation">(</span>self<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>net1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">demo_basic</span><span class="token punctuation">(</span>rank<span class="token punctuation">,</span> world_size<span class="token punctuation">)</span><span class="token punctuation">:</span>    setup<span class="token punctuation">(</span>rank<span class="token punctuation">,</span> world_size<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># setup devices for this process, rank 1 uses GPUs [0, 1, 2, 3] and</span>    <span class="token comment" spellcheck="true"># rank 2 uses GPUs [4, 5, 6, 7].</span>    n <span class="token operator">=</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>device_count<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">//</span> world_size    device_ids <span class="token operator">=</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span>rank <span class="token operator">*</span> n<span class="token punctuation">,</span> <span class="token punctuation">(</span>rank <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># create model and move it to device_ids[0]</span>    model <span class="token operator">=</span> ToyModel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device_ids<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># output_device defaults to device_ids[0]</span>    ddp_model <span class="token operator">=</span> DDP<span class="token punctuation">(</span>model<span class="token punctuation">,</span> device_ids<span class="token operator">=</span>device_ids<span class="token punctuation">)</span>    loss_fn <span class="token operator">=</span> nn<span class="token punctuation">.</span>MSELoss<span class="token punctuation">(</span><span class="token punctuation">)</span>    optimizer <span class="token operator">=</span> optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>ddp_model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">)</span>    optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>    outputs <span class="token operator">=</span> ddp_model<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    labels <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device_ids<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    loss_fn<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>    optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>    cleanup<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">run_demo</span><span class="token punctuation">(</span>demo_fn<span class="token punctuation">,</span> world_size<span class="token punctuation">)</span><span class="token punctuation">:</span>    mp<span class="token punctuation">.</span>spawn<span class="token punctuation">(</span>demo_fn<span class="token punctuation">,</span>             args<span class="token operator">=</span><span class="token punctuation">(</span>world_size<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>             nprocs<span class="token operator">=</span>world_size<span class="token punctuation">,</span>             join<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span></code></pre><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>　　至此基本分析完所有Pytorch下的多GPU使用技巧，大体方案还是利用多进程的方式来规避GIL来提升性能，只需要用DDP 来包装model ，同时进行分布式对应的初始化，然后多进程启动即可加速训练，基本没有大的变动。</p><p>References:</p><p><a href="https://pytorch.apachecn.org/docs/1.4/75.html">torch.nn</a></p><p><a href="https://pytorch.org/docs/stable/generated/torch.nn.parallel.DistributedDataParallel.html?highlight=distributeddataparallel#torch.nn.parallel.DistributedDataParallel">DistributedDataParallel API</a></p><p><a href="https://pytorch.org/docs/stable/notes/cuda.html#cuda-nn-ddp-instead">CUDA Semantics</a></p><p><a href="https://pytorch.apachecn.org/docs/1.4/34.html">分布式数据并行入门</a></p><p><a href="https://pytorch.apachecn.org/docs/1.4/35.html">用Pytorch编写分布式应用程序</a></p><p><a href="https://nvidia.github.io/apex/parallel.html">apex.parallel</a></p>]]></content>
      
      
      <categories>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
            <tag> CUDA </tag>
            
            <tag> GPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步和异步编程(如何并行写同一个日志文件实践)</title>
      <link href="algorithms/tong-bu-he-yi-bu-bian-cheng-ru-he-bing-xing-xie-tong-yi-ge-ri-zhi-wen-jian-shi-jian/"/>
      <url>algorithms/tong-bu-he-yi-bu-bian-cheng-ru-he-bing-xing-xie-tong-yi-ge-ri-zhi-wen-jian-shi-jian/</url>
      
        <content type="html"><![CDATA[<p>　　最近遇到如何并行写日志文件的问题，查看之前的代码，发现是利用RabbitMQ 作为消息中转，把并行的日志流通过HTTP 请求整合成串行的方式，然后通过一个单独的 Rabbit-Consumer 来写入文件，这样就成功避免了多个进程同时写一个文件造成的加锁问题，但是我觉得日志这种I/O为主的任务，动用RabbitMQ 有点大材小用的感觉，Producer-Consumer的总体思想可以不变，但是可以用其他更加轻量级的编程模型来实现，也借此重新优化一下日志输出的，毕竟之前的日志输出感觉一片混乱，在自己熟悉代码的情况下，仍然会有些理解困难，这跟当初自己写代码的时候不重视日志输出这一块有关，甚至很多情急之下写下的print打印信息都最后都没有处理。</p><p>　　在开始之前，必须要回忆一些似曾相识，却又容易混淆的基本概念，因为在不区分这些基本OS名词之前，根本就完全无法下手，不知道应该如何正确的实践，具体到每个代码跟这些概念是如何结合在一起的，基本上完全不知道，学生时代留下的坏习惯作怪，理论脱离实际，这时候也才意识到书到用时方恨少。</p><h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><p>　　这个概念有点复杂，来自OS中线程/进程的生命周期，诸如，就绪，运行，阻塞 ，但是如果仅仅按照这个方向理解，那就比较简单，仅仅就是线程/进程调度程序根据一定的策略，把线程/进程制定相应的状态，来安排和调度CPU资源；然而在OS之中，阻塞的原因很多，并非只是单纯的IO，严格上来讲应该是跟IO类似的原因被阻塞，即请求的资源无法得到，所以这里的阻塞调用，则是更加强调的是，单线程/进程在运行时，那些一定会被阻塞的编程模式，最重要的一个就是同步的编程模式，一旦请求的资源不具备，程序立刻陷入等待，这样就会特别容易被OS识别为闲置的线程/进程，并很快被阻塞。相反，异步则是一种将等待的资源交给外部程序和硬件，要么是子线程/进程，要么就是外部设备，总之试图通过改变通信模式的方式，使主程序始终维持运行态，这样就达到不被阻塞的目的。这就对编程模式有比较大的变动，因为主程序需要应对请求资源返回的各种情况需要预先有响应的程序段来处理，也就是常见的编程过程中回调函数的编写。</p><blockquote><p>阻塞调用是指调用结果返回之前，调用者会进入阻塞状态等待。只有在得到结果之后才会返回。</p><p>非阻塞调用是指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p></blockquote><p>阻塞调用：比如 socket 的 recv()，调用这个函数的线程如果没有数据返回，它会一直阻塞着，也就是 recv() 后面的代码都不会执行了，程序就停在 recv() 这里等待，所以一般把 recv() 放在单独的线程里调用。</p><p>非阻塞调用：比如非阻塞socket 的 send()，调用这个函数，它只是把待发送的数据复制到TCP输出缓冲区中，就立刻返回了，线程并不会阻塞，数据有没有发出去 send() 是不知道的，不会等待它发出去才返回的。</p><h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h4><p>基本还记得最显著的区别</p><blockquote><p>并发是指一个时间段内，有几个程序都在同一个CPU上运行，但任意一个时刻点上只有一个程序在处理机上运行。</p><p>并行是指一个时间段内，有几个程序都在几个CPU上运行，任意一个时刻点上，有多个程序在同时运行，并且多道程序之间互不干扰。 两者区别如下图</p></blockquote><p><img src="1.jpeg"></p><p><img src="2.jpeg"></p><h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><p>这个有点基本印象，经过很多次反复理解，依然还是没有很清晰掌握</p><blockquote><p>同步：在发出一个同步调用时，在没有得到结果之前，该调用就不返回</p><p>异步：在发出一个异步调用后，调用者不会立刻得到结果，该调用就返回了</p></blockquote><p>　　同步和阻塞， 异步和非阻塞概念非常类似，但是所涉及的范围还是有所不同，总的来讲应该是2个独立的概念体系。</p><p>　　同步和异步，应该是编程模型中，约定好的一种线程/进程间互相通信的方式，同步则是比较自然的一种程序运作方式，就是自顶向下，资源缺失，主程序等待资源准备，资源就绪继续运行；然而在OS系统调度的指挥下，同步很明显的缺点就是主程序无差别的等待所有资源，很容易程序会因为一些无关紧要的情况而一直处于等待，这其中就有比较大的优化空间；所以根据这种情况一种自然的解决办法是，让程序对各种资源缺失的情况能有对应的方案，最终形成了异步的通信策略，相比于定义上的，调用之后立刻返回这样不知所云的解释，我的理解是，程序是制定了一系列某些资源缺失或者不可用时，程序应该如何运作的逻辑，并且为了保持主程序运行，把程序调用之后的所有职责都交给了子程序，即子程序调用之后，应该由子程序来负责通知主程序，而不是跟同步那样，主程序持续等待子程序准备就绪，而原地踏步；这里的主要区别就是异步时候，主程序调用之后立刻转入下一步不需要这个资源的逻辑，有点类似于，乐观锁和悲观锁的性质，不加判断的断定后续逻辑分支，直接运行。缺点是，感觉异步编程为了解决临界区问题和通信问题，有很多复杂的管控逻辑需要解决，简单来说就是很多坑。好处是，如果这些坑都能解决，程序运行效率会有比较大的提升。</p><p>　　如果同步异步是编程模式的话，那么阻塞和非阻塞相对来说我认为是一个并非严格的概念，如果调用必定会导致主程序闲置，进而被置入阻塞状态，那么就是阻塞，如果调用不会导致主程序闲置，那么就是非阻塞。这其中的关键点就是OS的进程/线程调度，而不是调用的问题，然而阻塞的定义中常常会加入调用是否立刻返回的解释，常常让我跟同步异步的概念分不清楚，诚然调用不返回在当今的OS下一定会引起主程序闲置并阻塞，但是主因必然是主程序闲置等待，如果异步通信，但是仍然没有后续程序逻辑，显然异步程序也会有阻塞的风险。所以，我觉得阻塞这个更应该是一个OS的结果，而不是原因。</p><blockquote><p>阻塞和非阻塞关注的是程序等待调用结果时的状态，是闲置还是持续运行</p></blockquote><p>线程与进程</p><p>　　曾经考试的时候定义背的滚瓜烂熟，然而却完全没有代码经验，感觉彼时都到门口了，缺乏临门一脚，直到现在又千辛万苦来回到这里，重新完成当初没有做到的事情。</p><p>　　这里我在实践中，线程跟并发 搞混了，以至于以为线程之间必然是并发，所以有可能分时共享cuda 的引用，认为利用多线程就可以优化GPU利用率。最后实践中，怎么都达不到预想的目的。仔细想想，尽管同一个进程的资源可以被进程内的所有线程共享，这样如果多个线程是分时共享的，那么cuda引用作为一个共享资源，就可以达到并发使用的目的；但是这个前提是，线程必须是并发的，那么线程真的是并发的吗？如果是曾经的单核单线程CPU，答案是肯定的，现在的基本都是多核多线程CPU了，所以线程级别肯定是并行的，那么cuda引用则必然作为一个临界共享资源，被多个线程抢占使用，多线程并行退化成多线程并发，虽然预想的目的似乎达到了，但是貌似并没有达到优化的目的，至少跟之前编写的单线程基本性能是一样的。</p><p>　　其次是Python的GIL锁, Global Interpreter Lock，即任何Python 线程执行，只有GIL锁的线程才可以运行，也就是说一个进程下的多线程在Python下，永远只有一个线程在运行</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token punctuation">,</span> multiprocessing<span class="token keyword">def</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    x <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> x<span class="token operator">^</span><span class="token number">1</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>multiprocessing<span class="token punctuation">.</span>cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target <span class="token operator">=</span> loop<span class="token punctuation">)</span>    t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>上述程序在多核CPU下占有率只有100%，但是C++/Java改写的死循环，则可以每个核心都跑完，即4核心400%</p><p>更坑的是，GIL锁每个线程只有执行100条字节码的机会，那么有效的利用cuda资源则成为空谈，因为频繁的显存数据进出，比较浪费时间。所以python下一般都是利用多个进程来实现并行，因为多个进程有独立的GIL锁，互不影响。</p><p>　　惭愧的是，自己写了这么久的Python，居然才第一次面对并行化问题，才知道GIL锁有这么多繁琐的坑。理论上证实这样的不可行之后，有点失望，但是也还是保留机会来完成并行写日志这个小任务的，毕竟通过HTTP接口，再怎么并发，框架还是很好的完成的这些繁琐的坑，只需要在producer-consumer 框架下，实现并行接受，串行消费就可以了，这还是比较基础的一个改写，对自己还是有信心的。</p><p>　　线程安全，进程安全，意思就是在多线程或者多进程下，可以在代码中不加改变的直接使用，库和框架会自动解决并发和并行问题。其中 queue.Queue 就是线程安全的，下面就是利用Queue来实现进程间通信的producer-consumer</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> queue <span class="token keyword">import</span> Queue<span class="token keyword">from</span> threading <span class="token keyword">import</span> Thread<span class="token keyword">def</span> <span class="token function">producer</span><span class="token punctuation">(</span>out_q<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        out_q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">consumer</span><span class="token punctuation">(</span>in_q<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        data <span class="token operator">=</span> in_q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true"># 通过q通知 任务完成</span>      in_q<span class="token punctuation">.</span>task_done<span class="token punctuation">(</span><span class="token punctuation">)</span>q <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>t1 <span class="token operator">=</span> Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>consumer<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>t2 <span class="token operator">=</span> Thread<span class="token punctuation">(</span>taget<span class="token operator">=</span>producer<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># wait for all produced items to be consumed</span>q<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>　　优化点，队列的流量控制，q需要指定大小，必要时候阻塞Queue，以避免连锁效应导致程序运行失常，同时阻塞的队列也会形成死锁，通过非阻塞和设定超时时间，来处理队列满或者超时的情况，避免阻塞</p><pre class=" language-python"><code class="language-python">q <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    data <span class="token operator">=</span> q<span class="token punctuation">.</span>get<span class="token punctuation">(</span>block<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">except</span> queue<span class="token punctuation">.</span>Empty<span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token keyword">try</span><span class="token punctuation">:</span>    q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>item<span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">5.0</span><span class="token punctuation">)</span><span class="token keyword">except</span> queue<span class="token punctuation">.</span>Full<span class="token punctuation">:</span>    log<span class="token punctuation">.</span>warning<span class="token punctuation">(</span><span class="token string">'queued item %r discarded!'</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span></code></pre><h3 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h3><p>　　利用tornado接受并发的http请求，解析request_body之后，直接入列队伍q.put()，这里利用了tornado 的异步接受并发的特点，直接简化producer过程。接着只需要编写consumer，取出数据，写到文件即可</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> eliot <span class="token keyword">import</span> log_call<span class="token punctuation">,</span> start_action<span class="token punctuation">,</span> to_file<span class="token keyword">class</span> <span class="token class-name">LogHandler</span><span class="token punctuation">(</span>tornado<span class="token punctuation">.</span>web<span class="token punctuation">.</span>RequestHandler<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># eliot 直接利用装饰器来添加日志功能，只记录input, output</span>    @log_call    <span class="token keyword">def</span> <span class="token function">post</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>timestamp <span class="token operator">=</span> time<span class="token punctuation">.</span>ctime<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>recv_json <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>self<span class="token punctuation">.</span>request<span class="token punctuation">.</span>body<span class="token punctuation">,</span> strict<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>            q<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>timestamp<span class="token punctuation">,</span> self<span class="token punctuation">.</span>recv_json <span class="token punctuation">)</span><span class="token punctuation">)</span>            output_dic <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>                <span class="token string">'status'</span><span class="token punctuation">:</span> <span class="token string">'1'</span><span class="token punctuation">,</span>                <span class="token string">'result'</span><span class="token punctuation">:</span> <span class="token string">'success'</span>      <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>        <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'LogHandler Error: '</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token comment" spellcheck="true"># eliot.start_action 通过 with 来记录函数段，有点繁琐，但是对于某段代码的日志记录很方便</span><span class="token keyword">def</span> <span class="token function">consume_msg</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">with</span> start_action<span class="token punctuation">(</span>action_type<span class="token operator">=</span><span class="token string">'consume_msg'</span><span class="token punctuation">,</span> lenghth <span class="token operator">=</span> queue<span class="token punctuation">.</span>qsize<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">try</span><span class="token punctuation">:</span>                timestamp<span class="token punctuation">,</span> msg<span class="token operator">=</span> q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>                start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">with</span> start_action<span class="token punctuation">(</span>action_type<span class="token operator">=</span><span class="token string">'save_request_body'</span><span class="token punctuation">,</span> timestamp<span class="token operator">=</span>timestamp<span class="token punctuation">,</span>msg<span class="token operator">=</span>msg<span class="token punctuation">)</span><span class="token punctuation">:</span>                    save_body<span class="token punctuation">(</span>msg<span class="token punctuation">)</span>            <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>                <span class="token keyword">with</span> start_action<span class="token punctuation">(</span>action_type<span class="token operator">=</span><span class="token string">'consume_msg exceptiosn'</span><span class="token punctuation">,</span> timestamp<span class="token operator">=</span>timestamp<span class="token punctuation">,</span>e<span class="token operator">=</span>e<span class="token punctuation">,</span> msg<span class="token operator">=</span>msg<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'consume_mgs exception : '</span>  <span class="token punctuation">,</span> e<span class="token punctuation">)</span>consumer <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>consume_msg<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">)</span>consumer<span class="token punctuation">.</span>daemon <span class="token operator">=</span> <span class="token boolean">True</span> <span class="token comment" spellcheck="true"># 守护进程</span>consumer<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>　　至此，多进程的日志记录完成，同时也用上了之前一直想要用eliot日志系统，让日志看起来清爽了许多。</p><h3 id="RabbiMQ"><a href="#RabbiMQ" class="headerlink" title="RabbiMQ"></a>RabbiMQ</h3><p>RabbiMQ 的方案也写进来，毕竟原理大同小异，只是初始化和连接的部分需要重新封装一下，而且适用性更广。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># rabbitmq init</span>credentials <span class="token operator">=</span> pika<span class="token punctuation">.</span>PlainCredentials<span class="token punctuation">(</span>RabbitMQ<span class="token punctuation">.</span>USERNAME<span class="token punctuation">,</span> RabbitMQ<span class="token punctuation">.</span>USERPWD<span class="token punctuation">)</span>connection <span class="token operator">=</span> pika<span class="token punctuation">.</span>BlockingConnection<span class="token punctuation">(</span>                pika<span class="token punctuation">.</span>ConnectionParameters<span class="token punctuation">(</span>RabbitMQ<span class="token punctuation">.</span>HOST<span class="token punctuation">,</span> RabbitMQ<span class="token punctuation">.</span>PORT<span class="token punctuation">,</span>                                          credentials<span class="token operator">=</span>credentials<span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token comment" spellcheck="true"># channel init and declare</span>channel <span class="token operator">=</span> connection<span class="token punctuation">.</span>channel<span class="token punctuation">(</span><span class="token punctuation">)</span>channel<span class="token punctuation">.</span>exchange_declare<span class="token punctuation">(</span>exchange<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>EXCHANGE<span class="token punctuation">,</span>                             exchange_type<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>EXCHANGE_TYPE<span class="token punctuation">,</span>                             durable<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>channel<span class="token punctuation">.</span>queue_declare<span class="token punctuation">(</span>queue<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>QUEUE_NAME_ALG<span class="token punctuation">,</span> durable<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>channel<span class="token punctuation">.</span>queue_bind<span class="token punctuation">(</span>exchange<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>EXCHANGE<span class="token punctuation">,</span>                       queue<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>QUEUE_NAME_ALG<span class="token punctuation">,</span>                       routing_key<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>ROUTING_KEY<span class="token punctuation">)</span>channel<span class="token punctuation">.</span>basic_qos<span class="token punctuation">(</span>prefetch_count<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 能者多劳</span>channel<span class="token punctuation">.</span>basic_consume<span class="token punctuation">(</span>on_message_callback<span class="token operator">=</span>consumer<span class="token punctuation">,</span>                          queue<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>QUEUE_NAME_ALG<span class="token punctuation">,</span> auto_ack<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">' [*] Waiting for messages...'</span><span class="token punctuation">)</span>channel<span class="token punctuation">.</span>start_consuming<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">consumer</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> method<span class="token punctuation">,</span> properties<span class="token punctuation">,</span> body<span class="token punctuation">)</span><span class="token punctuation">:</span>    body <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>body<span class="token punctuation">,</span> strict<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    flag <span class="token operator">=</span> body<span class="token punctuation">[</span><span class="token string">'flag'</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># process body</span>    <span class="token comment" spellcheck="true"># Ack manually</span>    ch<span class="token punctuation">.</span>basic_ack<span class="token punctuation">(</span>delivery_tag<span class="token operator">=</span>method<span class="token punctuation">.</span>delivery_tag<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># producer.py</span><span class="token keyword">try</span><span class="token punctuation">:</span>    credentials <span class="token operator">=</span> pika<span class="token punctuation">.</span>PlainCredentials<span class="token punctuation">(</span>                RabbitMQ<span class="token punctuation">.</span>USERNAME<span class="token punctuation">,</span> RabbitMQ<span class="token punctuation">.</span>USERPWD<span class="token punctuation">)</span>    connection <span class="token operator">=</span> pika<span class="token punctuation">.</span>BlockingConnection<span class="token punctuation">(</span>                pika<span class="token punctuation">.</span>ConnectionParameters<span class="token punctuation">(</span>RabbitMQ<span class="token punctuation">.</span>HOST<span class="token punctuation">,</span> RabbitMQ<span class="token punctuation">.</span>PORT<span class="token punctuation">,</span>                                          credentials<span class="token operator">=</span>credentials<span class="token punctuation">)</span>            <span class="token punctuation">)</span>    channel <span class="token operator">=</span> self<span class="token punctuation">.</span>connection<span class="token punctuation">.</span>channel<span class="token punctuation">(</span><span class="token punctuation">)</span>    channel<span class="token punctuation">.</span>exchange_declare<span class="token punctuation">(</span>exchange<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>EXCHANGE<span class="token punctuation">,</span>                                                                                              exchange_type<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>EXCHANGE_TYPE<span class="token punctuation">,</span>                                          durable<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">pass</span>sent_msg <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;...&amp;#125;</span>body <span class="token operator">=</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>sent_msg<span class="token punctuation">)</span>channel<span class="token punctuation">.</span>basic_publish<span class="token punctuation">(</span>exchange<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>EXCHANGE<span class="token punctuation">,</span>                                       routing_key<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>ROUTING_KEY<span class="token punctuation">,</span>                      body<span class="token operator">=</span>body<span class="token punctuation">,</span>                       properties<span class="token operator">=</span>pika<span class="token punctuation">.</span>BasicProperties<span class="token punctuation">(</span>delivery_mode<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>channel<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>connection<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="计算密集型-和-IO密集型的思考"><a href="#计算密集型-和-IO密集型的思考" class="headerlink" title="计算密集型 和 IO密集型的思考"></a>计算密集型 和 IO密集型的思考</h3><p>　　当初写论文的时候，就在机器上跑了很多类型的负载任务，最直观的感受就是，计算密集型的负载比较难找，相对于纯粹的计算任务，很多实际的任务都会因为千奇百怪的原因被消耗在IO上，导致运行效率低下。</p><blockquote><p>计算密集型，代码运行效率为主，因为主要时间都消耗在CPU上，Python的脚本语言不适合这类任务，最好用C++/Java实现</p><p>IO密集型，大部分时间消耗在IO上，C++/Java无法发挥优势，代码量少开发效率最高的Python具备优势</p></blockquote><p>　　所以，Python最好最为原型开发，保持逻辑流程通顺的前提下，可以用其他高效的语言如C++/Java改写最耗时的模块，迭代优化开发。</p><h3 id="协程：单线程异步"><a href="#协程：单线程异步" class="headerlink" title="协程：单线程异步"></a>协程：单线程异步</h3><p>　　虽然Python无法利用多线程的并行优势，但是还是有优化的手段的。如果把条件限制到单线程，那么有一个很自然的优化方式就是单线程异步，也就是只用单线程的情况下，实现程序内部的并发，这个并发是程序可控的，而不是由操作系统来根据一定策略加锁。</p><p>　　Python下有协程库asyncio内置了异步IO的支持。编程模型是一个消息循环，从asyncio获取EventLoop引用，把需要执行的协程作为参数传递给EventLoop，实现异步IO,下面直接给出协程版本的producer-consumer</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">import</span> random<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">producer</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'producing : '</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># simulate io job</span>        <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        item <span class="token operator">=</span> str<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">await</span> queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">consume</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        item <span class="token operator">=</span> <span class="token keyword">await</span> queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># process item</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'consuming : '</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># simulate io </span>    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># notify queue that the item has been processed</span>    queue<span class="token punctuation">.</span>task_done<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    queue <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># schedule consumer</span>    consumer<span class="token operator">=</span> asyncio<span class="token punctuation">.</span>ensure_future<span class="token punctuation">(</span>consume<span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> producer<span class="token punctuation">(</span>queue<span class="token punctuation">,</span> n<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># wait until consumer processed all items</span>    <span class="token keyword">await</span> queue<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># consumer is still awaiting item, cancel it</span>    consumer<span class="token punctuation">.</span>cancel<span class="token punctuation">(</span><span class="token punctuation">)</span>loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>run<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>loop<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>　　至此，关于同步异步的一些知识点和实践问题梳理完毕，协程的实践经验还是有点欠缺，以后看框架源码的时候，需要多学习和思考。</p><p>References:</p><p><a href="https://asyncio.readthedocs.io/en/latest/producer_consumer.html">Producer/consumer-examlpe_asyncio</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017968846697824">协程-廖雪峰</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017631469467456">进程-线程-廖雪峰</a></p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p03_communicating_between_threads.html">线程间通信-Python_CookBook</a></p><p><a href="https://juejin.cn/post/6844904039210024967#heading-3">Python下的多进程日志记录方案</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 33. Search in Rotated Sorted Array</title>
      <link href="algorithm/leetcode-33-search-in-rotated-sorted-array/"/>
      <url>algorithm/leetcode-33-search-in-rotated-sorted-array/</url>
      
        <content type="html"><![CDATA[<h3 id="LeetCode-33-Search-in-Rotated-Sorted-Array"><a href="#LeetCode-33-Search-in-Rotated-Sorted-Array" class="headerlink" title="LeetCode 33. Search in Rotated Sorted Array"></a>LeetCode 33. Search in Rotated Sorted Array</h3><p><img src="img1.png"></p><p>　　应该是二分法的变种优化，但是实际分析的过程中，自己的想法被太多的if条件给弄晕了，虽然勉强解出来了，但是更多是凭借临场发挥来作出的，至于宏观的算法原理，自己仍然理解不够透彻，借助讨论区的总结出几个好玩的解法</p><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>　　最直接的想法是找到数组的偏移量，通过还原数组为排序数组的方式，最终利用二分法搜索target ，但是自己并没有想出可以$O(log(n))$搜索偏移量的方法，所以没有深入思考。借助讨论区的提醒，其实偏移量就是最小值的下标，所以只需要找到一种在$O(log(n))$下找到最小值的方法，这里仍然是用二分法，只不过start, mid, end 之间比较关系是不同的</p><ul><li>start 和 mid:</li></ul><p>　mid &gt; start : 最小值 in left</p><p><img src="img3.jpg"></p><p>　mid &lt; start : 最小值仍然 in left:</p><p><img src="img2.jpg"></p><ul><li>mid 和 end</li></ul><p>　　mid &lt; end: 最小值 in left，end = mid</p><p><img src="img6.jpg"></p><p>　　mid &gt; end : 最小值 in right, start = mid</p><p><img src="img7.jpg"></p><p>　　只需要mid 和 end就可以利用二分法搜索最小值，只不过需要注意的一点是，可能会出现死循环</p><p><img src="img8.jpg"></p><p>　　主要原因应该是，当最小值in right 的时候，mid 原地更新，而在in right 的情况，实际上mid所在的value不可能是最小值，所以 start = mid + 1 即可</p><pre class=" language-python"><code class="language-python"><span class="token keyword">while</span> start <span class="token operator">&lt;</span> end<span class="token punctuation">:</span>    mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end <span class="token punctuation">)</span> <span class="token operator">//</span><span class="token number">2</span>    <span class="token keyword">if</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">:</span>        start <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        end <span class="token operator">=</span> midbias <span class="token operator">=</span> start</code></pre><p>　　最后利用偏移量，转换mid 为 偏移后的mid，二分搜索target</p><pre class=" language-python"><code class="language-python">start <span class="token operator">=</span> <span class="token number">0</span>end <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token keyword">while</span> start <span class="token operator">&lt;=</span> end<span class="token punctuation">:</span>    mid <span class="token operator">=</span> <span class="token punctuation">(</span>start<span class="token operator">+</span>end<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>    mid_pos <span class="token operator">=</span> <span class="token punctuation">(</span>mid <span class="token operator">+</span> bias<span class="token punctuation">)</span>     <span class="token operator">%</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    val <span class="token operator">=</span> nums<span class="token punctuation">[</span>mid_pos<span class="token punctuation">]</span>    <span class="token keyword">if</span> target <span class="token operator">==</span> value<span class="token punctuation">:</span>        <span class="token keyword">return</span> mid_pos    <span class="token keyword">if</span> target <span class="token operator">&lt;</span> value<span class="token punctuation">:</span>        end <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        start <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span></code></pre><p>Time Complexity: $O(log(n))$</p><p>Space Complexity: $O(1)$</p><h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>　　这里还是将被切分的2段分成2个有序数组来处理，比如,[4 5 6 7 1 2 3 ]分成 [4 5 6 7 ]和[1 2 3 ]，判断target位于其中的哪一段，然后将另一段变成-inf or inf，这样做的目的是可以用正常的二分法来搜索改变后的数组。</p><p>[ 4 5 6 7 1 2 3] ，如果 target = 5，那么数组可以看做 [ 4 5 6 7 inf inf inf ]。</p><p>[ 4 5 6 7 1 2 3] ，如果 target = 2，那么数组可以看做 [ -inf -inf - inf -inf 1 2 3]。</p><p>　　实践阶段，只需要判断nums[mid]的val，如果val跟target同一段，val不变，如果val跟target不通段，就要变成-inf or inf</p><ul><li>nums[mid] 和 target 同一段的条件: </li></ul><pre class=" language-python"><code class="language-python">nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">and</span> target <span class="token operator">></span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">or</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">and</span> target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></code></pre><ul><li>nums[mid] 和 target 不通段的条件：</li></ul><pre class=" language-python"><code class="language-python">nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">and</span> target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">or</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">and</span> target <span class="token operator">></span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></code></pre><p>这样动态的变更nums[mid]的val，保持nums始终与target同段段那部分不变，不同段则变为-inf or inf</p><pre class=" language-python"><code class="language-python">lo <span class="token operator">=</span> <span class="token number">0</span>hi <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token keyword">while</span> lo <span class="token operator">&lt;=</span> hi<span class="token punctuation">:</span>    mid <span class="token operator">=</span> <span class="token punctuation">(</span>lo<span class="token operator">+</span>hi<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>    val <span class="token operator">=</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">></span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span>target <span class="token operator">></span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        val <span class="token operator">=</span>  float<span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span> <span class="token keyword">if</span> target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">else</span> float<span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> val <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>        lo <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">elif</span> val <span class="token operator">></span> target<span class="token punctuation">:</span>        hi <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> mid  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span></code></pre><p>Time Complexity: $O(log(n))$</p><p>Space Complexity: $O(1)$</p><h4 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h4><p>　　基于一个事实，数组从任意位置劈开后，至少有一半是有序的</p><p>　　这里只需要判断二分法的其中一半是否有序， 再根据有序的这一部分判断target是否包含其中</p><pre class=" language-python"><code class="language-python">lo <span class="token operator">=</span> <span class="token number">0</span>hi <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token keyword">while</span> lo <span class="token operator">&lt;=</span> hi<span class="token punctuation">:</span>    mid <span class="token operator">=</span> <span class="token punctuation">(</span>lo<span class="token operator">+</span>hi<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>    val <span class="token operator">=</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span>    <span class="token keyword">if</span> target <span class="token operator">==</span> val<span class="token punctuation">:</span>        <span class="token keyword">return</span> mid        <span class="token comment" spellcheck="true"># lo-mid 有序</span>    <span class="token keyword">if</span> nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> val<span class="token punctuation">:</span>        <span class="token keyword">if</span> target <span class="token operator">>=</span> nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span> <span class="token operator">and</span> target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">:</span>            hi <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            lo <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># mid-hi 有序</span>        <span class="token keyword">if</span> target <span class="token operator">></span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">and</span> target <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>hi<span class="token punctuation">]</span><span class="token punctuation">:</span>            lo <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            hi <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span></code></pre><p>Time Complexity: $O(log(n))$</p><p>Space Complexity: $O(1)$</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>　　$log(n)$的时间复杂度，基本都是二分法的变体，平日自己对二分法过于忽视，导致理解不深刻，所以这个题目做起来才比较费劲。除此之外，解法二巧妙的利用了target 和 nums[mid]是否同一个分割排序段的条件，来简化判断，同时动态的更新nums[mid]值的方法很有启发性，比自己笨拙的设置一大堆if条件，结果自己都搞不清楚状况来的优雅许多。解法一二都是利用抽取出的关键信息来还原二分搜索法，解法三，则是试图找到target分段之前，获取排序信息，再以及排序信息搜索target，题目顿时变的简单了许多。</p><p>Reference:</p><p><a href="https://leetcode.wang/leetCode-33-Search-in-Rotated-Sorted-Array.html">LeetCode 33. Search in Rotated Sorted Array</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记ubuntu重启引起的故障排查</title>
      <link href="yun-wei/ji-ubuntu-chong-qi-yin-qi-de-gu-zhang-pai-cha/"/>
      <url>yun-wei/ji-ubuntu-chong-qi-yin-qi-de-gu-zhang-pai-cha/</url>
      
        <content type="html"><![CDATA[<p>　　前几天，由于自己服务所在的服务器需要停机维护，运行已有近半年的ubuntu 18.04 LTS终于迎来首次重启，尽管由于预料到长时间的服务器不停机，在关机或者重启阶段会有不可预知的事件发生。但是当服务器真的出现网络无法连接的状况的时候，长时间没有安装系统的我那一刻竟然还有点懵B了，此文主要关注此次故障问题排查和解决记录，作为以后服务器维护 参考之用。</p><h3 id="网络故障"><a href="#网络故障" class="headerlink" title="网络故障"></a>网络故障</h3><p>　　重启之后，首先出现的问题就是网络接口灯直接熄灭，几番周折接上显示器和键盘之后，发现是网卡没有ipv4的地址，反而是ipv6的地址是有的。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ifconfig</span> -a <span class="token comment" spellcheck="true"># 显示所有的网卡，如果网卡无ip，单纯的用ifconfig 是无法显示的所有网卡设备的</span><span class="token comment" spellcheck="true"># or</span>ip a</code></pre><p>　　考虑现今的网络设备ipv6基本属于摆设，所以首先定位的问题是静态ip配置没有生效（此刻持续懵B 3mins，完全忘记如何手工配置 静态ip，某些最基础的操作，还是相当依赖UI），搜索一番得到结果是</p><pre class=" language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/network/interfaces<span class="token comment" spellcheck="true"># change</span>auto enp1s0 <span class="token comment" spellcheck="true"># enp5s0 根据ifconfig 或许实际的网卡编号</span>iface enp1s0 inet static        address x.x.x.x        netmask 255.255.255.0        gateway x.x.x.x        dns-nameservers 114.114.114.114 8.8.8.8<span class="token function">sudo</span> ip a flush enp1s0<span class="token function">sudo</span> systemctl restart networking.service</code></pre><p>　　悲剧的是，最后重启 networking.service 并没有发现这个服务，一度陷入僵局，最后发现 Ubuntu 18.04 LTS 开始启用 netplan 组建作为网络管理器，所以这里应该使用netplan来配置静态ip，又是搜索一番</p><pre class=" language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/netplan/50-cloud-init.yaml <span class="token comment" spellcheck="true"># 对于yaml文件可是深恶痛绝，奇怪冒号后必须接空格 和 不允许 缩进\t的设定</span><span class="token comment" spellcheck="true"># change</span><span class="token comment" spellcheck="true"># This file describes the network interfaces available on your system</span><span class="token comment" spellcheck="true"># For more information, see netplan(5).</span>network:  version: 2  renderer: networkd  ethernets:    enp1s0:     dhcp4: no     addresses: <span class="token punctuation">[</span>192.168.1.222/24<span class="token punctuation">]</span>     gateway4: 192.168.1.1     nameservers:       addresses: <span class="token punctuation">[</span>8.8.8.8,8.8.4.4<span class="token punctuation">]</span><span class="token function">sudo</span> netplan apply<span class="token comment" spellcheck="true"># or</span><span class="token function">sudo</span> netplan --dubug apply</code></pre><p>　　坑爹的是，居然没有 netplan 这个命令，然而却有/etc/netplan/50-cloud-init.yaml这个配置网络的文件，而且里面都是曾经配置完好的文件，应该是上次安装就已经确定下来生成的配置文件，这个就属于很小众的问题了，徜徉 StackOverFlow 和 StackExchange 数小时之后得到答案是：从 Ubuntu 16.04  Upgrade Ubuntu 18.04 会出现 netplan 配置已经安装，但是仍然使用 /etc/network/interfaces 配置ip生效的情况。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># netplan 安装 </span><span class="token function">sudo</span> apt <span class="token function">install</span> netplan.io <span class="token comment" spellcheck="true"># 坑爹的软件包命名</span></code></pre><p>但是在这两个文件都存在，同时都配置的情况下，仍然无法使静态ip的配置生效，最主要的是，这个服务器就是原生安装的Ubuntu 18.04 ，并不存在Upgrade 导致这个问题存在的原因。最后无奈，只能通过命令临时生效的静态ip配置，来勉强达到可以上网的目的，想来毕竟服务器24h不关机，临时配置也算可用。唯一的缺点就是，万一重启，就又不得不去机房，现场维护，颇为不便。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 临时生效的 ip 网关 dns 配置方法</span><span class="token comment" spellcheck="true"># 以下所有配置 重启失效</span><span class="token function">ifconfig</span> enp1s0 x.x.x.x netmask 255.255.255.0route add default gw x.x.x.x<span class="token function">vi</span> /etc/resolf.conf</code></pre><h3 id="nvidia-smi-以及-docker-故障"><a href="#nvidia-smi-以及-docker-故障" class="headerlink" title="nvidia-smi 以及 docker 故障"></a>nvidia-smi 以及 docker 故障</h3><p>　　更坑爹是，总算以为完事了的时候，发现nvidia-smi挂了，docker也挂了</p><pre class=" language-bash"><code class="language-bash">nvidia-smiNVIDIA-SMI has failed because it couldn’t communicate with the NVIDIA driver. Make sure that the latest NVIDIA driver is installed and running.</code></pre><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析　　"></a>原因分析　　</h3><p>　　结合之前网络问题，推测应该是重启导致的系统层面的问题。考虑到此次维护硬件只有内存的变动，通过命令查看内存是正常运作的，判断应该是 Ubuntu 系统在重启的时候发生的变化，导致这个问题发生。以ubuntu重启，nvidia 失效，作为关键词，终于找到本次故障的最终原因：Ubuntu 18.04 会自动更新linux内核，并在重启的时候自动启动最新的内核</p><h3 id="故障解决，切换成旧版本内核"><a href="#故障解决，切换成旧版本内核" class="headerlink" title="故障解决，切换成旧版本内核"></a>故障解决，切换成旧版本内核</h3><p>　　首先需要确认旧版本内核是否可以解决上述所有问题，最简单的切换就内核的方法是，在 grub 启动菜单里面选择,Advanced options for Ubuntu -&gt; Ubuntu , with linux x.x.x-x-generic ， 终于找到了4.15.0-60-generic 是旧版本内核，并且上述问题全部解决，而4.15.0-122-generic则是产生故障的最新内核版本。</p><p>　　那么问题来了，怎么切换内核呢？ 搜索引擎救星又来了</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看目前系统已安装内核</span>dpkg --get-selections <span class="token operator">|</span><span class="token function">grep</span> linux-imagelinux-image-4.15.0-122-generic            deinstalllinux-image-4.15.0-60-generic            <span class="token function">install</span>linux-image-4.15.0-62-generic            deinstall<span class="token comment" spellcheck="true"># 查看 grub 已经生成 菜单入口名称</span><span class="token function">grep</span> menuentry /boot/grub/grub.cfgmenuentry <span class="token string">'Ubuntu, with Linux 4.15.0-60-generic'</span> <span class="token punctuation">..</span>.</code></pre><h4 id="Solution-1-修改grub启动配置"><a href="#Solution-1-修改grub启动配置" class="headerlink" title="Solution 1: 修改grub启动配置"></a>Solution 1: 修改grub启动配置</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/default/grub<span class="token comment" spellcheck="true"># change</span>GRUB_DEFAULT<span class="token operator">=</span>“Advanced options <span class="token keyword">for</span> Ubuntu <span class="token operator">></span> Ubuntu, with Linux 4.15.0-60-generic”<span class="token comment" spellcheck="true"># 也可以 用数字标示 0作为第一个菜单</span>GRUB_DEFAULT <span class="token operator">=</span> <span class="token string">"1> 4"</span> <span class="token comment" spellcheck="true">#改成这样</span>GRUB_TIMEOUT_STYLE<span class="token operator">=</span>menu <span class="token comment" spellcheck="true"># default: hidden</span>GRUB_TIMEOUT<span class="token operator">=</span>3 <span class="token comment" spellcheck="true"># default: 0</span><span class="token function">sudo</span> update-grub<span class="token function">sudo</span> <span class="token function">reboot</span></code></pre><h4 id="Solution-2-删除新内核"><a href="#Solution-2-删除新内核" class="headerlink" title="Solution 2: 删除新内核"></a>Solution 2: 删除新内核</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 注意 无法删除正在使用的内核</span><span class="token function">sudo</span> apt remove linux-image-xxx-xx-generic<span class="token comment" spellcheck="true"># or</span><span class="token function">sudo</span> dpkg --purge linux-image-x.x.x-xx-generic<span class="token comment" spellcheck="true"># 安装新内核</span><span class="token function">sudo</span> apt <span class="token function">install</span> linux-headers-x.x.x-x-generic linux-image-x.x.x-x-generic<span class="token comment" spellcheck="true"># 关闭内核自动更新</span><span class="token function">sudo</span> apt-mark hold linux-image-generic linux-headers-generic<span class="token comment" spellcheck="true"># 开启内核自动更新</span><span class="token function">sudo</span> apt-mark unhold linux-image-generic linux-headers-generic</code></pre><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>　　至此，网络问题，nvidia驱动问题，docker问题都得到圆满解决。回顾过程，心态方面还是稍微不够沉着冷静，发现问题根本原因之前，过分关注表象，诸如 netplan 的配置花费的过多时间，反而问题原因没有深入思考，导致东弄西弄一下，试图用碰运气的方式来解决问题方式终究还是有瓶颈的，或许是碰运气的方式曾经取得的成果对现在行为抉择还是产生的一定的影响，其实在陷入僵局之后的思考基本已经锁定了问题，就算是没有解决问题的彼时，心里对故障的排除已经基本有底了，最后的解决也只是水到渠成而已。</p><p>References:</p><p><a href="https://linuxconfig.org/how-to-configure-static-ip-address-on-ubuntu-18-04-bionic-beaver-linux">How to configure static IP address on Ubuntu 18.04 </a></p><p><a href="https://askubuntu.com/questions/1034711/how-to-enable-netplan-on-ubuntu-server-upgraded-from-16-04-to-18-04">How to enable netplan on ubuntu server upgraded from 16.04 to 18.04</a></p><p><a href="https://blog.csdn.net/qq_43222384/article/details/90314297">ubuntu18.04 内核自动更新导致驱动掉了</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> 故障排查 </tag>
            
            <tag> linux内核 </tag>
            
            <tag> grub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>改变与懒惰：主观能动性讨论</title>
      <link href="sui-bi/gai-bian-yu-lan-duo/"/>
      <url>sui-bi/gai-bian-yu-lan-duo/</url>
      
        <content type="html"><![CDATA[<p>　　前段时间，大概是在暑假期间吧，似乎因为看了很多动漫，仍然沉迷在学生时代的火热的夏天气息中。是呀！美好的夏天，如梦似幻。然而最难过的是，尽管现在的我无论想要如何去追寻这种夏日的味道，哪怕只是夏天的尾气而已，我却仍然无比清晰的认识到，自己的暑假早已经一去不复返了。这让自己陷入到一个两难的境地，一面渴望夏日的美好，一面却又警醒自己去接受事实，既无法肆意去做自我，也没办法彻底的放弃，去追寻所谓的成熟，就特别的拧巴。至于为什么总是要自己接受自己不断长大的事实，我也不甚明了，仿佛跟自己说的多了，就真的成长了一样。可能唯一让自己神伤的就只是不断变老的事实吧，或许告诉自己去年的自己跟现在的自己其实没什么太多变化和进步，那么多少有点对不起自己不断老去的时间，所以滋生出这样心理暗示，说是聊以慰己也好，说是对自己的失望继而产生的愧疚也好，总之，都是一份对自己自甘堕落，原地踏步的一种惩罚吧！所以，带着这份不甘，不明就里的开始了这份夏日的无聊幻想。</p><p><img src="IMG_9373.jpeg" alt="2020-07-31"></p><p>　　清楚记得是在7月31日，下班从公司回家， 开车走了一条平时从来没有走过的路，天色湛蓝，久违的看到了雾状的云絮，随着落日余晖，呈现出一幅不断变幻的黄昏美景，在这个陌生的却干净的路上走着，有一种异域他乡的漂泊感油然而生。不得不感叹，人有时候就是这么的任性，假如面对突然变化的外部环境，心情不免充满了惊慌和不安；但是一旦在舒适区呆的足够久，却又开始渴望起陌生的神秘起来。所以，在那一刻，我有点爱丽丝梦游仙境的不真实感，才从二次元的幻想出来，又来到这里，心中突然诞生起一股强烈的想要去亲眼见证 命运石之门，青春猪头少年，灌篮高手，你的名字 里面二次元名场景的三次元场景的冲动。这其中当然有自己近段时间一直懒于出游，疫情原因，甚至直接放弃远行的原因，已经快有一年没有认真旅行了，去年这个时候，还沉浸在五月天鸟巢演唱会的期待中。没想到一年后，都快要忘记旅行是什么感觉了，心中只有漠然和麻木。我熟悉这种感觉，当我十年前无法面对自己的时候，我就是这样一步一步麻痹自我，无视自己的感觉，任由时间和偶然的未来来试图冲淡这份难过，虽然几次试图反抗，但是最后还是来到了自己预想中的，失去了爱和共情能力的终点。等到意识到，这样堕落下去，并不能真正解决这份难过的时候，又过去了好久好久。想要改变的时候，心中的那份激情早已经烟消云散了，当我想要去喜欢的时候，内心却做到真正意义上的毫无波澜，直到再次遇见的二次元，这种状况才好起来。所以此时，我又重新遭遇了这份想要改变，却无法调动自己的内心的尴尬，似乎在这十年间，我无意识间培养出一股冷眼旁观的特质，无论是跟自己是否相关的人和事，习惯性的把自己置身事外，试图冷静分析利弊得失，却完全丧失了<strong>意识主观能动性</strong>，这股自己窃以为最核心和宝贵的动力，我明白，我所尊崇的理性，作为绝对意义上的中立，统治了自己的是非观，但是一旦要去自己去亲自上阵的时候，光有理性，总是感觉差点什么东西，实践起来也并不是那么得心应手，甚至还有点举步维艰。总之，无论做什么，我缺乏一种，“当我在做这件事，我在做什么的” 的自觉性。记得不久前，自己还有强烈的这种动力想要实现梦想，却在错失良机之后，陷入长久的沉寂。当工作从长远来看不受自己控制的变得愈加明朗起来的时候，自己陷入了对未来的强烈不安之中。造成如今的局面，都是有点自己自暴自弃的成分在里面，屏蔽自己感情，活在当下，试图忘掉自己的梦想，成为了如今自己生活的主题。自我屏蔽，前面已经聊过，被证实只是一种自我麻醉而已，跟逃避没什么两样，对于解决问题，没什么卵用；活在当下，虽然并没有什么不好，但是作为浑浑噩噩度日的借口，时间久了，自己也有点不好意思起来；试图忘记梦想，真的是逃避之集大成者。兜兜转转，最后还是来到了需要认真面对自己的这个路口，时间只不过让自己忘却了些许忧伤，积攒了一点可怜的勇气而已。如果自己没有根本性的转变和思想觉悟，我并不认为自己能有所突破。</p><p>　　所以，回到，发现问题，认识问题，解决问题 的模式 ！</p><p>发现问题：    </p><p>​    <strong><em>生活缺乏 目标，激情和动力！</em></strong></p><p>认识问题：</p><p>　　按照 身边人面对这个问题的惯常思路，没有动力，给压力就好了。我并不否认这种方法的有效性，但是我一方面不认可这种方法，另一方面我本身也不是很习惯这种被迫做事的急促感，我认为扼杀了创意和生活的乐趣。曾经我也讨论过这个问题，得出的结论是，我并不适合这种压迫产生的动力；但另一方面，自己却由于过分懒散，反而落入了完全忘记自己的目标是什么的另一个极端。这样的后果就是，摸鱼到一定程度，自己甚至都开始厌恶这样无所事事的日子，想要找点事情来分散下多余的脑力，这个时候甚至反而觉得有点儿事做还挺有意思的。很遗憾的是，目前自己正处于这种状态，由于工作内容对自己来说比较容易，自己也没有适时的给自己足够的挑战，10月份以来，自己一直处于这种慵懒的状态，所以整个月的都处于基本停止的状态。仔细想来，应该是上次的面试结束之后，由于非技术原因没拿到offer，尽管情绪上来说没什么影响，但是准备算法OJ的积极性有点下降，努力想要认真刷算法题的这个弦突然就松下来了，这才导致后续很多事情都开始丧失积极性直到彻底懒得去做了。从这个角度来说，自己在战略上，还是需要足够的压力来推进自己去实践，否则很容易落入偷懒的陷阱之中。譬如，每天的总结，每周的反思，都在那之后渐渐都没有了；细想之下，我都是用，不做也没什么，晚点做也一样这种轻描淡写的借口一带而过。想来，自己也足够鸡贼，在缺乏意识驱动的事情上，是没有感情的理性机器，在这种需要理性监督的日常惯例上，却贪图一时的便利，自欺欺人起来。说到这里，猛然发现自己有一个很坑爹的问题就是，每当某些事做的很好的时候，心里洋溢着开心和满足，发自内心的对自己说，原来认真一把，也很有意思很好玩的，信誓旦旦的对自己说，记住这种感觉，明天也要这样加油努力。 转头就把这些警醒忘得一干二净，反而在满足感的驱使下开始完全放松的日子。从根源上来讲，自己这个问题应该是，目标太小，易于满足；然而另一方面，为了从长远角度保证计划的实施同时保持生活的乐趣，避免陷入某天计划没完成，直接导致后续计划的崩盘，本来就没有给每天安排很多任务，所以这样就陷入了一种矛盾的状态。 面对这个事情，我想起来之前 看到的<strong>延迟满足</strong>这个词，当时看的就觉得虽然意思明白，但是实践起来是什么样子，没有什么概念。现在或许能有点明白，应该是，满足感留在完成那一天，但是再接再厉的警醒，还是需要时刻提醒自己，在整个规划中，自己走到哪一步了，有了今天 的成果，明天该怎么更进一步，这种不断进步的渴求，才是敦促自己前进的最原始的动力。</p><p>解决问题：</p><p>　　用认真的态度过好每一天，而不是得过且过的自我敷衍。这其实是自己一直没太关注的，总是试图用全局的计划和美好的理想来敦促自己，发现仍然过不好每一天的生活。渴望进步的决心，是绝对不会变的，但是认真的态度，特别是每天都坚持保持这种精神，实际是不容易办到的，而且偶尔的放松，实际上对自己有很大影响，因为自己特别容易自暴自弃，接受那些不受控制或者并非属于自身原因的变化，享受当下认真带来的满足和乐趣，放眼明日需要改变和努力的方向，过好自己的每一天，我想也不会有那种缺乏目标，激情和动力的乏味感觉了吧！</p><p>　　说到这里，这篇关于懒惰和改变的讨论应该已经得到答案了。但是彼时对夏日的怀恋和异域的沉迷并没有得到解决，似乎一场旅行是非常有必要的，虽然真的很想去日本旅游，遗憾的是年末疫情复发可能对出国旅行产生很大的影响，不过究竟是什么程度的影响，自己也并没有做过多考察，剩下几个月的时间，自己还是应该鼓起干劲，多做一些信息上的搜集和准备，努力规划一场美好的动漫朝圣之旅。</p><p><img src="2020-07-31.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要写博客？</title>
      <link href="sui-bi/my-first-blog/"/>
      <url>sui-bi/my-first-blog/</url>
      
        <content type="html"><![CDATA[<p>　　我有一个很奇特的习性，就是无论做任何事情，喜欢起个大早，却赶了个晚集；究其原因，想来应该是一直以来困扰我的慵懒毛病，做什么事情都是三分钟热度，热情消退之后，很多设想都被抛诸脑后，结果留下一地鸡毛。曾经几度自我挣扎过，甚至几度接近成功，但是每次达到一定高度之后，很快就如弹簧般反弹到最初的起点。从这个角度分析，我想应该是每次跟自我的斗争时候，都没有树立一个明显的目标，结果在对付完心中的对自己的愧疚和不甘之后，很快的便沉溺于自我满足的情绪中，直到意识到自己是不是该做点什么来拯救一下自己。写博客的设想也是如此，曾经看到过很多博主在序言中论述自己为何写博客，很多文字和想法都对自己很有感触，觉得自己也完全可以学习这种做法，努力提升自己，改变自己。这就有了第一次想写blog的想法，来自于模仿，然而遗憾的是，行动力太差，这个设想也仅仅停留在设想而已；随后无论是写日记，记录此时自己的所思所想，学习笔记，工作笔记，算法刷题的小结，看书感想，电影鉴赏，动漫观后感，旅游记录等，其实都零零碎碎都产生了很多碎片化的记录，只是没有按照合理的结构组织成一份文章而已。真正意识到这种记录的整理是非常非常有必要的是在看自己的相册的时候，恍惚间自己居然已经做过这么多事情，留下了这么多图片记录，自己居然完全不记得了，而且看自己相册的过程是一个跟理想中的美好回忆完全不同的艰难历程，其中充斥着废图，毫不相干的图片，甚至毫无意义，不明所以的照片，严重干扰了自己的回忆活动，尽管iOS很贴心的用算法整理出了一些有主题的照片合辑，但是仍然杯水车薪，难以从根本上解决这个问题。每次想到，曾经经历过如此重要的经历，尽管有文字，图片甚至视频记录下来了，但是却散落在这些毫不相干的地方，自己只是一味的寻求记录，仿佛有着疯狂的收集癖的人一样，疯狂的记录着自己周遭的一切，却完全忘记了要去用心去感受和回忆经历的那些重要时刻。等到自己忘记的差不多的时候，才偶然发现有这么一个记录存在，然而这个时候再回忆的时候，发现自己心里毫无涟漪，似乎在看一个跟自己无关的人的过去那样欣赏着这些破碎的记录，每次想到这里，感觉异常可惜。</p><img src="Euphonium_Movie_2nd_KV.jpg" width="50%" height="50%"><p>　　所以便有了想要通过写blog的方式来记录下自己的经历的想法，遗憾的是，这个虽然不算很复杂的事情，自己也一直没有提上日程，直到近一年来，由于疫情的原因，开始有了足够的时间来思考这个事情，这期间也培养了自己做规划，做总结并不断完善的习惯，这多亏了非常厉害的博主<a href="http://freemind.pluskid.org/">pluskid/freemind</a> 的一篇<a href="http://freemind.pluskid.org/misc/knowledge-accumulate/">关于知识整理，积累与记忆</a> 的优秀文章，恰逢其时的解决了我关于知识和记忆的一些困扰，所以很顺利的便开始学习和实践起来，收到了很不错的效果，如果不是由于自己间歇性的懒惰，应该还能做的更好。（关于这位厉害的博主，之前也写过不少文章，活成自己希望的样子，每次都能恰到好处的激励自己，以后一定要把这些文章都挪到这里来）</p><p>　　在囤积了足够多的文章之后，也到了要准备把这些记录整理输出到页面上的时候了，没想到这个进程被我从7-8月份生生拖到了十月份，才开始着手技术选型和部署相关的事宜，虽然从定制角度，wordpress是最初的首选，但是起数据库的管理方式对于文章为主的组织方式还是觉得有点不习惯，再则很早以前小试过Hexo，上手起来还是很舒适，奇怪的是，熟悉的概念和框架，也还是花了整个下午的时间去测试，磕磕碰碰的，虽然勉强完成了，但是潜意识里对自己的高要求和鄙夷，多少还是让这个成果来的不是那么爽快。我觉得是背负了之前曾经学过这个负担，所以测试途中的任何波折都会成为一个自我否定的理由。之前也讨论过，自己总是潜意识的用否定和打压来给自己前进的动力，但是为什么一直是负反馈的逼迫，而不是正反馈的鼓励，我不得而知，仿佛给压力是前进的唯一动力，而现在我意识到这种方法并不总是有效，反而很影响心情和状态的时候，决心想要改变这个势态。从部署Blog的过程中观察到的这个小心翼翼和不自信的事实，自己这方面还有很大的进步空间。此处就不多展开了，总之，大体的框架都布置好了，只剩下文章了。在选择技术框架的时候，有个回答很好，无论是什么blog框架，坚持写作才是最重要的。提醒了我，不断的优化和改进才是完美进化的捷径，一步到位只是完美主义者的美妙幻想而已。尽管只完成了hexo和主题的最基础的修改，但是起码最重要的文章已经准备就绪，其他的细节以后一步一步的改进和优化。</p><p><img src="relife-1.png"></p><p>　　絮絮叨叨的说了很多，好像都没有触及到自己的blog想要记录的关键，想起不久前看的一部番Relife 中的一个问题，既然认定了青春会结束，恋爱会终结，毕业之后，这一切都烟消云散，为什么此刻要执着于对方呢？这一切的意义是什么？ 我和主人公想的是一样的，就是这些对黄金时代美好事物的追求，会成为生命中最珍贵的回忆，就算最后可能一无所获，但是曾经那份雄心壮志，觉得自己无所不能的勇气，以后和最珍惜的伙伴的度过那些美好岁月，都是未来路上自己所能依仗的一切了。自己早已不复黄金岁月，每每想起，总是心酸无奈，五味杂陈。很多事情都渐渐遗忘，我无法忍受自己面对这种消逝，却选择无动于衷，总是想方设法的要留住。最终，发现还是用文字记录下来，才是对自己最好的一种交代，因为用心在写，用心在看。幸运的是，自己并没有忘记自己的梦想和追求，有很多事很多计划都亟待自己去实现，戒骄戒躁，更要戒怠惰，享受前进途中的种种风景，毕竟人生路上还有很多美好等着自己去探索，怎能因为这些微不足道的原因妨碍自己去追求和享受呢？</p><p><img src="relife-2.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="test/hello-world/"/>
      <url>test/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
