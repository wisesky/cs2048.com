<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode 126. Word Ladder II</title>
      <link href="uncategorized/leetcode-126-word-ladder-ii/"/>
      <url>uncategorized/leetcode-126-word-ladder-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find all shortest transformation sequence(s) from <em>beginWord</em> to <em>endWord</em>, such that:</p><ol><li>Only one letter can be changed at a time</li><li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li></ol><p><strong>Note:</strong></p><ul><li>Return an empty list if there is no such transformation sequence.</li><li>All words have the same length.</li><li>All words contain only lowercase alphabetic characters.</li><li>You may assume no duplicates in the word list.</li><li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li></ul><p><strong>Example 1:</strong></p><pre><code>Input:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Output:[  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]]</code></pre><p><strong>Example 2:</strong></p><pre><code>Input:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]Output: []Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation</code></pre></blockquote><p>　　这是一道似曾相识的Hard题，却意外的卡了好几天，好在最后还是凭借自己完成的算法方案，差一点AC，TLE的程度，最后试图优化无果，搜索Discuss，发现Python高赞方案跟自己的如出一辙，只不过在最费时的状态图构建上，做了很好的优化，借助这个优化思路，也很快获得了AC，学到了很好的优化经验。</p><p>　　说到似曾相识，是因为自己曾经做过的Frog Jump 也是一道Hard题，现在回想起来，那可能是自己独立实现AC的第一道Hard，这才有了后来渐渐想要不借助提示挑战Hard的勇气。虽说Frog Jump 是一道Hard，但是解题过程意外的轻松，很容易的就找到了算法方案，基本就是常规的思路，然后实现代码过程也没遇到很多问题，最后一次AC，倍感意外。彼时就有点反思道，是不是自己高估了Hard，所以被这个束缚，才一直觉得自己搞不定才没有去尝试。现在想来，可能只是因为经验不足，用于解题的算法工具不够充足才会有Hard无法突破的心理障碍，比如，Frog Jump , Jump Game 的多种变种以及这题Word Ladder 基本都跟算法（第四版）中的 确定有穷状态自动机DFA 和 不确定有穷状态自动机 NFA的解法一致，无论是最初AC，还是后来的Debug优化，基本都是围绕Pattern 构建的状态图流转即可。此题甚至都无需构建状态图，只需要寻找合适的数据结构来标记状态即可，多少跟图论算法比较相似。</p><h3 id="算法思路分析"><a href="#算法思路分析" class="headerlink" title="算法思路分析"></a>算法思路分析</h3><p>　　本质上，这其实是一道图论题目，在wordList提供的图之中，搜索从beginWord 到 endWord 的最短路径，最短路径可以直接用BFS求解，因为题设只需要输出最短路径的可能值即可，所以找到终点之后，程序即可中止。</p><p>　　算法上，还是延续之前的各种Jump的变种思路，难点应该还是在于实现上，毕竟这些变种题会有各种约束条件的变化导致代码上会有些许不同，这个恐怕要在写代码的时候才能意识得到。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>　　跟DFA/NFA类似，先把wordList转化成图表达，搜索所有的有连接关系的单词对，并保存起来。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 判断 字符串 s1 s2 是否有边连接</span><span class="token keyword">def</span> <span class="token function">isPair</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">:</span>    c <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span>j <span class="token keyword">in</span> zip<span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> c <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> i <span class="token operator">!=</span> j<span class="token punctuation">:</span>            c <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> c <span class="token operator">==</span> <span class="token number">1</span><span class="token comment" spellcheck="true"># word 在wordList 搜索所有可能的边</span><span class="token keyword">def</span> <span class="token function">constructidx</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word<span class="token punctuation">,</span> wordList<span class="token punctuation">,</span> des2src<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> w <span class="token keyword">in</span> wordList<span class="token punctuation">:</span>    <span class="token keyword">if</span> w <span class="token operator">!=</span> word <span class="token operator">and</span> self<span class="token punctuation">.</span>isPair<span class="token punctuation">(</span>w<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">:</span>        des2src<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>word<span class="token punctuation">)</span>        des2src<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>w<span class="token punctuation">)</span>    <span class="token keyword">return</span></code></pre><p>　　自己虽然知道在搜索连接边的isPair写的有点简单粗暴，有很大的优化空间，因为随着wordList的length增大，这个调用次数也是呈指数上升的，所以isPair的一点小优化能极大的降低TLE概率，事实也确实如此。无奈自己面对这样的基础优化，还是有点无能无力，似乎陷入了这个第一想法就得到结果的算法思路限制，无法彻底的想到新思路，最后在Discuss找到了这一段的简洁实现，利用wordList_set的在搜索阶段的改进很明显，除此之外以word为基础重新构建的方法会快一点，毕竟一个单词每一个位置都用26个字母重新替换一下，也需要$O(N)$的时间复杂度，综合起来$O(MN)$；而上述的代码可能需要$O(M^2)$， 其中M代表wordList 长度，N代表word本身的长度，这个角度来看，M较大的可能性还是比较高的。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">constructidx_1</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word<span class="token punctuation">,</span> wordList_set<span class="token punctuation">,</span> des2src<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> char <span class="token keyword">in</span> string<span class="token punctuation">.</span>ascii_lowercase<span class="token punctuation">:</span>            tmp <span class="token operator">=</span> word<span class="token punctuation">[</span> <span class="token punctuation">:</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> char <span class="token operator">+</span> word<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">]</span>            <span class="token keyword">if</span> tmp <span class="token keyword">in</span> wordList_set<span class="token punctuation">:</span>                des2src<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># des2src[tmp].add(word)</span>    <span class="token keyword">return</span></code></pre><p>　　也是这一段的优化最终将TLE的代码转化为AC的代码</p><p>　　接下来就是BFS搜索的过程了，自己在写这段代码的时候，不知道是不是脑子抽风了，又犯了还没想好整体构思，就提枪上阵的毛病，本来是一段很基础的BFS搜索的过程，结果由于访问状态标记的代码没想明白，就随意的放置访问状态的代码，结果调试了1天，才发现问题所在，期间出现了各种匪夷所思的访问状态变化的问题，搞得自己经常莫名其妙，各种怀疑是不是其他地方出了问题。实在是有点不应该。</p><p>　　可能是以前的BFS都需要遍历所有的节点之后，自动返回，所以直接采用queue的方式，queue为空自动返回即可，不需要标记BFS目前在第几层，然而此题是需要求最短路径，显然是需要采取层次遍历的方式依此进行，所以用q, q_next依此交替的方式，q是目前的遍历层次，q_next是接下来需要遍历的层次；其次，状态标记visited 的问题，此题由于要输出所有可能的最短路径，所以不仅进入q_next的新节点需要标记回溯路径，有可能q_next中的某个节点a，在此层被2个不同的节点b和c连接，此时需要把这2条路径需要标记回溯路径，之前这种可能性被自己忽略了，所以每当有多条的路径的时候，自己的代码只输出了一条，最后发现是遍历b和c的时候，b-a 使a 进入q_next, 并且visited[a] = True,标记b-a的回溯路径， 而当 c-a 需要标记回溯路径的时候，却由于visited[a]==True 被跳过了，所以才有那段不伦不类的if elif 的分支判断</p><pre class=" language-python"><code class="language-python">q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>endWord<span class="token punctuation">)</span>visited <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;endWord:True&amp;#125;</span>bp <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#res = defaultdict(list)</span><span class="token comment" spellcheck="true">#res[endWord] = [ [endWord] ]</span><span class="token keyword">while</span> len<span class="token punctuation">(</span>q<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">:</span>    q_next <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> e <span class="token keyword">in</span> q<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># self.constructidx(e, wordList_set, des2src)</span>        self<span class="token punctuation">.</span>constructidx_1<span class="token punctuation">(</span>e<span class="token punctuation">,</span> wordList_set<span class="token punctuation">,</span> des2src<span class="token punctuation">)</span>        <span class="token keyword">for</span> src <span class="token keyword">in</span> des2src<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> visited<span class="token punctuation">.</span>get<span class="token punctuation">(</span>src<span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span>  <span class="token punctuation">:</span>                visited<span class="token punctuation">[</span>src<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>                q_next<span class="token punctuation">.</span>append<span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#                r = [ [src] ]if len(res[e]) == 0 else [[src] + re for re in res[e]]</span><span class="token comment" spellcheck="true">#                res[src].extend(r)</span>                bp<span class="token punctuation">[</span>src<span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>e<span class="token punctuation">)</span>            <span class="token keyword">elif</span> src <span class="token keyword">in</span> q_next<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#                r = [ [src] ]if len(res[e]) == 0 else [[src] + re for re in res[e]]</span><span class="token comment" spellcheck="true">#                res[src].extend(r)</span>                bp<span class="token punctuation">[</span>src<span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>e<span class="token punctuation">)</span>    <span class="token keyword">if</span> beginWord <span class="token keyword">in</span> q_next<span class="token punctuation">:</span>        <span class="token keyword">break</span>    wordList_set <span class="token operator">=</span> wordList_set <span class="token operator">-</span> set<span class="token punctuation">(</span>bp<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    q <span class="token operator">=</span> q_next<span class="token comment" spellcheck="true"># return res[beginWord]</span>res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>self<span class="token punctuation">.</span>backPath<span class="token punctuation">(</span>beginWord<span class="token punctuation">,</span> endWord<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">,</span> bp<span class="token punctuation">)</span><span class="token keyword">return</span> res<span class="token comment" spellcheck="true"># 回溯还原最短路径</span><span class="token keyword">def</span> <span class="token function">backPath</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> start<span class="token punctuation">,</span>endWord<span class="token punctuation">,</span> r <span class="token punctuation">,</span>res<span class="token punctuation">,</span>bp<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> start <span class="token operator">==</span> endWord<span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>r<span class="token operator">+</span><span class="token punctuation">[</span>endWord<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token keyword">for</span> st <span class="token keyword">in</span> bp<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>backPath<span class="token punctuation">(</span>st<span class="token punctuation">,</span> endWord<span class="token punctuation">,</span> r<span class="token operator">+</span><span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">,</span> bp<span class="token punctuation">)</span>        <span class="token keyword">return</span></code></pre><p>上述注释的代码，是除了回溯之外，另一种BFS中，直接保存结果的方法，当初以为是TLE的主因，最后证明其实不是，所以也是一种输出结果的方法，原理是用字典res，保存所有以word开头的可能的路径列表。</p><h3 id="BFS优化"><a href="#BFS优化" class="headerlink" title="BFS优化"></a>BFS优化</h3><p>　　Discuss Python高赞解法大体BFS跟我的一致，但是我前面也分析过，我这个奇怪的if/elif分支其实还是有很大的优化空间，再则自己的状态划分不佳其实也是导致这么奇怪分支的一个原因，所以高赞的解法直接把这二者完美的统一了，窃以为也是一个简洁优雅的解法，值得学习。这里res 跟我上述的res相反，是保存以word结尾的路径列表的字典</p><pre class=" language-python"><code class="language-python">q <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>list<span class="token punctuation">)</span>q<span class="token punctuation">[</span>beginWord<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>beginWord<span class="token punctuation">]</span><span class="token punctuation">]</span>wordList_set <span class="token operator">=</span> set<span class="token punctuation">(</span>wordList<span class="token punctuation">)</span>res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">while</span> len<span class="token punctuation">(</span>q<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>  q_next <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>list<span class="token punctuation">)</span>  <span class="token keyword">for</span> word <span class="token keyword">in</span> q<span class="token punctuation">:</span>    <span class="token keyword">if</span> word <span class="token operator">==</span> endWord<span class="token punctuation">:</span>      res<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>k <span class="token keyword">for</span> k <span class="token keyword">in</span> q<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">for</span> char <span class="token keyword">in</span> string<span class="token punctuation">.</span>ascii_lowercase<span class="token punctuation">:</span>        tmp <span class="token operator">=</span> word<span class="token punctuation">[</span> <span class="token punctuation">:</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> char <span class="token operator">+</span> word<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 未访问状态的列表中搜索拼接的可能的值，逐渐减少搜索空间，也是一种很好的优化方法，即逻辑上实现了 visited 状态验证，同时一层一更新减少了搜索空间，用set实现极大的优化了搜索时间</span>        <span class="token keyword">if</span> tmp <span class="token keyword">in</span> wordList_set<span class="token punctuation">:</span>                    q_next<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token punctuation">[</span>tmp<span class="token punctuation">]</span> <span class="token keyword">for</span> r <span class="token keyword">in</span> q<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># wordList_set 实际上是保存了所有未访问状态的列表，BFS的时候每一层更新一次，避免奇怪的if/elif 分支判断，是更准确的状态划分方法</span>    wordList_set <span class="token operator">=</span> wordList_set <span class="token operator">-</span> set<span class="token punctuation">(</span>q_next<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  q <span class="token operator">=</span> q_next<span class="token keyword">return</span> res</code></pre><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>　　算法优化阶段的时间复杂度分析做的不是很到位，其实似乎还是懒居多，细想一下，M和N之间的对比，似乎也能找到一点蛛丝马迹；其次，BFS状态划分没有因地制宜，还是想以套路直接鲁莽上阵，其实在发现应该按照层次BFS的时候，此题应该已经解决了，解析之后的后续优化工作还是需要多积累一些套路经验，特别是Python本来就比较慢的基础上，时间复杂度分析的重要性可能会越来越大。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 115. Distinct Subsequences</title>
      <link href="algorithms/leetcode-115-distinct-subsequences/"/>
      <url>algorithms/leetcode-115-distinct-subsequences/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Given two strings <code>s</code> and <code>t</code>, return <em>the number of distinct subsequences of <code>s</code> which equals <code>t</code></em>.</p><p>A string’s <strong>subsequence</strong> is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).</p><p>It’s guaranteed the answer fits on a 32-bit signed integer.</p><p><strong>Example 1:</strong></p><pre><code>Input: s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;Output: 3Explanation:As shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.rabbbitrabbbitrabbbit</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: s = &quot;babgbag&quot;, t = &quot;bag&quot;Output: 5Explanation:As shown below, there are 5 ways you can generate &quot;bag&quot; from S.babgbagbabgbagbabgbagbabgbagbabgbag</code></pre><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= s.length, t.length &lt;= 1000</code></li><li><code>s</code> and <code>t</code> consist of English letters.</li></ul></blockquote><p>　　或许是由于之前做过这个题目的原因，所以面对这道Hard题目，心态比较冷静；再加上100题前后的几乎都是二叉树类别的题目，自己面对链表和树类别的题目基本没碰到困难，所以DFS用的手软，到这里有点停不下来的感觉。所以此时第一想法就想到用DFS，虽然预感对于字符串匹配类别的题目，DFS肯定会出现性能问题，但是作为验证算法思想的先导思路，还是打算先实现出来再看，毕竟用DFS写代码，代码真的很短，AC的时候更是有种 吊炸天的 爽快感；结果还是差一点AC；其次，可能是之前做过的原因，虽然第一时间没写出dp递推公式，但是写出了递推矩阵，演算了一番，没想到居然是对的，很容易的转换成了算法代码，结果干净利落的AC了，甚至比之前的AC的时候还要快一倍以上。虽然这不是自己第一次独立解决Hard题目，但是这题没有借鉴之前的代码，而且从构思算法道实践成功基本没遇到什么障碍，还是值得自己兴奋一阵子了。</p><h3 id="解法一：DFS"><a href="#解法一：DFS" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h3><p>　　此题如果要用递归的方法，那么就可以从最简单的字符串匹配入手，就是s和t都是单字符，直接就可以快速返回结果，这就可以精简成3种情况：</p><ol><li>s == ‘’ 即待匹配的模式t还没有消耗完，就直接没有s可供匹配了，返回0</li><li>t == ‘’ 即待匹配的模式t消耗完，返回1</li><li>s==t 直接返回1</li><li>递归处理</li></ol><p>　　接下来，就开始要做递推式的处理，t的首字符t[0]如果在s中，那么就可以进行递归处理，考虑到s中可能有多个t[0]相同的字符，就要对s和t做不同的切分处理来交给递归处理，最后把所有返回的结果sum一下，就可以了</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># DFS</span>    <span class="token keyword">def</span> <span class="token function">numDistinct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> s <span class="token operator">==</span> t<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        r <span class="token operator">=</span> <span class="token number">0</span>        t0 <span class="token operator">=</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        pos <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        news <span class="token operator">=</span> s<span class="token punctuation">[</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">]</span>        <span class="token keyword">while</span> t0 <span class="token keyword">in</span> news<span class="token punctuation">:</span>            pos <span class="token operator">=</span> news<span class="token punctuation">.</span>index<span class="token punctuation">(</span>t0<span class="token punctuation">)</span>            news <span class="token operator">=</span> news<span class="token punctuation">[</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">]</span>            r <span class="token operator">+=</span> self<span class="token punctuation">.</span>numDistinct<span class="token punctuation">(</span>news<span class="token punctuation">,</span> t<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> r</code></pre><p>测试用例通过率：106/116， 离AC只有一步之遥，目测发现是超长的字符串s导致递归性能急剧下降，那么可以确定的是算法思路是没有问题的。接着开始转入DP的算法构思。</p><h3 id="解法二：-动态规划-Dynamic-Programming-DP"><a href="#解法二：-动态规划-Dynamic-Programming-DP" class="headerlink" title="解法二： 动态规划 Dynamic Programming (DP)"></a>解法二： 动态规划 Dynamic Programming (DP)</h3><p>　　由于之前做过这个题，所以非常确定有一个DP算法存在，但是对于这个DP是怎么构建最优子结构的，完全想不起来了。所以，接下来就完全需要自己朝着DP思路构思DP矩阵了。</p><p>　　字符串匹配的DP算法有一个非常有名的最长公共子序列(LCS)问题，几乎所有讲解DP的教材都拿这个题目做过示例分析，当时自己对这个递推式还是很不理解，为什么$dp[i][j]$在$s[i]!=t[j]$的时候，可以由$dp[i-1][j]$和$dp[i][j-1]$构成？当初还是理解了好久，才想明白。或许是当初对这个分解的情况思索的很久的原因，所以但凡遇到DP算法的，都会潜意识的往LCS靠；而此题恰好也是字符串匹配的题目，思路方向似乎没什么太大问题。</p><table><thead><tr><th align="center"></th><th align="center">r</th><th align="center">a</th><th align="center">b</th><th align="center">b</th><th align="center">b</th><th align="center">i</th><th align="center">t</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">a</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">b</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">b</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">i</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">3</td><td align="center">0</td></tr><tr><td align="center">t</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">3</td></tr></tbody></table><p>对$dp[i][j]$的定义开始还是不太明确，最初以为是本层i和上层i-1的累加，最后发现不对，最后从意义上的分析，最终确定是来自上一层之前所有可能性的累加，因为$dp[i-1][ :j]$中累加表示上层匹配结束之后，所有可供下层提供入口的数量，而且这个入口只有在$s[i]==t[j]$的时候，才有效，否则直接置为0，最后的返回的结果应该是$sum(dp[-1])$。</p><p>最关键的步骤就是正确性验证，在提供的2个测试用例都无误之后，基本就可以开始步入写代码的过程了.</p><table><thead><tr><th align="center"></th><th align="center">b</th><th align="center">a</th><th align="center">b</th><th align="center">g</th><th align="center">b</th><th align="center">a</th><th align="center">g</th></tr></thead><tbody><tr><td align="center">b</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">a</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">3</td><td align="center">0</td></tr><tr><td align="center">g</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">4</td></tr></tbody></table><p>由于只需要上层的数据就可以计算本层， 但是并不是完全copy上层的数据，所以没办法用dp常用的边更新数据边覆盖的方式复用同一个List， 所以这里采用了2个List交替使用的方式来逐层更新</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># dp</span>    <span class="token keyword">def</span> <span class="token function">numDistinct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">:</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span>char <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> char <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> char <span class="token keyword">in</span> t<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">]</span><span class="token punctuation">:</span>            count <span class="token operator">=</span> <span class="token number">0</span>            dp_next <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> char<span class="token punctuation">:</span>                    dp_next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> count                count <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            dp <span class="token operator">=</span> dp_next        <span class="token keyword">return</span> sum<span class="token punctuation">(</span>dp<span class="token punctuation">)</span></code></pre><p>36ms AC， 比之前AC的DP还快上一倍，这是最初没想到的。</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>　　这次顺利AC的主要原因还是思路方向的偶然正确性，这跟学生时代做数学题似乎有着异曲同工的地方，就是尝试的手段恰好是对的。如果尝试的手段恰好不对呢？无论是实践还是算法，我领悟到的结论是，多思考问题和事物的本质，才是快速接近正确答案有效的方式。上面的过程也可以发现，在有了正确的递归矩阵的引导下，代码的实现其实很轻松；反倒是，没抓住问题本质的随意和胡乱的尝试，才是导致心态急躁的根源，因为这种胡乱的尝试，似乎给了一种正在接近解决问题的错觉，虽然积累一点关于问题的经验，但是很多时候似乎只是积累无意义的失败经验而已；在适当的失败经验的基础上，更多的思考原因，在发现问题和原因的基础上的尝试，才是有价值和意义的，也才是最有效率的方式。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1-100 刷题有感</title>
      <link href="sui-bi/leetcode-1-100-shua-ti-you-gan/"/>
      <url>sui-bi/leetcode-1-100-shua-ti-you-gan/</url>
      
        <content type="html"><![CDATA[<p>　　跌跌撞撞终于在前几天完成的LeetCode 100题，刷题过程印证了之前对自我的一个论断，起了个大早，干了个晚集。 早在2012年，自己就开始了解到LeetCode 刷完前100题的神迹，这时LeetCode应该还没创立多久吧！当时国内只有北大的POJ可用，那曲高和寡的界面和难度，着实有点劝退！自己的编程学习之路从来没有一个类似引路人之类的角色，全凭自学，再加上我三分钟热度的神奇特性，所以对ACM之类的算法竞赛全然不知也就毫无意外。彼时，复现数据结构的排序等级实践水平就足以让自己沾沾自喜半天了，毕竟身边有大把无法做到这一点的人，而且还是靠背代码的方式，二叉树倒是无论是理论学习阶段还是代码实现阶段都没有遇到过太大的挑战，图论则是看算法（第四版）就收获了巨大的理论学习上的满足感，听信了据说实践基本不会出现这种级别的题目的话，就止步于此，毕竟图的数据结构确实有点繁琐，代码复杂度也有点棘手，但是在已经完全理解算法理论的基础上，实现起来也至多花一点时间而已。再加上当时眼界受限，以为排序，搜索以及图论之类就已经是算法的全部了。现在的我才真正意识到，理解算法理论和实现算法代码，在学习上是截然不同的2种境界，所幸自己就算没有在电脑上实现代码，也还是保持了记笔记的好习惯，很多自己觉得精妙和优雅的算法，忍不住在笔记本下写下来了，也算是另一种维度的代码实践吧！</p><p>　　回到了LeetCode上来，2012年记得是硕士复试需要准备OJ，当时觉得还是颇为新奇，所以比较重视，刷了很多OJ题目，其中就有LeetCode，不过当时光理解题目意思都有点费劲，刷了不到10题的Easy难度的题目就劝退了；复试结束之后，习惯性的放弃了，直到看完算法（第四版），重新理解了Java之后，忍不住想要做点什么，就又开始重新开始刷LeetCode，用Java 勉强刷了几十道medium和easy的题目，虽然大部分都还是做不出来，不清楚常规解题套路，Hard题目一想就是一整天都没什么头绪，最后还是看Discuss才能找到一点感觉，甚至很多时候光理解代码就需要大半天时间。由于LeetCode OJ系统的易用性，免去了调试环境的很多烦恼，能专注于算法编码和Debug，其次社区讨论都非常活跃，遇到不会做的题目或者是思路受阻，基本都能在Discuss下面找到解答，当时虽然抱着模仿性质的想法，试图想要刷完LeetCode 100题，但是止步于好几个Hard题目，记得有一道计算城市天际线面积的题目，整整想了一周，总是感觉算法上，似乎已经找到解决算法，但是编码时候总是磕磕碰碰，自己的想法还没到验证的阶段，就被茫茫然的细节问题给淹没了。最后不得不求助社区，最后理解完正确的代码之后，就这么弃置不顾。完全放弃了在LeetCode中寻找乐趣的想法了。</p><p>　　以现在的角度回顾分析之前为什么放弃 LeetCode 刷题，或许会有不错的收获！首先，也是老生常谈的问题，就是自己三分钟热度的问题，也不过多展开了，直接给出结论就是，中立的来看，自己既然有这样不算好也不算坏的特质，别像以前那样，说到三分钟热度，大部分时候都是带着点贬义和自我批判意味。再说，三分钟热度起码给了自己一种不断变换角度来看周遭和自己的机会，抱有对世界最单纯的好奇心。缺点自然也很明显，也就是浅尝辄止。最后的一句话点醒了梦中人，<strong>有三分钟热度，就有三分钟收获</strong>。其次，就是自己刷题时候的无知者无畏的盲目自信，想要试图跳级做题，而不是惯常的循序渐进，徒增难度，却发现自己完全没有做好准备，浪费了很多时间，还严重打击了自信，于是便开始自暴自弃，顺带连之前积累的理论知识都被荒废了。这可能是学生思维的弊端，不够谦卑，更不够自信，这其中的度，没有拿捏得当。诚然，数据结构和算法的理论支撑下，很多算法题都会变的比较容易用常规的套路解答，特别是很多算法笔试和考试中，都已经把最难点给精确的给出来了，照本宣科就可以了。那么，这是否意味着解决了核心难点之后，其他方面是否不值一提呢？真实情况并不是这样的，很多时候并没有意识到这个难点为什么是难点，只是被动的接受知识而已，这理所当然的导致另一个重要的能力的缺失，学会如何灵活的运用这些算法理论，也就是融会贯通。只有当无论什么算法题目，都能很准确的分析出问题本质，根据分析结果找到相应的数据结构工具和手段解决问题，才能完成编码的核心，就是算法伪代码的初步构思；但是是否真的能在OJ中AC，只有代码才能验证。这跟数学证明题一样，在证明过程顺利铺开之前，一切构思都只是可能的解决方案而已，能不能达到预想的目的，还需要证明过程来验证，况且，这个构思可能会被证明过程自我否定掉。这些内容总结起来，其实就是<strong>执行力</strong>。回顾自己大部分的学生时代，遗憾的发现，自己执行力可能是属于非常拉胯的级别。也就勉强仗着的天赋好，和某些时候的灵光乍现以及为数不多的树立并确信要去达成的目标的时候，才能走到现在。近年来，终于能心平气和的分析自己的优缺点的时候，才意识到，循序渐进的构思-行动，小步快走的达成目标的重要性和难能可贵。这一点可能是当初年轻气盛的时候不具备的。再则，其实也是上一个原因派生出来的问题，就是Java本身的标准库和数据结构的不熟悉，谁能想到，自学了Java这么久，居然还是懒得看Java的标准文档，尽管算法（第四版）实现了简化版的，堆栈，队列，二叉树等数据结构，文件I/O也大幅简化，增强了易用性，也让自己缺乏去看繁杂的Java标准实现的动力，所以很多时候都是现学现用，这当然无可厚非，因为熟记这些库是没有必要的，只需要知道是堆栈等这些数据结构的接口就可以了，用的时候再去查就行了，无非就是低效一点，并不至于无法实现的地步，但是结果就是不用就不学，导致直到现在对Java的标准库还是一知半解，前段时间打包个Jar还老费劲了。这样做的当时可能觉得没啥，但是一旦实践起来，就很容易出现问题，在做LeetCode OJ的时候，就集中爆发出来了，就是自己是算法构思，迟迟没办法得到代码验证，常常会卡在Java的实现细节上，当时也没有对构思和实践分的这么开，觉得有个构思好像能解决问题，就硬着头强上，以至于最后败兴而归都没能整明白，究竟是算法构思的问题，还是代码实现的问题；以至于虽然刷了很久的题目，收获不大，反倒是积累了很多Java的问题没有解决。以上的一些做的不够好的地方，基本解释了当初为什么没能坚持刷LeetCode ？ </p><p>　　还有一个重要的需要解释的问题就是，为什么刷过的LeetCode 过段时间回头来看，仍然解不出来或者是一知半解？譬如说，现在回去做城市天际线的题目，自己似乎没有自信能100%解出来。主要原因应该是自己并没有规划性的做复习工作，很多算法题做完，并没有留下一个可供复习的笔记和资料为后续复习做准备，也就是在之前Blog做反思的过程中提到的，没有系统行的整理和复习自己的学习笔记和资料，导致每次复习的时候，都不得不重头开始做题，把之前踩过的坑又重新踩了一遍，这在几年后，也就是最近几年开始用Python重做这些题的时候都渐渐体现出来了，这其实完全没有必要，因为发生这样的事情主要原因仅仅只是遗忘了而已，思维过程其实还是在没有复习的情况仍然保有印象。所以，定期的记录刷题方法并整理和复习在这个阶段就变的很重要了，这也是自己强调过很多次的问题了，也是努力在改进，就不多细说了。</p><p>　　用Python重刷题的时候，就显得有效率了很多，一来很多题目都比较熟悉了，只需要用Python相对应的数据结构重新实现即可，这个过程其实也加深了很多经常用的数据结构的理解，不常用的类和编程模式也熟悉了不少，也算是一个不错的收获吧，毕竟曾经对实践编码的忽视缺失导致自己眼高手低，失去了很多提升编码能力的机会，编码之后，才真实的认识到编程原本就是一项工程实践，自己怎么会天真到仅仅满足于算法构思，而不是脚踏实地的实现出来；再则，其实也算是一种复习，对之前理解不深刻，一知半解的方法做一个完整的梳理。 这也解释为什么，上周某天下午半天不到的时间，就把最后20题，一次性全部刷完，高效的自己都觉得不可思议。其中甚至包含2道Hard，自己原以为需要借助一些提示才做的出来的题目，也比较顺利的完成了。 刷完100题的时候，感觉真的很兴奋，曾经以为很厉害，遥不可及的神迹，现在自己也站在这里达成了这个目标，虽然耗时比较久，过程断断续续，其实过程基本是大部分时间没怎么刷，突然心血来潮就刷很多题那样，也算是达成一个不大不小的成就吧！</p><p>　　接下来该怎么做呢？ 这也是最最重要和需要关注的问题，毕竟尽管自己可以一下午刷几十道题，停不下来，但是我还是会开个小差，摸鱼一整天，更是停不下来的那种。我已经渐渐摸索出应对这种情况的解决办法，就是合理的做规划，给出目标，不多不少，不偏不倚。因为从刷题过程来看，我还是非常享受刷题带来的乐趣的，特别是那些觉得有点困难的题目，AC的时候，可以开心好一阵子了，以至于都忘记要整理自己的代码和笔记了。设想中的刷完100题之后，应该是需要整理一下100题的笔记和要点，作为刷题总结的方式，一篇一篇的成为Blog的主要内容来源，现在看来，似乎这项工作并没有开展起来，因为很多注释都写在代码里面了，现在回过头来一个一个的去复习和整理，觉得有点没必要，似乎只需要关注最主要和核心的题目整理出笔记即可，更主要的原因可能是担心这项工作可能会延误自己刷100-200题的进度，毕竟比起回头复习旧题目，我似乎更喜欢做新题。现在回想一下，其实很多代码注释的内容，都足以作为Blog的文字内容存在了，只需要稍加排版即可成为一份笔记，所以对于刷题的笔记模版，应该无需过于担忧。更值得关注的应该是要求自己刷100之后的新题的时候，务必要求自己必须整理出一份代码说明出来，定期排版成Blog，将定期刷题变成一个习惯，这样就有精力去迎接下一个挑战了，毕竟对自己来说是一件很开心的事情。</p><p>　　LeetCode 刷完100题有感就这么多，接下来还是希望自己能贯彻自己的日常目标，现阶段坚持刷题和背单词，再坚持锻炼身体，不要避重就轻的断断续续的逃避，相信有了这几项准备和积累，面对以后的工作和生活的挑战，自己能应对的更加自如，处理的更加高效！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPU in Pytorch  并行和分布式实践</title>
      <link href="pytorch/gpu-in-pytorch-bing-xing-he-fen-bu-shi-shi-jian/"/>
      <url>pytorch/gpu-in-pytorch-bing-xing-he-fen-bu-shi-shi-jian/</url>
      
        <content type="html"><![CDATA[<p>　　虽然还没有机会用到CUDA集群，但是前段时间对协程和并行化的研究，让我忍不住想要探索一下如何在多个GPU下利用Pytorch加快训练的实践方法，算是为之后并行训练优化一个理论参考吧！</p><p>　　Pytorch 大体上有3种实现并行的接口（另外还有一种不利用接口的拼接模型的技巧，之后再单独讨论），分别是：torch.multiprocessing, nn.DataParallel, nn.parallel.DistributedDataParallel，如果是是GPU多卡运行，最佳实践是 nn.parallle.DistributedDataParallel,官方文档 <a href="https://pytorch.org/docs/stable/notes/cuda.html#cuda-nn-ddp-instead">CUDA SEMANTIC</a> 是这么描述的：</p><blockquote><p><strong>Use nn.parallel.DistributedDataParallel instead of multiprocessing or nn.DataParallel</strong></p><p>Most use cases involving batched inputs and multiple GPUs should default to using <a href="https://pytorch.org/docs/stable/generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel"><code>DistributedDataParallel</code></a> to utilize more than one GPU.</p><p>There are significant caveats to using CUDA models with <a href="https://pytorch.org/docs/stable/multiprocessing.html#module-torch.multiprocessing"><code>multiprocessing</code></a>; unless care is taken to meet the data handling requirements exactly, it is likely that your program will have incorrect or undefined behavior.</p><p>It is recommended to use <a href="https://pytorch.org/docs/stable/generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel"><code>DistributedDataParallel</code></a>, instead of <a href="https://pytorch.org/docs/stable/generated/torch.nn.DataParallel.html#torch.nn.DataParallel"><code>DataParallel</code></a> to do multi-GPU training, even if there is only a single node.</p><p>The difference between <a href="https://pytorch.org/docs/stable/generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel"><code>DistributedDataParallel</code></a> and <a href="https://pytorch.org/docs/stable/generated/torch.nn.DataParallel.html#torch.nn.DataParallel"><code>DataParallel</code></a> is: <a href="https://pytorch.org/docs/stable/generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel"><code>DistributedDataParallel</code></a> uses multiprocessing where a process is created for each GPU, while <a href="https://pytorch.org/docs/stable/generated/torch.nn.DataParallel.html#torch.nn.DataParallel"><code>DataParallel</code></a> uses multithreading. By using multiprocessing, each GPU has its dedicated process, this avoids the performance overhead caused by GIL of Python interpreter.</p><p>If you use <a href="https://pytorch.org/docs/stable/generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel"><code>DistributedDataParallel</code></a>, you could use torch.distributed.launch utility to launch your program, see <a href="https://pytorch.org/docs/stable/distributed.html#distributed-launch">Third-party backends</a>.</p></blockquote><h3 id="torch-multiprocessing"><a href="#torch-multiprocessing" class="headerlink" title="torch.multiprocessing"></a>torch.multiprocessing</h3><p>　　torch.multiprocessing 是 Python下 multiprocessing 的替代品，接口基本一致，并根据情况进行扩张，建议使用 python: multiprocessing.Queue 在进程中传递Pytorch对象。除此之外，还有很多坑，详见官方笔记 <a href="https://pytorch.org/docs/stable/notes/multiprocessing.html">MULTIPROCESSING BEST PRACTICES</a>, <a href="https://pytorch.apachecn.org/docs/1.4/64.html">并行处理最佳实践</a></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token punctuation">.</span>multiprocessing <span class="token keyword">as</span> mp<span class="token keyword">from</span> model <span class="token keyword">import</span> MyModel<span class="token keyword">def</span> <span class="token function">train</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># Construct data_loader, optimizer, etc.</span>    <span class="token keyword">for</span> data<span class="token punctuation">,</span> labels <span class="token keyword">in</span> data_loader<span class="token punctuation">:</span>        optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        loss_fn<span class="token punctuation">(</span>model<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># This will update the shared parameters</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    num_processes <span class="token operator">=</span> <span class="token number">4</span>    model <span class="token operator">=</span> MyModel<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># NOTE: this is required for the ``fork`` method to work</span>    model<span class="token punctuation">.</span>share_memory<span class="token punctuation">(</span><span class="token punctuation">)</span>    processes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> rank <span class="token keyword">in</span> range<span class="token punctuation">(</span>num_processes<span class="token punctuation">)</span><span class="token punctuation">:</span>        p <span class="token operator">=</span> mp<span class="token punctuation">.</span>Process<span class="token punctuation">(</span>target<span class="token operator">=</span>train<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>        processes<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">)</span>    <span class="token keyword">for</span> p <span class="token keyword">in</span> processes<span class="token punctuation">:</span>        p<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="DataParallel"><a href="#DataParallel" class="headerlink" title="DataParallel"></a>DataParallel</h3><p>　　DataParallel原理是，把model 副本copy到所有GPU上，其中每个GPU消耗数据的不同分区，相当于SIMD，把数据条目根据GPU数量重新分配</p><h4 id="单机DataParallel并行"><a href="#单机DataParallel并行" class="headerlink" title="单机DataParallel并行"></a>单机DataParallel并行</h4><pre class=" language-python"><code class="language-python">model <span class="token operator">=</span> nn<span class="token punctuation">.</span>DataParallel<span class="token punctuation">(</span>model<span class="token punctuation">)</span></code></pre><p>　　代码验证 outside model 数据维度  和 inside model 维度</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Model</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># Our model</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> input_size<span class="token punctuation">,</span> output_size<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>Model<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>input_size<span class="token punctuation">,</span> output_size<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> input<span class="token punctuation">)</span><span class="token punctuation">:</span>        output <span class="token operator">=</span> self<span class="token punctuation">.</span>fc<span class="token punctuation">(</span>input<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\tIn Model: input size"</span><span class="token punctuation">,</span> input<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>              <span class="token string">"output size"</span><span class="token punctuation">,</span> output<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> outputmodel <span class="token operator">=</span> Model<span class="token punctuation">(</span>input_size<span class="token punctuation">,</span> output_size<span class="token punctuation">)</span><span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>device_count<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Let's use"</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>device_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"GPUs!"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># dim = 0 [30, xxx] -> [10, ...], [10, ...], [10, ...] on 3 GPUs</span>  model <span class="token operator">=</span> nn<span class="token punctuation">.</span>DataParallel<span class="token punctuation">(</span>model<span class="token punctuation">)</span>model<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token keyword">for</span> data <span class="token keyword">in</span> rand_loader<span class="token punctuation">:</span>    input <span class="token operator">=</span> data<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>    output <span class="token operator">=</span> model<span class="token punctuation">(</span>input<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Outside: input size"</span><span class="token punctuation">,</span> input<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token string">"output_size"</span><span class="token punctuation">,</span> output<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 2 GPUs</span><span class="token comment" spellcheck="true"># on 2 GPUs</span>Let's use <span class="token number">2</span> GPUs!    In Model<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    In Model<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Outside<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output_size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    In Model<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    In Model<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Outside<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output_size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    In Model<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    In Model<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Outside<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output_size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    In Model<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    In Model<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Outside<span class="token punctuation">:</span> input size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> output_size torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>优点是，通过消耗输入数据不同分区的方式加快训练过程，缺点是，如果单个模型太大，无法放入单个GPU，就无法运行，这时有个Trick可以把模型分段载入不同GPU，利用拼接的方式完成并行训练，该模型将单个模型拆分到不同的 GPU 上，而不是在每个 GPU 上复制整个模型(具体来说， 假设模型<code>m</code>包含 10 层：使用<code>DataParallel</code>时，每个 GPU 都具有这 10 层中每个层的副本，而当在两个 GPU 上并行使用模型时，每个 GPU 可以承载 5 层）</p><h4 id="单机模型拼接并行"><a href="#单机模型拼接并行" class="headerlink" title="单机模型拼接并行"></a>单机模型拼接并行</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">import</span> torch<span class="token punctuation">.</span>optim <span class="token keyword">as</span> optim<span class="token keyword">class</span> <span class="token class-name">ToyModel</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>ToyModel<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>net1 <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">'cuda:0'</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>relu <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>net2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">'cuda:1'</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>net1<span class="token punctuation">(</span>x<span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">'cuda:0'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>net2<span class="token punctuation">(</span>x<span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">'cuda:1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>对于模型太大而无法放入单个 GPU 的情况，上述实现解决了该问题。 但是，分析原理的时候可能已经注意到，如果模型单个GPU可以载入，它将比在单个 GPU 上运行它要慢。 这是因为在任何时间点，两个 GPU 中只有一个在工作，而另一个在那儿什么也没做。 由于中间输出需要在<code>layer2</code>和<code>layer3</code>之间从<code>cuda:0</code>复制到<code>cuda:1</code>，因此性能进一步恶化。</p><p>除此之外，还有通过异步方式构建流水线的手段加速，这个Trick比较精巧和优雅，思想可以学习一下</p><h4 id="单机Pipeline-并行"><a href="#单机Pipeline-并行" class="headerlink" title="单机Pipeline 并行"></a>单机Pipeline 并行</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">PipelineParallelResNet50</span><span class="token punctuation">(</span>ModelParallelResNet50<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> split_size<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>PipelineParallelResNet50<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>split_size <span class="token operator">=</span> split_size    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        splits <span class="token operator">=</span> iter<span class="token punctuation">(</span>x<span class="token punctuation">.</span>split<span class="token punctuation">(</span>self<span class="token punctuation">.</span>split_size<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        s_next <span class="token operator">=</span> next<span class="token punctuation">(</span>splits<span class="token punctuation">)</span>        s_prev <span class="token operator">=</span> self<span class="token punctuation">.</span>seq1<span class="token punctuation">(</span>s_next<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">'cuda:1'</span><span class="token punctuation">)</span>        ret <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> s_next <span class="token keyword">in</span> splits<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># A. s_prev runs on cuda:1</span>            s_prev <span class="token operator">=</span> self<span class="token punctuation">.</span>seq2<span class="token punctuation">(</span>s_prev<span class="token punctuation">)</span>            ret<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc<span class="token punctuation">(</span>s_prev<span class="token punctuation">.</span>view<span class="token punctuation">(</span>s_prev<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># B. s_next runs on cuda:0, which can run concurrently with A</span>            s_prev <span class="token operator">=</span> self<span class="token punctuation">.</span>seq1<span class="token punctuation">(</span>s_next<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">'cuda:1'</span><span class="token punctuation">)</span>        s_prev <span class="token operator">=</span> self<span class="token punctuation">.</span>seq2<span class="token punctuation">(</span>s_prev<span class="token punctuation">)</span>        ret<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc<span class="token punctuation">(</span>s_prev<span class="token punctuation">.</span>view<span class="token punctuation">(</span>s_prev<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span>ret<span class="token punctuation">)</span>setup <span class="token operator">=</span> <span class="token string">"model = PipelineParallelResNet50()"</span>pp_run_times <span class="token operator">=</span> timeit<span class="token punctuation">.</span>repeat<span class="token punctuation">(</span>    stmt<span class="token punctuation">,</span> setup<span class="token punctuation">,</span> number<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> repeat<span class="token operator">=</span>num_repeat<span class="token punctuation">,</span> globals<span class="token operator">=</span>globals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>pp_mean<span class="token punctuation">,</span> pp_std <span class="token operator">=</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>pp_run_times<span class="token punctuation">)</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>std<span class="token punctuation">(</span>pp_run_times<span class="token punctuation">)</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span>mp_mean<span class="token punctuation">,</span> rn_mean<span class="token punctuation">,</span> pp_mean<span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token punctuation">[</span>mp_std<span class="token punctuation">,</span> rn_std<span class="token punctuation">,</span> pp_std<span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token punctuation">[</span><span class="token string">'Model Parallel'</span><span class="token punctuation">,</span> <span class="token string">'Single GPU'</span><span class="token punctuation">,</span> <span class="token string">'Pipelining Model Parallel'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token string">'mp_vs_rn_vs_pp.png'</span><span class="token punctuation">)</span></code></pre><p>在2 GPUs上能有50%的提速，离100%还是有点差距，加速对比如下</p><p>###<img src="1.png" alt="1"> </p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>依次是 2-GPU并行， 1-GPU运行， 2-GPU Pipelining 并行 的运行时间对比</p><h3 id="nn-parallel-DistributedDataParallel"><a href="#nn-parallel-DistributedDataParallel" class="headerlink" title="nn.parallel.DistributedDataParallel"></a>nn.parallel.DistributedDataParallel</h3><p>　　基于torch.distributed 的分布式数据并行，原理和DataParallel类似，但是是跨机器和跨设备级别的数据并行，在每台机器和每台设备上复制，并且每个这样的副本处理一部分输入， 在向后传递过程中，将平均每个节点的梯度，总之，是按批处理维度分块指定设备之间的输入来并行化给定模块的应用程序。</p><p><code>DistributedDataParallel</code>可以通过以下两种方式使用：</p><h4 id="单线程多GPU"><a href="#单线程多GPU" class="headerlink" title="单线程多GPU"></a>单线程多GPU</h4><pre class=" language-python"><code class="language-python">torch<span class="token punctuation">.</span>distributed<span class="token punctuation">.</span>init_process_group<span class="token punctuation">(</span>backend<span class="token operator">=</span><span class="token string">"nccl"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># device_ids will include all GPU devices by default</span>model <span class="token operator">=</span> DistributedDataParallel<span class="token punctuation">(</span>model<span class="token punctuation">)</span> </code></pre><h4 id="多线程多GPU"><a href="#多线程多GPU" class="headerlink" title="多线程多GPU"></a>多线程多GPU</h4><p>　　强烈推荐的使用方式，在单机多GPU的情况下，单进程很容易由于GIL出现利用率不足的问题，这时候多进程就是唯一解决办法。最佳实践是，将DDP(DistributedDataParallel)配合多进程一起使用，每个GPU分配一个进程，会比torch.nn.DataParallel快得多，也是目前Pytorch最快的训练方法。</p><p>使用步骤：</p><ol><li>在N个GPU的单机上生成N个进程，这个过程可以交给torch.distributed.launch完成</li></ol><pre class=" language-bash"><code class="language-bash">python -m torch.distributed.launch --nproc_per_node<span class="token operator">=</span>n distributed_data_parallel.py</code></pre><ol start="2"><li>在代码中绑定GPU 编号，同时并行化model</li></ol><pre class=" language-python"><code class="language-python">parser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># FOR DISTRIBUTED:  Parse for the local_rank argument, which will be supplied</span><span class="token comment" spellcheck="true"># automatically by torch.distributed.launch.</span>parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">"--local_rank"</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> type<span class="token operator">=</span>int<span class="token punctuation">)</span>args <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 进程内绑定 GPU rank id</span>torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>set_device<span class="token punctuation">(</span>args<span class="token punctuation">.</span>local_rank<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 构造model</span>torch<span class="token punctuation">.</span>distributed<span class="token punctuation">.</span>init_process_group<span class="token punctuation">(</span>backend<span class="token operator">=</span><span class="token string">'nccl'</span><span class="token punctuation">,</span> world_size<span class="token operator">=</span>n<span class="token punctuation">,</span> init_method<span class="token operator">=</span><span class="token string">'env://'</span><span class="token punctuation">)</span>model <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>parallel<span class="token punctuation">.</span>DistributedDataParallel<span class="token punctuation">(</span>                                      model<span class="token punctuation">,</span>                                        device_ids<span class="token operator">=</span><span class="token punctuation">[</span>args<span class="token punctuation">.</span>local_rank<span class="token punctuation">]</span><span class="token punctuation">,</span>                                        output_device<span class="token operator">=</span>args<span class="token punctuation">.</span>local_rank<span class="token punctuation">)</span></code></pre><p>Note:</p><ol><li>nccl 后端是分布式训练使用的推荐的最快后端，适用于单节点和多节点分布式训练</li><li>nccl同时支持混合精度分布式训练</li><li>no_sync 用于禁用DDP进程之间的梯度同步，直到退出此上下文区域的第一个梯度Forward-Backward中进行梯度同步</li></ol><pre class=" language-python"><code class="language-python">ddp <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>DistributedDataParallel<span class="token punctuation">(</span>model<span class="token punctuation">,</span> pg<span class="token punctuation">)</span><span class="token keyword">with</span> ddp<span class="token punctuation">.</span>no_sync<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">for</span> input <span class="token keyword">in</span> inputs<span class="token punctuation">:</span>    ddp<span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># no synchronization, accumulate grads</span>ddp<span class="token punctuation">(</span>another_input<span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># synchronize grads</span></code></pre><h3 id="apex-parallel-DistributedDataParallel"><a href="#apex-parallel-DistributedDataParallel" class="headerlink" title="apex.parallel.DistributedDataParallel"></a>apex.parallel.DistributedDataParallel</h3><p>　　基本上是torch.nn.parallel.DistributedDataParallel的wrapper，同时调用的时候优化了NCCL的使用和简化了参数</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 调用的时候，注意 n &lt;= 每个节点的GPU数量 同时默认 1个GPU对应1进程</span>torch.distributed.launch --nproc_per_node<span class="token operator">=</span>n distributed_data_parallel.py<span class="token comment" spellcheck="true"># 会自动提供的参数目前已知的是:</span><span class="token comment" spellcheck="true"># args.local_rank</span><span class="token comment" spellcheck="true"># os.environ['WORLD_SIZE']</span></code></pre><p>简化的要点：</p><ol><li><p>model = DDP(model) 即可，无需再传递 devices_ids output_device</p></li><li><p>init_process_group 中的 init_method=’env://‘</p><pre class=" language-python"><code class="language-python">torch<span class="token punctuation">.</span>distributed<span class="token punctuation">.</span>init_process_group<span class="token punctuation">(</span>backend<span class="token operator">=</span><span class="token string">'nccl'</span><span class="token punctuation">,</span>init_method<span class="token operator">=</span><span class="token string">'env://'</span><span class="token punctuation">)</span></code></pre></li></ol><p>直接给出示例代码</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># distributed_data_parallel.py</span><span class="token keyword">import</span> torch<span class="token keyword">import</span> argparse<span class="token keyword">import</span> os<span class="token keyword">from</span> apex <span class="token keyword">import</span> amp<span class="token comment" spellcheck="true"># FOR DISTRIBUTED: (can also use torch.nn.parallel.DistributedDataParallel instead)</span><span class="token keyword">from</span> apex<span class="token punctuation">.</span>parallel <span class="token keyword">import</span> DistributedDataParallelparser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># FOR DISTRIBUTED:  Parse for the local_rank argument, which will be supplied</span><span class="token comment" spellcheck="true"># automatically by torch.distributed.launch.</span>parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">"--local_rank"</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> type<span class="token operator">=</span>int<span class="token punctuation">)</span>args <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># FOR DISTRIBUTED:  If we are running under torch.distributed.launch,</span><span class="token comment" spellcheck="true"># the 'WORLD_SIZE' environment variable will also be set automatically.</span>args<span class="token punctuation">.</span>distributed <span class="token operator">=</span> <span class="token boolean">False</span><span class="token keyword">if</span> <span class="token string">'WORLD_SIZE'</span> <span class="token keyword">in</span> os<span class="token punctuation">.</span>environ<span class="token punctuation">:</span>    args<span class="token punctuation">.</span>distributed <span class="token operator">=</span> int<span class="token punctuation">(</span>os<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">'WORLD_SIZE'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token keyword">if</span> args<span class="token punctuation">.</span>distributed<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># FOR DISTRIBUTED:  Set the device according to local_rank.</span>    torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>set_device<span class="token punctuation">(</span>args<span class="token punctuation">.</span>local_rank<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># FOR DISTRIBUTED:  Initialize the backend.  torch.distributed.launch will provide</span>    <span class="token comment" spellcheck="true"># environment variables, and requires that you use init_method=`env://`.</span>    torch<span class="token punctuation">.</span>distributed<span class="token punctuation">.</span>init_process_group<span class="token punctuation">(</span>backend<span class="token operator">=</span><span class="token string">'nccl'</span><span class="token punctuation">,</span>                                         init_method<span class="token operator">=</span><span class="token string">'env://'</span><span class="token punctuation">)</span>torch<span class="token punctuation">.</span>backends<span class="token punctuation">.</span>cudnn<span class="token punctuation">.</span>benchmark <span class="token operator">=</span> <span class="token boolean">True</span>N<span class="token punctuation">,</span> D_in<span class="token punctuation">,</span> D_out <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token comment" spellcheck="true"># Each process receives its own batch of "fake input data" and "fake target data."</span><span class="token comment" spellcheck="true"># The "training loop" in each process just uses this fake batch over and over.</span><span class="token comment" spellcheck="true"># https://github.com/NVIDIA/apex/tree/master/examples/imagenet provides a more realistic</span><span class="token comment" spellcheck="true"># example of distributed data sampling for both training and validation.</span>x <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>N<span class="token punctuation">,</span> D_in<span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token string">'cuda'</span><span class="token punctuation">)</span>y <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>N<span class="token punctuation">,</span> D_out<span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token string">'cuda'</span><span class="token punctuation">)</span>model <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>D_in<span class="token punctuation">,</span> D_out<span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span>model<span class="token punctuation">,</span> optimizer <span class="token operator">=</span> amp<span class="token punctuation">.</span>initialize<span class="token punctuation">(</span>model<span class="token punctuation">,</span> optimizer<span class="token punctuation">,</span> opt_level<span class="token operator">=</span><span class="token string">"O1"</span><span class="token punctuation">)</span><span class="token keyword">if</span> args<span class="token punctuation">.</span>distributed<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># FOR DISTRIBUTED:  After amp.initialize, wrap the model with</span>    <span class="token comment" spellcheck="true"># apex.parallel.DistributedDataParallel.</span>    model <span class="token operator">=</span> DistributedDataParallel<span class="token punctuation">(</span>model<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># torch.nn.parallel.DistributedDataParallel is also fine, with some added args:</span>    <span class="token comment" spellcheck="true"># model = torch.nn.parallel.DistributedDataParallel(model,</span>    <span class="token comment" spellcheck="true">#                                                   device_ids=[args.local_rank],</span>    <span class="token comment" spellcheck="true">#                                                   output_device=args.local_rank)</span>loss_fn <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>MSELoss<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> t <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>    y_pred <span class="token operator">=</span> model<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    loss <span class="token operator">=</span> loss_fn<span class="token punctuation">(</span>y_pred<span class="token punctuation">,</span> y<span class="token punctuation">)</span>    <span class="token keyword">with</span> amp<span class="token punctuation">.</span>scale_loss<span class="token punctuation">(</span>loss<span class="token punctuation">,</span> optimizer<span class="token punctuation">)</span> <span class="token keyword">as</span> scaled_loss<span class="token punctuation">:</span>        scaled_loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>    optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> args<span class="token punctuation">.</span>local_rank <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"final loss = "</span><span class="token punctuation">,</span> loss<span class="token punctuation">)</span></code></pre><p>更复杂的多精度调用见 <a href="https://github.com/NVIDIA/apex/tree/master/examples/imagenet">mixed precision training with DDP</a></p><h3 id="DDP-保存和加载检查点"><a href="#DDP-保存和加载检查点" class="headerlink" title="DDP 保存和加载检查点"></a>DDP 保存和加载检查点</h3><p>　　一般是使用torch.save 和 torch.load 来完成，但是在多进程下，优化方法是，仅在一个进程中保存，然后在其他所有进程中加载。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> tempfile<span class="token keyword">import</span> torch<span class="token keyword">import</span> torch<span class="token punctuation">.</span>distributed <span class="token keyword">as</span> dist<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">import</span> torch<span class="token punctuation">.</span>optim <span class="token keyword">as</span> optim<span class="token keyword">import</span> torch<span class="token punctuation">.</span>multiprocessing <span class="token keyword">as</span> mp<span class="token keyword">from</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>parallel <span class="token keyword">import</span> DistributedDataParallel <span class="token keyword">as</span> DDP<span class="token keyword">def</span> <span class="token function">demo_checkpoint</span><span class="token punctuation">(</span>rank<span class="token punctuation">,</span> world_size<span class="token punctuation">)</span><span class="token punctuation">:</span>    setup<span class="token punctuation">(</span>rank<span class="token punctuation">,</span> world_size<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># setup devices for this process, rank 1 uses GPUs [0, 1, 2, 3] and</span>    <span class="token comment" spellcheck="true"># rank 2 uses GPUs [4, 5, 6, 7].</span>    n <span class="token operator">=</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>device_count<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">//</span> world_size    device_ids <span class="token operator">=</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span>rank <span class="token operator">*</span> n<span class="token punctuation">,</span> <span class="token punctuation">(</span>rank <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>    model <span class="token operator">=</span> ToyModel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device_ids<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># output_device defaults to device_ids[0]</span>    ddp_model <span class="token operator">=</span> DDP<span class="token punctuation">(</span>model<span class="token punctuation">,</span> device_ids<span class="token operator">=</span>device_ids<span class="token punctuation">)</span>    loss_fn <span class="token operator">=</span> nn<span class="token punctuation">.</span>MSELoss<span class="token punctuation">(</span><span class="token punctuation">)</span>    optimizer <span class="token operator">=</span> optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>ddp_model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">)</span>    CHECKPOINT_PATH <span class="token operator">=</span> tempfile<span class="token punctuation">.</span>gettempdir<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"/model.checkpoint"</span>    <span class="token keyword">if</span> rank <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># All processes should see same parameters as they all start from same</span>        <span class="token comment" spellcheck="true"># random parameters and gradients are synchronized in backward passes.</span>        <span class="token comment" spellcheck="true"># Therefore, saving it in one process is sufficient.</span>        torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>ddp_model<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> CHECKPOINT_PATH<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Use a barrier() to make sure that process 1 loads the model after process</span>    <span class="token comment" spellcheck="true"># 0 saves it.</span>    dist<span class="token punctuation">.</span>barrier<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># configure map_location properly</span>    rank0_devices <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token operator">-</span> rank <span class="token operator">*</span> len<span class="token punctuation">(</span>device_ids<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> device_ids<span class="token punctuation">]</span>    device_pairs <span class="token operator">=</span> zip<span class="token punctuation">(</span>rank0_devices<span class="token punctuation">,</span> device_ids<span class="token punctuation">)</span>    map_location <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;'cuda:%d' % x: 'cuda:%d' % y for x, y in device_pairs&amp;#125;</span>    ddp_model<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>        torch<span class="token punctuation">.</span>load<span class="token punctuation">(</span>CHECKPOINT_PATH<span class="token punctuation">,</span> map_location<span class="token operator">=</span>map_location<span class="token punctuation">)</span><span class="token punctuation">)</span>    optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>    outputs <span class="token operator">=</span> ddp_model<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    labels <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device_ids<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    loss_fn <span class="token operator">=</span> nn<span class="token punctuation">.</span>MSELoss<span class="token punctuation">(</span><span class="token punctuation">)</span>    loss_fn<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>    optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Use a barrier() to make sure that all processes have finished reading the</span>    <span class="token comment" spellcheck="true"># checkpoint</span>    dist<span class="token punctuation">.</span>barrier<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> rank <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        os<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>CHECKPOINT_PATH<span class="token punctuation">)</span>    cleanup<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="DDP-与模型拼接并行"><a href="#DDP-与模型拼接并行" class="headerlink" title="DDP 与模型拼接并行"></a>DDP 与模型拼接并行</h3><p>　　DDP 还可以与多 GPU 模型一起使用，但是不支持进程内的复制。 您需要为每个模块副本创建一个进程，与每个进程的多个副本相比，通常可以提高性能。 当训练具有大量数据的大型模型时，DDP 包装多 GPU 模型特别有用。 使用此功能时，需要小心地实现多 GPU 模型，以避免使用硬编码的设备，因为会将不同的模型副本放置到不同的设备上。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ToyMpModel</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dev0<span class="token punctuation">,</span> dev1<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>ToyMpModel<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dev0 <span class="token operator">=</span> dev0        self<span class="token punctuation">.</span>dev1 <span class="token operator">=</span> dev1        self<span class="token punctuation">.</span>net1 <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>dev0<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>relu <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>net2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>dev1<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> x<span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>dev0<span class="token punctuation">)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>net1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>        x <span class="token operator">=</span> x<span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>dev1<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>net2<span class="token punctuation">(</span>x<span class="token punctuation">)</span></code></pre><p>将多 GPU 模型传递给 DDP 时，不得设置<code>device_ids</code>和<code>output_device</code>。 输入和输出数据将通过应用程序或模型<code>forward()</code>方法放置在适当的设备中。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">demo_model_parallel</span><span class="token punctuation">(</span>rank<span class="token punctuation">,</span> world_size<span class="token punctuation">)</span><span class="token punctuation">:</span>    setup<span class="token punctuation">(</span>rank<span class="token punctuation">,</span> world_size<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># setup mp_model and devices for this process</span>    dev0 <span class="token operator">=</span> rank <span class="token operator">*</span> <span class="token number">2</span>    dev1 <span class="token operator">=</span> rank <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span>    mp_model <span class="token operator">=</span> ToyMpModel<span class="token punctuation">(</span>dev0<span class="token punctuation">,</span> dev1<span class="token punctuation">)</span>    ddp_mp_model <span class="token operator">=</span> DDP<span class="token punctuation">(</span>mp_model<span class="token punctuation">)</span>    loss_fn <span class="token operator">=</span> nn<span class="token punctuation">.</span>MSELoss<span class="token punctuation">(</span><span class="token punctuation">)</span>    optimizer <span class="token operator">=</span> optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>ddp_mp_model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">)</span>    optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># outputs will be on dev1</span>    outputs <span class="token operator">=</span> ddp_mp_model<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    labels <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>dev1<span class="token punctuation">)</span>    loss_fn<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>    optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>    cleanup<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    run_demo<span class="token punctuation">(</span>demo_basic<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    run_demo<span class="token punctuation">(</span>demo_checkpoint<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>device_count<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">8</span><span class="token punctuation">:</span>        run_demo<span class="token punctuation">(</span>demo_model_parallel<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span></code></pre><p>注意上述setup 是通过 torch.multiprocessing.spawn 来完成多线程启动的，所以初始化方法也需要通过setup单独来指定</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> tempfile<span class="token keyword">import</span> torch<span class="token keyword">import</span> torch<span class="token punctuation">.</span>distributed <span class="token keyword">as</span> dist<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">import</span> torch<span class="token punctuation">.</span>optim <span class="token keyword">as</span> optim<span class="token keyword">import</span> torch<span class="token punctuation">.</span>multiprocessing <span class="token keyword">as</span> mp<span class="token keyword">from</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>parallel <span class="token keyword">import</span> DistributedDataParallel <span class="token keyword">as</span> DDP<span class="token keyword">def</span> <span class="token function">setup</span><span class="token punctuation">(</span>rank<span class="token punctuation">,</span> world_size<span class="token punctuation">)</span><span class="token punctuation">:</span>    os<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">'MASTER_ADDR'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'localhost'</span>    os<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">'MASTER_PORT'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'12355'</span>    <span class="token comment" spellcheck="true"># initialize the process group</span>    dist<span class="token punctuation">.</span>init_process_group<span class="token punctuation">(</span><span class="token string">"gloo"</span><span class="token punctuation">,</span> rank<span class="token operator">=</span>rank<span class="token punctuation">,</span> world_size<span class="token operator">=</span>world_size<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Explicitly setting seed to make sure that models created in two processes</span>    <span class="token comment" spellcheck="true"># start from same random weights and biases.</span>    torch<span class="token punctuation">.</span>manual_seed<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    dist<span class="token punctuation">.</span>destroy_process_group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">ToyModel</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>ToyModel<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>net1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>relu <span class="token operator">=</span> nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>net2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>net2<span class="token punctuation">(</span>self<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>net1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">demo_basic</span><span class="token punctuation">(</span>rank<span class="token punctuation">,</span> world_size<span class="token punctuation">)</span><span class="token punctuation">:</span>    setup<span class="token punctuation">(</span>rank<span class="token punctuation">,</span> world_size<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># setup devices for this process, rank 1 uses GPUs [0, 1, 2, 3] and</span>    <span class="token comment" spellcheck="true"># rank 2 uses GPUs [4, 5, 6, 7].</span>    n <span class="token operator">=</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>device_count<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">//</span> world_size    device_ids <span class="token operator">=</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span>rank <span class="token operator">*</span> n<span class="token punctuation">,</span> <span class="token punctuation">(</span>rank <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># create model and move it to device_ids[0]</span>    model <span class="token operator">=</span> ToyModel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device_ids<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># output_device defaults to device_ids[0]</span>    ddp_model <span class="token operator">=</span> DDP<span class="token punctuation">(</span>model<span class="token punctuation">,</span> device_ids<span class="token operator">=</span>device_ids<span class="token punctuation">)</span>    loss_fn <span class="token operator">=</span> nn<span class="token punctuation">.</span>MSELoss<span class="token punctuation">(</span><span class="token punctuation">)</span>    optimizer <span class="token operator">=</span> optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>ddp_model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">)</span>    optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>    outputs <span class="token operator">=</span> ddp_model<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    labels <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device_ids<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    loss_fn<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>    optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>    cleanup<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">run_demo</span><span class="token punctuation">(</span>demo_fn<span class="token punctuation">,</span> world_size<span class="token punctuation">)</span><span class="token punctuation">:</span>    mp<span class="token punctuation">.</span>spawn<span class="token punctuation">(</span>demo_fn<span class="token punctuation">,</span>             args<span class="token operator">=</span><span class="token punctuation">(</span>world_size<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>             nprocs<span class="token operator">=</span>world_size<span class="token punctuation">,</span>             join<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span></code></pre><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>　　至此基本分析完所有Pytorch下的多GPU使用技巧，大体方案还是利用多进程的方式来规避GIL来提升性能，只需要用DDP 来包装model ，同时进行分布式对应的初始化，然后多进程启动即可加速训练，基本没有大的变动。</p><p>References:</p><p><a href="https://pytorch.apachecn.org/docs/1.4/75.html">torch.nn</a></p><p><a href="https://pytorch.org/docs/stable/generated/torch.nn.parallel.DistributedDataParallel.html?highlight=distributeddataparallel#torch.nn.parallel.DistributedDataParallel">DistributedDataParallel API</a></p><p><a href="https://pytorch.org/docs/stable/notes/cuda.html#cuda-nn-ddp-instead">CUDA Semantics</a></p><p><a href="https://pytorch.apachecn.org/docs/1.4/34.html">分布式数据并行入门</a></p><p><a href="https://pytorch.apachecn.org/docs/1.4/35.html">用Pytorch编写分布式应用程序</a></p><p><a href="https://nvidia.github.io/apex/parallel.html">apex.parallel</a></p>]]></content>
      
      
      <categories>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
            <tag> CUDA </tag>
            
            <tag> GPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步和异步编程(如何并行写同一个日志文件实践)</title>
      <link href="algorithms/tong-bu-he-yi-bu-bian-cheng-ru-he-bing-xing-xie-tong-yi-ge-ri-zhi-wen-jian-shi-jian/"/>
      <url>algorithms/tong-bu-he-yi-bu-bian-cheng-ru-he-bing-xing-xie-tong-yi-ge-ri-zhi-wen-jian-shi-jian/</url>
      
        <content type="html"><![CDATA[<p>　　最近遇到如何并行写日志文件的问题，查看之前的代码，发现是利用RabbitMQ 作为消息中转，把并行的日志流通过HTTP 请求整合成串行的方式，然后通过一个单独的 Rabbit-Consumer 来写入文件，这样就成功避免了多个进程同时写一个文件造成的加锁问题，但是我觉得日志这种I/O为主的任务，动用RabbitMQ 有点大材小用的感觉，Producer-Consumer的总体思想可以不变，但是可以用其他更加轻量级的编程模型来实现，也借此重新优化一下日志输出的，毕竟之前的日志输出感觉一片混乱，在自己熟悉代码的情况下，仍然会有些理解困难，这跟当初自己写代码的时候不重视日志输出这一块有关，甚至很多情急之下写下的print打印信息都最后都没有处理。</p><p>　　在开始之前，必须要回忆一些似曾相识，却又容易混淆的基本概念，因为在不区分这些基本OS名词之前，根本就完全无法下手，不知道应该如何正确的实践，具体到每个代码跟这些概念是如何结合在一起的，基本上完全不知道，学生时代留下的坏习惯作怪，理论脱离实际，这时候也才意识到书到用时方恨少。</p><h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><p>　　这个概念有点复杂，来自OS中线程/进程的生命周期，诸如，就绪，运行，阻塞 ，但是如果仅仅按照这个方向理解，那就比较简单，仅仅就是线程/进程调度程序根据一定的策略，把线程/进程制定相应的状态，来安排和调度CPU资源；然而在OS之中，阻塞的原因很多，并非只是单纯的IO，严格上来讲应该是跟IO类似的原因被阻塞，即请求的资源无法得到，所以这里的阻塞调用，则是更加强调的是，单线程/进程在运行时，那些一定会被阻塞的编程模式，最重要的一个就是同步的编程模式，一旦请求的资源不具备，程序立刻陷入等待，这样就会特别容易被OS识别为闲置的线程/进程，并很快被阻塞。相反，异步则是一种将等待的资源交给外部程序和硬件，要么是子线程/进程，要么就是外部设备，总之试图通过改变通信模式的方式，使主程序始终维持运行态，这样就达到不被阻塞的目的。这就对编程模式有比较大的变动，因为主程序需要应对请求资源返回的各种情况需要预先有响应的程序段来处理，也就是常见的编程过程中回调函数的编写。</p><blockquote><p>阻塞调用是指调用结果返回之前，调用者会进入阻塞状态等待。只有在得到结果之后才会返回。</p><p>非阻塞调用是指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p></blockquote><p>阻塞调用：比如 socket 的 recv()，调用这个函数的线程如果没有数据返回，它会一直阻塞着，也就是 recv() 后面的代码都不会执行了，程序就停在 recv() 这里等待，所以一般把 recv() 放在单独的线程里调用。</p><p>非阻塞调用：比如非阻塞socket 的 send()，调用这个函数，它只是把待发送的数据复制到TCP输出缓冲区中，就立刻返回了，线程并不会阻塞，数据有没有发出去 send() 是不知道的，不会等待它发出去才返回的。</p><h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h4><p>基本还记得最显著的区别</p><blockquote><p>并发是指一个时间段内，有几个程序都在同一个CPU上运行，但任意一个时刻点上只有一个程序在处理机上运行。</p><p>并行是指一个时间段内，有几个程序都在几个CPU上运行，任意一个时刻点上，有多个程序在同时运行，并且多道程序之间互不干扰。 两者区别如下图</p></blockquote><p><img src="1.jpeg"></p><p><img src="2.jpeg"></p><h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><p>这个有点基本印象，经过很多次反复理解，依然还是没有很清晰掌握</p><blockquote><p>同步：在发出一个同步调用时，在没有得到结果之前，该调用就不返回</p><p>异步：在发出一个异步调用后，调用者不会立刻得到结果，该调用就返回了</p></blockquote><p>　　同步和阻塞， 异步和非阻塞概念非常类似，但是所涉及的范围还是有所不同，总的来讲应该是2个独立的概念体系。</p><p>　　同步和异步，应该是编程模型中，约定好的一种线程/进程间互相通信的方式，同步则是比较自然的一种程序运作方式，就是自顶向下，资源缺失，主程序等待资源准备，资源就绪继续运行；然而在OS系统调度的指挥下，同步很明显的缺点就是主程序无差别的等待所有资源，很容易程序会因为一些无关紧要的情况而一直处于等待，这其中就有比较大的优化空间；所以根据这种情况一种自然的解决办法是，让程序对各种资源缺失的情况能有对应的方案，最终形成了异步的通信策略，相比于定义上的，调用之后立刻返回这样不知所云的解释，我的理解是，程序是制定了一系列某些资源缺失或者不可用时，程序应该如何运作的逻辑，并且为了保持主程序运行，把程序调用之后的所有职责都交给了子程序，即子程序调用之后，应该由子程序来负责通知主程序，而不是跟同步那样，主程序持续等待子程序准备就绪，而原地踏步；这里的主要区别就是异步时候，主程序调用之后立刻转入下一步不需要这个资源的逻辑，有点类似于，乐观锁和悲观锁的性质，不加判断的断定后续逻辑分支，直接运行。缺点是，感觉异步编程为了解决临界区问题和通信问题，有很多复杂的管控逻辑需要解决，简单来说就是很多坑。好处是，如果这些坑都能解决，程序运行效率会有比较大的提升。</p><p>　　如果同步异步是编程模式的话，那么阻塞和非阻塞相对来说我认为是一个并非严格的概念，如果调用必定会导致主程序闲置，进而被置入阻塞状态，那么就是阻塞，如果调用不会导致主程序闲置，那么就是非阻塞。这其中的关键点就是OS的进程/线程调度，而不是调用的问题，然而阻塞的定义中常常会加入调用是否立刻返回的解释，常常让我跟同步异步的概念分不清楚，诚然调用不返回在当今的OS下一定会引起主程序闲置并阻塞，但是主因必然是主程序闲置等待，如果异步通信，但是仍然没有后续程序逻辑，显然异步程序也会有阻塞的风险。所以，我觉得阻塞这个更应该是一个OS的结果，而不是原因。</p><blockquote><p>阻塞和非阻塞关注的是程序等待调用结果时的状态，是闲置还是持续运行</p></blockquote><p>线程与进程</p><p>　　曾经考试的时候定义背的滚瓜烂熟，然而却完全没有代码经验，感觉彼时都到门口了，缺乏临门一脚，直到现在又千辛万苦来回到这里，重新完成当初没有做到的事情。</p><p>　　这里我在实践中，线程跟并发 搞混了，以至于以为线程之间必然是并发，所以有可能分时共享cuda 的引用，认为利用多线程就可以优化GPU利用率。最后实践中，怎么都达不到预想的目的。仔细想想，尽管同一个进程的资源可以被进程内的所有线程共享，这样如果多个线程是分时共享的，那么cuda引用作为一个共享资源，就可以达到并发使用的目的；但是这个前提是，线程必须是并发的，那么线程真的是并发的吗？如果是曾经的单核单线程CPU，答案是肯定的，现在的基本都是多核多线程CPU了，所以线程级别肯定是并行的，那么cuda引用则必然作为一个临界共享资源，被多个线程抢占使用，多线程并行退化成多线程并发，虽然预想的目的似乎达到了，但是貌似并没有达到优化的目的，至少跟之前编写的单线程基本性能是一样的。</p><p>　　其次是Python的GIL锁, Global Interpreter Lock，即任何Python 线程执行，只有GIL锁的线程才可以运行，也就是说一个进程下的多线程在Python下，永远只有一个线程在运行</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token punctuation">,</span> multiprocessing<span class="token keyword">def</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>                x <span class="token operator">=</span> x<span class="token operator">^</span><span class="token number">1</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>multiprocessing<span class="token punctuation">.</span>cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target <span class="token operator">=</span> loop<span class="token punctuation">)</span>        t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>上述程序在多核CPU下占有率只有100%，但是C++/Java改写的死循环，则可以每个核心都跑完，即4核心400%</p><p>更坑的是，GIL锁每个线程只有执行100条字节码的机会，那么有效的利用cuda资源则成为空谈，因为频繁的显存数据进出，比较浪费时间。所以python下一般都是利用多个进程来实现并行，因为多个进程有独立的GIL锁，互不影响。</p><p>　　惭愧的是，自己写了这么久的Python，居然才第一次面对并行化问题，才知道GIL锁有这么多繁琐的坑。理论上证实这样的不可行之后，有点失望，但是也还是保留机会来完成并行写日志这个小任务的，毕竟通过HTTP接口，再怎么并发，框架还是很好的完成的这些繁琐的坑，只需要在producer-consumer 框架下，实现并行接受，串行消费就可以了，这还是比较基础的一个改写，对自己还是有信心的。</p><p>　　线程安全，进程安全，意思就是在多线程或者多进程下，可以在代码中不加改变的直接使用，库和框架会自动解决并发和并行问题。其中 queue.Queue 就是线程安全的，下面就是利用Queue来实现进程间通信的producer-consumer</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> queue <span class="token keyword">import</span> Queue<span class="token keyword">from</span> threading <span class="token keyword">import</span> Thread<span class="token keyword">def</span> <span class="token function">producer</span><span class="token punctuation">(</span>out_q<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        out_q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">consumer</span><span class="token punctuation">(</span>in_q<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        data <span class="token operator">=</span> in_q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true"># 通过q通知 任务完成</span>      in_q<span class="token punctuation">.</span>task_done<span class="token punctuation">(</span><span class="token punctuation">)</span>q <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>t1 <span class="token operator">=</span> Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>consumer<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>t2 <span class="token operator">=</span> Thread<span class="token punctuation">(</span>taget<span class="token operator">=</span>producer<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># wait for all produced items to be consumed</span>q<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>　　优化点，队列的流量控制，q需要指定大小，必要时候阻塞Queue，以避免连锁效应导致程序运行失常，同时阻塞的队列也会形成死锁，通过非阻塞和设定超时时间，来处理队列满或者超时的情况，避免阻塞</p><pre class=" language-python"><code class="language-python">q <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    data <span class="token operator">=</span> q<span class="token punctuation">.</span>get<span class="token punctuation">(</span>block<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">except</span> queue<span class="token punctuation">.</span>Empty<span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token keyword">try</span><span class="token punctuation">:</span>    q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>item<span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">5.0</span><span class="token punctuation">)</span><span class="token keyword">except</span> queue<span class="token punctuation">.</span>Full<span class="token punctuation">:</span>    log<span class="token punctuation">.</span>warning<span class="token punctuation">(</span><span class="token string">'queued item %r discarded!'</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span></code></pre><h3 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h3><p>　　利用tornado接受并发的http请求，解析request_body之后，直接入列队伍q.put()，这里利用了tornado 的异步接受并发的特点，直接简化producer过程。接着只需要编写consumer，取出数据，写到文件即可</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> eliot <span class="token keyword">import</span> log_call<span class="token punctuation">,</span> start_action<span class="token punctuation">,</span> to_file<span class="token keyword">class</span> <span class="token class-name">LogHandler</span><span class="token punctuation">(</span>tornado<span class="token punctuation">.</span>web<span class="token punctuation">.</span>RequestHandler<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># eliot 直接利用装饰器来添加日志功能，只记录input, output</span>    @log_call    <span class="token keyword">def</span> <span class="token function">post</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>timestamp <span class="token operator">=</span> time<span class="token punctuation">.</span>ctime<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>recv_json <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>self<span class="token punctuation">.</span>request<span class="token punctuation">.</span>body<span class="token punctuation">,</span> strict<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>            q<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>timestamp<span class="token punctuation">,</span> self<span class="token punctuation">.</span>recv_json <span class="token punctuation">)</span><span class="token punctuation">)</span>            output_dic <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>                <span class="token string">'status'</span><span class="token punctuation">:</span> <span class="token string">'1'</span><span class="token punctuation">,</span>                <span class="token string">'result'</span><span class="token punctuation">:</span> <span class="token string">'success'</span>      <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>        <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'LogHandler Error: '</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token comment" spellcheck="true"># eliot.start_action 通过 with 来记录函数段，有点繁琐，但是对于某段代码的日志记录很方便</span><span class="token keyword">def</span> <span class="token function">consume_msg</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">with</span> start_action<span class="token punctuation">(</span>action_type<span class="token operator">=</span><span class="token string">'consume_msg'</span><span class="token punctuation">,</span> lenghth <span class="token operator">=</span> queue<span class="token punctuation">.</span>qsize<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">try</span><span class="token punctuation">:</span>                timestamp<span class="token punctuation">,</span> msg<span class="token operator">=</span> q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>                start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">with</span> start_action<span class="token punctuation">(</span>action_type<span class="token operator">=</span><span class="token string">'save_request_body'</span><span class="token punctuation">,</span> timestamp<span class="token operator">=</span>timestamp<span class="token punctuation">,</span>msg<span class="token operator">=</span>msg<span class="token punctuation">)</span><span class="token punctuation">:</span>                    save_body<span class="token punctuation">(</span>msg<span class="token punctuation">)</span>            <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>                <span class="token keyword">with</span> start_action<span class="token punctuation">(</span>action_type<span class="token operator">=</span><span class="token string">'consume_msg exceptiosn'</span><span class="token punctuation">,</span> timestamp<span class="token operator">=</span>timestamp<span class="token punctuation">,</span>e<span class="token operator">=</span>e<span class="token punctuation">,</span> msg<span class="token operator">=</span>msg<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'consume_mgs exception : '</span>  <span class="token punctuation">,</span> e<span class="token punctuation">)</span>consumer <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>consume_msg<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">)</span>consumer<span class="token punctuation">.</span>daemon <span class="token operator">=</span> <span class="token boolean">True</span> <span class="token comment" spellcheck="true"># 守护进程</span>consumer<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>　　至此，多进程的日志记录完成，同时也用上了之前一直想要用eliot日志系统，让日志看起来清爽了许多。</p><h3 id="RabbiMQ"><a href="#RabbiMQ" class="headerlink" title="RabbiMQ"></a>RabbiMQ</h3><p>RabbiMQ 的方案也写进来，毕竟原理大同小异，只是初始化和连接的部分需要重新封装一下，而且适用性更广。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># rabbitmq init</span>credentials <span class="token operator">=</span> pika<span class="token punctuation">.</span>PlainCredentials<span class="token punctuation">(</span>RabbitMQ<span class="token punctuation">.</span>USERNAME<span class="token punctuation">,</span> RabbitMQ<span class="token punctuation">.</span>USERPWD<span class="token punctuation">)</span>connection <span class="token operator">=</span> pika<span class="token punctuation">.</span>BlockingConnection<span class="token punctuation">(</span>                pika<span class="token punctuation">.</span>ConnectionParameters<span class="token punctuation">(</span>RabbitMQ<span class="token punctuation">.</span>HOST<span class="token punctuation">,</span> RabbitMQ<span class="token punctuation">.</span>PORT<span class="token punctuation">,</span>                                          credentials<span class="token operator">=</span>credentials<span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token comment" spellcheck="true"># channel init and declare</span>channel <span class="token operator">=</span> connection<span class="token punctuation">.</span>channel<span class="token punctuation">(</span><span class="token punctuation">)</span>channel<span class="token punctuation">.</span>exchange_declare<span class="token punctuation">(</span>exchange<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>EXCHANGE<span class="token punctuation">,</span>                             exchange_type<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>EXCHANGE_TYPE<span class="token punctuation">,</span>                             durable<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>channel<span class="token punctuation">.</span>queue_declare<span class="token punctuation">(</span>queue<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>QUEUE_NAME_ALG<span class="token punctuation">,</span> durable<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>channel<span class="token punctuation">.</span>queue_bind<span class="token punctuation">(</span>exchange<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>EXCHANGE<span class="token punctuation">,</span>                       queue<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>QUEUE_NAME_ALG<span class="token punctuation">,</span>                       routing_key<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>ROUTING_KEY<span class="token punctuation">)</span>channel<span class="token punctuation">.</span>basic_qos<span class="token punctuation">(</span>prefetch_count<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 能者多劳</span>channel<span class="token punctuation">.</span>basic_consume<span class="token punctuation">(</span>on_message_callback<span class="token operator">=</span>consumer<span class="token punctuation">,</span>                          queue<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>QUEUE_NAME_ALG<span class="token punctuation">,</span> auto_ack<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">' [*] Waiting for messages...'</span><span class="token punctuation">)</span>channel<span class="token punctuation">.</span>start_consuming<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">consumer</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> method<span class="token punctuation">,</span> properties<span class="token punctuation">,</span> body<span class="token punctuation">)</span><span class="token punctuation">:</span>    body <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>body<span class="token punctuation">,</span> strict<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    flag <span class="token operator">=</span> body<span class="token punctuation">[</span><span class="token string">'flag'</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># process body</span>    <span class="token comment" spellcheck="true"># Ack manually</span>    ch<span class="token punctuation">.</span>basic_ack<span class="token punctuation">(</span>delivery_tag<span class="token operator">=</span>method<span class="token punctuation">.</span>delivery_tag<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># producer.py</span><span class="token keyword">try</span><span class="token punctuation">:</span>    credentials <span class="token operator">=</span> pika<span class="token punctuation">.</span>PlainCredentials<span class="token punctuation">(</span>                RabbitMQ<span class="token punctuation">.</span>USERNAME<span class="token punctuation">,</span> RabbitMQ<span class="token punctuation">.</span>USERPWD<span class="token punctuation">)</span>    connection <span class="token operator">=</span> pika<span class="token punctuation">.</span>BlockingConnection<span class="token punctuation">(</span>                pika<span class="token punctuation">.</span>ConnectionParameters<span class="token punctuation">(</span>RabbitMQ<span class="token punctuation">.</span>HOST<span class="token punctuation">,</span> RabbitMQ<span class="token punctuation">.</span>PORT<span class="token punctuation">,</span>                                          credentials<span class="token operator">=</span>credentials<span class="token punctuation">)</span>            <span class="token punctuation">)</span>    channel <span class="token operator">=</span> self<span class="token punctuation">.</span>connection<span class="token punctuation">.</span>channel<span class="token punctuation">(</span><span class="token punctuation">)</span>    channel<span class="token punctuation">.</span>exchange_declare<span class="token punctuation">(</span>exchange<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>EXCHANGE<span class="token punctuation">,</span>                                                                                              exchange_type<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>EXCHANGE_TYPE<span class="token punctuation">,</span>                                          durable<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">pass</span>sent_msg <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;...&amp;#125;</span>body <span class="token operator">=</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>sent_msg<span class="token punctuation">)</span>channel<span class="token punctuation">.</span>basic_publish<span class="token punctuation">(</span>exchange<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>EXCHANGE<span class="token punctuation">,</span>                                       routing_key<span class="token operator">=</span>RabbitMQ<span class="token punctuation">.</span>ROUTING_KEY<span class="token punctuation">,</span>                      body<span class="token operator">=</span>body<span class="token punctuation">,</span>                       properties<span class="token operator">=</span>pika<span class="token punctuation">.</span>BasicProperties<span class="token punctuation">(</span>delivery_mode<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>channel<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>connection<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="计算密集型-和-IO密集型的思考"><a href="#计算密集型-和-IO密集型的思考" class="headerlink" title="计算密集型 和 IO密集型的思考"></a>计算密集型 和 IO密集型的思考</h3><p>　　当初写论文的时候，就在机器上跑了很多类型的负载任务，最直观的感受就是，计算密集型的负载比较难找，相对于纯粹的计算任务，很多实际的任务都会因为千奇百怪的原因被消耗在IO上，导致运行效率低下。</p><blockquote><p>计算密集型，代码运行效率为主，因为主要时间都消耗在CPU上，Python的脚本语言不适合这类任务，最好用C++/Java实现</p><p>IO密集型，大部分时间消耗在IO上，C++/Java无法发挥优势，代码量少开发效率最高的Python具备优势</p></blockquote><p>　　所以，Python最好最为原型开发，保持逻辑流程通顺的前提下，可以用其他高效的语言如C++/Java改写最耗时的模块，迭代优化开发。</p><h3 id="协程：单线程异步"><a href="#协程：单线程异步" class="headerlink" title="协程：单线程异步"></a>协程：单线程异步</h3><p>　　虽然Python无法利用多线程的并行优势，但是还是有优化的手段的。如果把条件限制到单线程，那么有一个很自然的优化方式就是单线程异步，也就是只用单线程的情况下，实现程序内部的并发，这个并发是程序可控的，而不是由操作系统来根据一定策略加锁。</p><p>　　Python下有协程库asyncio内置了异步IO的支持。编程模型是一个消息循环，从asyncio获取EventLoop引用，把需要执行的协程作为参数传递给EventLoop，实现异步IO,下面直接给出协程版本的producer-consumer</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">import</span> random<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">producer</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'producing : '</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># simulate io job</span>        <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        item <span class="token operator">=</span> str<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">await</span> queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">consume</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        item <span class="token operator">=</span> <span class="token keyword">await</span> queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># process item</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'consuming : '</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># simulate io </span>    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># notify queue that the item has been processed</span>    queue<span class="token punctuation">.</span>task_done<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    queue <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># schedule consumer</span>  consumer<span class="token operator">=</span> asyncio<span class="token punctuation">.</span>ensure_future<span class="token punctuation">(</span>consume<span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">await</span> producer<span class="token punctuation">(</span>queue<span class="token punctuation">,</span> n<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># wait until consumer processed all items</span>  <span class="token keyword">await</span> queue<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># consumer is still awaiting item, cancel it</span>  consumer<span class="token punctuation">.</span>cancel<span class="token punctuation">(</span><span class="token punctuation">)</span>loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>run<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>loop<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>　　至此，关于同步异步的一些知识点和实践问题梳理完毕，协程的实践经验还是有点欠缺，以后看框架源码的时候，需要多学习和思考。</p><p>References:</p><p><a href="https://asyncio.readthedocs.io/en/latest/producer_consumer.html">Producer/consumer-examlpe_asyncio</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017968846697824">协程-廖雪峰</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017631469467456">进程-线程-廖雪峰</a></p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p03_communicating_between_threads.html">线程间通信-Python_CookBook</a></p><p><a href="https://juejin.cn/post/6844904039210024967#heading-3">Python下的多进程日志记录方案</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 33. Search in Rotated Sorted Array</title>
      <link href="algorithm/leetcode-33-search-in-rotated-sorted-array/"/>
      <url>algorithm/leetcode-33-search-in-rotated-sorted-array/</url>
      
        <content type="html"><![CDATA[<h3 id="LeetCode-33-Search-in-Rotated-Sorted-Array"><a href="#LeetCode-33-Search-in-Rotated-Sorted-Array" class="headerlink" title="LeetCode 33. Search in Rotated Sorted Array"></a>LeetCode 33. Search in Rotated Sorted Array</h3><p><img src="img1.png"></p><p>　　应该是二分法的变种优化，但是实际分析的过程中，自己的想法被太多的if条件给弄晕了，虽然勉强解出来了，但是更多是凭借临场发挥来作出的，至于宏观的算法原理，自己仍然理解不够透彻，借助讨论区的总结出几个好玩的解法</p><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>　　最直接的想法是找到数组的偏移量，通过还原数组为排序数组的方式，最终利用二分法搜索target ，但是自己并没有想出可以$O(log(n))$搜索偏移量的方法，所以没有深入思考。借助讨论区的提醒，其实偏移量就是最小值的下标，所以只需要找到一种在$O(log(n))$下找到最小值的方法，这里仍然是用二分法，只不过start, mid, end 之间比较关系是不同的</p><ul><li>start 和 mid:</li></ul><p>　mid &gt; start : 最小值 in left</p><p><img src="img3.jpg"></p><p>　mid &lt; start : 最小值仍然 in left:</p><p><img src="img2.jpg"></p><ul><li>mid 和 end</li></ul><p>　　mid &lt; end: 最小值 in left，end = mid</p><p><img src="img6.jpg"></p><p>　　mid &gt; end : 最小值 in right, start = mid</p><p><img src="img7.jpg"></p><p>　　只需要mid 和 end就可以利用二分法搜索最小值，只不过需要注意的一点是，可能会出现死循环</p><p><img src="img8.jpg"></p><p>　　主要原因应该是，当最小值in right 的时候，mid 原地更新，而在in right 的情况，实际上mid所在的value不可能是最小值，所以 start = mid + 1 即可</p><pre class=" language-python"><code class="language-python"><span class="token keyword">while</span> start <span class="token operator">&lt;</span> end<span class="token punctuation">:</span>    mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end <span class="token punctuation">)</span> <span class="token operator">//</span><span class="token number">2</span>    <span class="token keyword">if</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">:</span>        start <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        end <span class="token operator">=</span> midbias <span class="token operator">=</span> start</code></pre><p>　　最后利用偏移量，转换mid 为 偏移后的mid，二分搜索target</p><pre class=" language-python"><code class="language-python">start <span class="token operator">=</span> <span class="token number">0</span>end <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token keyword">while</span> start <span class="token operator">&lt;=</span> end<span class="token punctuation">:</span>    mid <span class="token operator">=</span> <span class="token punctuation">(</span>start<span class="token operator">+</span>end<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>    mid_pos <span class="token operator">=</span> <span class="token punctuation">(</span>mid <span class="token operator">+</span> bias<span class="token punctuation">)</span>     <span class="token operator">%</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    val <span class="token operator">=</span> nums<span class="token punctuation">[</span>mid_pos<span class="token punctuation">]</span>    <span class="token keyword">if</span> target <span class="token operator">==</span> value<span class="token punctuation">:</span>        <span class="token keyword">return</span> mid_pos    <span class="token keyword">if</span> target <span class="token operator">&lt;</span> value<span class="token punctuation">:</span>        end <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        start <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span></code></pre><p>Time Complexity: $O(log(n))$</p><p>Space Complexity: $O(1)$</p><h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>　　这里还是将被切分的2段分成2个有序数组来处理，比如,[4 5 6 7 1 2 3 ]分成 [4 5 6 7 ]和[1 2 3 ]，判断target位于其中的哪一段，然后将另一段变成-inf or inf，这样做的目的是可以用正常的二分法来搜索改变后的数组。</p><p>[ 4 5 6 7 1 2 3] ，如果 target = 5，那么数组可以看做 [ 4 5 6 7 inf inf inf ]。</p><p>[ 4 5 6 7 1 2 3] ，如果 target = 2，那么数组可以看做 [ -inf -inf - inf -inf 1 2 3]。</p><p>　　实践阶段，只需要判断nums[mid]的val，如果val跟target同一段，val不变，如果val跟target不通段，就要变成-inf or inf</p><ul><li>nums[mid] 和 target 同一段的条件: </li></ul><pre class=" language-python"><code class="language-python">nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">and</span> target <span class="token operator">></span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">or</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">and</span> target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></code></pre><ul><li>nums[mid] 和 target 不通段的条件：</li></ul><pre class=" language-python"><code class="language-python">nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">and</span> target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">or</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">and</span> target <span class="token operator">></span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></code></pre><p>这样动态的变更nums[mid]的val，保持nums始终与target同段段那部分不变，不同段则变为-inf or inf</p><pre class=" language-python"><code class="language-python">lo <span class="token operator">=</span> <span class="token number">0</span>hi <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token keyword">while</span> lo <span class="token operator">&lt;=</span> hi<span class="token punctuation">:</span>    mid <span class="token operator">=</span> <span class="token punctuation">(</span>lo<span class="token operator">+</span>hi<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>    val <span class="token operator">=</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">></span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span>target <span class="token operator">></span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        val <span class="token operator">=</span>  float<span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span> <span class="token keyword">if</span> target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">else</span> float<span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> val <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>        lo <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">elif</span> val <span class="token operator">></span> target<span class="token punctuation">:</span>        hi <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> mid  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span></code></pre><p>Time Complexity: $O(log(n))$</p><p>Space Complexity: $O(1)$</p><h4 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h4><p>　　基于一个事实，数组从任意位置劈开后，至少有一半是有序的</p><p>　　这里只需要判断二分法的其中一半是否有序， 再根据有序的这一部分判断target是否包含其中</p><pre class=" language-python"><code class="language-python">lo <span class="token operator">=</span> <span class="token number">0</span>hi <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token keyword">while</span> lo <span class="token operator">&lt;=</span> hi<span class="token punctuation">:</span>    mid <span class="token operator">=</span> <span class="token punctuation">(</span>lo<span class="token operator">+</span>hi<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>    val <span class="token operator">=</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span>    <span class="token keyword">if</span> target <span class="token operator">==</span> val<span class="token punctuation">:</span>        <span class="token keyword">return</span> mid        <span class="token comment" spellcheck="true"># lo-mid 有序</span>    <span class="token keyword">if</span> nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> val<span class="token punctuation">:</span>        <span class="token keyword">if</span> target <span class="token operator">>=</span> nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span> <span class="token operator">and</span> target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">:</span>            hi <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            lo <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># mid-hi 有序</span>        <span class="token keyword">if</span> target <span class="token operator">></span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">and</span> target <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>hi<span class="token punctuation">]</span><span class="token punctuation">:</span>            lo <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            hi <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span></code></pre><p>Time Complexity: $O(log(n))$</p><p>Space Complexity: $O(1)$</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>　　$log(n)$的时间复杂度，基本都是二分法的变体，平日自己对二分法过于忽视，导致理解不深刻，所以这个题目做起来才比较费劲。除此之外，解法二巧妙的利用了target 和 nums[mid]是否同一个分割排序段的条件，来简化判断，同时动态的更新nums[mid]值的方法很有启发性，比自己笨拙的设置一大堆if条件，结果自己都搞不清楚状况来的优雅许多。解法一二都是利用抽取出的关键信息来还原二分搜索法，解法三，则是试图找到target分段之前，获取排序信息，再以及排序信息搜索target，题目顿时变的简单了许多。</p><p>Reference:</p><p><a href="https://leetcode.wang/leetCode-33-Search-in-Rotated-Sorted-Array.html">LeetCode 33. Search in Rotated Sorted Array</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记ubuntu重启引起的故障排查</title>
      <link href="yun-wei/ji-ubuntu-chong-qi-yin-qi-de-gu-zhang-pai-cha/"/>
      <url>yun-wei/ji-ubuntu-chong-qi-yin-qi-de-gu-zhang-pai-cha/</url>
      
        <content type="html"><![CDATA[<p>　　前几天，由于自己服务所在的服务器需要停机维护，运行已有近半年的ubuntu 18.04 LTS终于迎来首次重启，尽管由于预料到长时间的服务器不停机，在关机或者重启阶段会有不可预知的事件发生。但是当服务器真的出现网络无法连接的状况的时候，长时间没有安装系统的我那一刻竟然还有点懵B了，此文主要关注此次故障问题排查和解决记录，作为以后服务器维护 参考之用。</p><h3 id="网络故障"><a href="#网络故障" class="headerlink" title="网络故障"></a>网络故障</h3><p>　　重启之后，首先出现的问题就是网络接口灯直接熄灭，几番周折接上显示器和键盘之后，发现是网卡没有ipv4的地址，反而是ipv6的地址是有的。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ifconfig</span> -a <span class="token comment" spellcheck="true"># 显示所有的网卡，如果网卡无ip，单纯的用ifconfig 是无法显示的所有网卡设备的</span><span class="token comment" spellcheck="true"># or</span>ip a</code></pre><p>　　考虑现今的网络设备ipv6基本属于摆设，所以首先定位的问题是静态ip配置没有生效（此刻持续懵B 3mins，完全忘记如何手工配置 静态ip，某些最基础的操作，还是相当依赖UI），搜索一番得到结果是</p><pre class=" language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/network/interfaces<span class="token comment" spellcheck="true"># change</span>auto enp1s0 <span class="token comment" spellcheck="true"># enp5s0 根据ifconfig 或许实际的网卡编号</span>iface enp1s0 inet static        address x.x.x.x        netmask 255.255.255.0        gateway x.x.x.x        dns-nameservers 114.114.114.114 8.8.8.8<span class="token function">sudo</span> ip a flush enp1s0<span class="token function">sudo</span> systemctl restart networking.service</code></pre><p>　　悲剧的是，最后重启 networking.service 并没有发现这个服务，一度陷入僵局，最后发现 Ubuntu 18.04 LTS 开始启用 netplan 组建作为网络管理器，所以这里应该使用netplan来配置静态ip，又是搜索一番</p><pre class=" language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/netplan/50-cloud-init.yaml <span class="token comment" spellcheck="true"># 对于yaml文件可是深恶痛绝，奇怪冒号后必须接空格 和 不允许 缩进\t的设定</span><span class="token comment" spellcheck="true"># change</span><span class="token comment" spellcheck="true"># This file describes the network interfaces available on your system</span><span class="token comment" spellcheck="true"># For more information, see netplan(5).</span>network:  version: 2  renderer: networkd  ethernets:    enp1s0:     dhcp4: no     addresses: <span class="token punctuation">[</span>192.168.1.222/24<span class="token punctuation">]</span>     gateway4: 192.168.1.1     nameservers:       addresses: <span class="token punctuation">[</span>8.8.8.8,8.8.4.4<span class="token punctuation">]</span><span class="token function">sudo</span> netplan apply<span class="token comment" spellcheck="true"># or</span><span class="token function">sudo</span> netplan --dubug apply</code></pre><p>　　坑爹的是，居然没有 netplan 这个命令，然而却有/etc/netplan/50-cloud-init.yaml这个配置网络的文件，而且里面都是曾经配置完好的文件，应该是上次安装就已经确定下来生成的配置文件，这个就属于很小众的问题了，徜徉 StackOverFlow 和 StackExchange 数小时之后得到答案是：从 Ubuntu 16.04  Upgrade Ubuntu 18.04 会出现 netplan 配置已经安装，但是仍然使用 /etc/network/interfaces 配置ip生效的情况。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># netplan 安装 </span><span class="token function">sudo</span> apt <span class="token function">install</span> netplan.io <span class="token comment" spellcheck="true"># 坑爹的软件包命名</span></code></pre><p>但是在这两个文件都存在，同时都配置的情况下，仍然无法使静态ip的配置生效，最主要的是，这个服务器就是原生安装的Ubuntu 18.04 ，并不存在Upgrade 导致这个问题存在的原因。最后无奈，只能通过命令临时生效的静态ip配置，来勉强达到可以上网的目的，想来毕竟服务器24h不关机，临时配置也算可用。唯一的缺点就是，万一重启，就又不得不去机房，现场维护，颇为不便。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 临时生效的 ip 网关 dns 配置方法</span><span class="token comment" spellcheck="true"># 以下所有配置 重启失效</span><span class="token function">ifconfig</span> enp1s0 x.x.x.x netmask 255.255.255.0route add default gw x.x.x.x<span class="token function">vi</span> /etc/resolf.conf</code></pre><h3 id="nvidia-smi-以及-docker-故障"><a href="#nvidia-smi-以及-docker-故障" class="headerlink" title="nvidia-smi 以及 docker 故障"></a>nvidia-smi 以及 docker 故障</h3><p>　　更坑爹是，总算以为完事了的时候，发现nvidia-smi挂了，docker也挂了</p><pre class=" language-bash"><code class="language-bash">nvidia-smiNVIDIA-SMI has failed because it couldn’t communicate with the NVIDIA driver. Make sure that the latest NVIDIA driver is installed and running.</code></pre><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析　　"></a>原因分析　　</h3><p>　　结合之前网络问题，推测应该是重启导致的系统层面的问题。考虑到此次维护硬件只有内存的变动，通过命令查看内存是正常运作的，判断应该是 Ubuntu 系统在重启的时候发生的变化，导致这个问题发生。以ubuntu重启，nvidia 失效，作为关键词，终于找到本次故障的最终原因：Ubuntu 18.04 会自动更新linux内核，并在重启的时候自动启动最新的内核</p><h3 id="故障解决，切换成旧版本内核"><a href="#故障解决，切换成旧版本内核" class="headerlink" title="故障解决，切换成旧版本内核"></a>故障解决，切换成旧版本内核</h3><p>　　首先需要确认旧版本内核是否可以解决上述所有问题，最简单的切换就内核的方法是，在 grub 启动菜单里面选择,Advanced options for Ubuntu -&gt; Ubuntu , with linux x.x.x-x-generic ， 终于找到了4.15.0-60-generic 是旧版本内核，并且上述问题全部解决，而4.15.0-122-generic则是产生故障的最新内核版本。</p><p>　　那么问题来了，怎么切换内核呢？ 搜索引擎救星又来了</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看目前系统已安装内核</span>dpkg --get-selections <span class="token operator">|</span><span class="token function">grep</span> linux-imagelinux-image-4.15.0-122-generic            deinstalllinux-image-4.15.0-60-generic            <span class="token function">install</span>linux-image-4.15.0-62-generic            deinstall<span class="token comment" spellcheck="true"># 查看 grub 已经生成 菜单入口名称</span><span class="token function">grep</span> menuentry /boot/grub/grub.cfgmenuentry <span class="token string">'Ubuntu, with Linux 4.15.0-60-generic'</span> <span class="token punctuation">..</span>.</code></pre><h4 id="Solution-1-修改grub启动配置"><a href="#Solution-1-修改grub启动配置" class="headerlink" title="Solution 1: 修改grub启动配置"></a>Solution 1: 修改grub启动配置</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/default/grub<span class="token comment" spellcheck="true"># change</span>GRUB_DEFAULT<span class="token operator">=</span>“Advanced options <span class="token keyword">for</span> Ubuntu <span class="token operator">></span> Ubuntu, with Linux 4.15.0-60-generic”<span class="token comment" spellcheck="true"># 也可以 用数字标示 0作为第一个菜单</span>GRUB_DEFAULT <span class="token operator">=</span> <span class="token string">"1> 4"</span> <span class="token comment" spellcheck="true">#改成这样</span>GRUB_TIMEOUT_STYLE<span class="token operator">=</span>menu <span class="token comment" spellcheck="true"># default: hidden</span>GRUB_TIMEOUT<span class="token operator">=</span>3 <span class="token comment" spellcheck="true"># default: 0</span><span class="token function">sudo</span> update-grub<span class="token function">sudo</span> <span class="token function">reboot</span></code></pre><h4 id="Solution-2-删除新内核"><a href="#Solution-2-删除新内核" class="headerlink" title="Solution 2: 删除新内核"></a>Solution 2: 删除新内核</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 注意 无法删除正在使用的内核</span><span class="token function">sudo</span> apt remove linux-image-xxx-xx-generic<span class="token comment" spellcheck="true"># or</span><span class="token function">sudo</span> dpkg --purge linux-image-x.x.x-xx-generic<span class="token comment" spellcheck="true"># 安装新内核</span><span class="token function">sudo</span> apt <span class="token function">install</span> linux-headers-x.x.x-x-generic linux-image-x.x.x-x-generic<span class="token comment" spellcheck="true"># 关闭内核自动更新</span><span class="token function">sudo</span> apt-mark hold linux-image-generic linux-headers-generic<span class="token comment" spellcheck="true"># 开启内核自动更新</span><span class="token function">sudo</span> apt-mark unhold linux-image-generic linux-headers-generic</code></pre><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>　　至此，网络问题，nvidia驱动问题，docker问题都得到圆满解决。回顾过程，心态方面还是稍微不够沉着冷静，发现问题根本原因之前，过分关注表象，诸如 netplan 的配置花费的过多时间，反而问题原因没有深入思考，导致东弄西弄一下，试图用碰运气的方式来解决问题方式终究还是有瓶颈的，或许是碰运气的方式曾经取得的成果对现在行为抉择还是产生的一定的影响，其实在陷入僵局之后的思考基本已经锁定了问题，就算是没有解决问题的彼时，心里对故障的排除已经基本有底了，最后的解决也只是水到渠成而已。</p><p>References:</p><p><a href="https://linuxconfig.org/how-to-configure-static-ip-address-on-ubuntu-18-04-bionic-beaver-linux">How to configure static IP address on Ubuntu 18.04 </a></p><p><a href="https://askubuntu.com/questions/1034711/how-to-enable-netplan-on-ubuntu-server-upgraded-from-16-04-to-18-04">How to enable netplan on ubuntu server upgraded from 16.04 to 18.04</a></p><p><a href="https://blog.csdn.net/qq_43222384/article/details/90314297">ubuntu18.04 内核自动更新导致驱动掉了</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> 故障排查 </tag>
            
            <tag> linux内核 </tag>
            
            <tag> grub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>改变与懒惰：主观能动性讨论</title>
      <link href="sui-bi/gai-bian-yu-lan-duo/"/>
      <url>sui-bi/gai-bian-yu-lan-duo/</url>
      
        <content type="html"><![CDATA[<p>　　前段时间，大概是在暑假期间吧，似乎因为看了很多动漫，仍然沉迷在学生时代的火热的夏天气息中。是呀！美好的夏天，如梦似幻。然而最难过的是，尽管现在的我无论想要如何去追寻这种夏日的味道，哪怕只是夏天的尾气而已，我却仍然无比清晰的认识到，自己的暑假早已经一去不复返了。这让自己陷入到一个两难的境地，一面渴望夏日的美好，一面却又警醒自己去接受事实，既无法肆意去做自我，也没办法彻底的放弃，去追寻所谓的成熟，就特别的拧巴。至于为什么总是要自己接受自己不断长大的事实，我也不甚明了，仿佛跟自己说的多了，就真的成长了一样。可能唯一让自己神伤的就只是不断变老的事实吧，或许告诉自己去年的自己跟现在的自己其实没什么太多变化和进步，那么多少有点对不起自己不断老去的时间，所以滋生出这样心理暗示，说是聊以慰己也好，说是对自己的失望继而产生的愧疚也好，总之，都是一份对自己自甘堕落，原地踏步的一种惩罚吧！所以，带着这份不甘，不明就里的开始了这份夏日的无聊幻想。</p><p><img src="IMG_9373.jpeg" alt="2020-07-31"></p><p>　　清楚记得是在7月31日，下班从公司回家， 开车走了一条平时从来没有走过的路，天色湛蓝，久违的看到了雾状的云絮，随着落日余晖，呈现出一幅不断变幻的黄昏美景，在这个陌生的却干净的路上走着，有一种异域他乡的漂泊感油然而生。不得不感叹，人有时候就是这么的任性，假如面对突然变化的外部环境，心情不免充满了惊慌和不安；但是一旦在舒适区呆的足够久，却又开始渴望起陌生的神秘起来。所以，在那一刻，我有点爱丽丝梦游仙境的不真实感，才从二次元的幻想出来，又来到这里，心中突然诞生起一股强烈的想要去亲眼见证 命运石之门，青春猪头少年，灌篮高手，你的名字 里面二次元名场景的三次元场景的冲动。这其中当然有自己近段时间一直懒于出游，疫情原因，甚至直接放弃远行的原因，已经快有一年没有认真旅行了，去年这个时候，还沉浸在五月天鸟巢演唱会的期待中。没想到一年后，都快要忘记旅行是什么感觉了，心中只有漠然和麻木。我熟悉这种感觉，当我十年前无法面对自己的时候，我就是这样一步一步麻痹自我，无视自己的感觉，任由时间和偶然的未来来试图冲淡这份难过，虽然几次试图反抗，但是最后还是来到了自己预想中的，失去了爱和共情能力的终点。等到意识到，这样堕落下去，并不能真正解决这份难过的时候，又过去了好久好久。想要改变的时候，心中的那份激情早已经烟消云散了，当我想要去喜欢的时候，内心却做到真正意义上的毫无波澜，直到再次遇见的二次元，这种状况才好起来。所以此时，我又重新遭遇了这份想要改变，却无法调动自己的内心的尴尬，似乎在这十年间，我无意识间培养出一股冷眼旁观的特质，无论是跟自己是否相关的人和事，习惯性的把自己置身事外，试图冷静分析利弊得失，却完全丧失了<strong>意识主观能动性</strong>，这股自己窃以为最核心和宝贵的动力，我明白，我所尊崇的理性，作为绝对意义上的中立，统治了自己的是非观，但是一旦要去自己去亲自上阵的时候，光有理性，总是感觉差点什么东西，实践起来也并不是那么得心应手，甚至还有点举步维艰。总之，无论做什么，我缺乏一种，“当我在做这件事，我在做什么的” 的自觉性。记得不久前，自己还有强烈的这种动力想要实现梦想，却在错失良机之后，陷入长久的沉寂。当工作从长远来看不受自己控制的变得愈加明朗起来的时候，自己陷入了对未来的强烈不安之中。造成如今的局面，都是有点自己自暴自弃的成分在里面，屏蔽自己感情，活在当下，试图忘掉自己的梦想，成为了如今自己生活的主题。自我屏蔽，前面已经聊过，被证实只是一种自我麻醉而已，跟逃避没什么两样，对于解决问题，没什么卵用；活在当下，虽然并没有什么不好，但是作为浑浑噩噩度日的借口，时间久了，自己也有点不好意思起来；试图忘记梦想，真的是逃避之集大成者。兜兜转转，最后还是来到了需要认真面对自己的这个路口，时间只不过让自己忘却了些许忧伤，积攒了一点可怜的勇气而已。如果自己没有根本性的转变和思想觉悟，我并不认为自己能有所突破。</p><p>　　所以，回到，发现问题，认识问题，解决问题 的模式 ！</p><p>发现问题：    </p><p>​    <strong><em>生活缺乏 目标，激情和动力！</em></strong></p><p>认识问题：</p><p>　　按照 身边人面对这个问题的惯常思路，没有动力，给压力就好了。我并不否认这种方法的有效性，但是我一方面不认可这种方法，另一方面我本身也不是很习惯这种被迫做事的急促感，我认为扼杀了创意和生活的乐趣。曾经我也讨论过这个问题，得出的结论是，我并不适合这种压迫产生的动力；但另一方面，自己却由于过分懒散，反而落入了完全忘记自己的目标是什么的另一个极端。这样的后果就是，摸鱼到一定程度，自己甚至都开始厌恶这样无所事事的日子，想要找点事情来分散下多余的脑力，这个时候甚至反而觉得有点儿事做还挺有意思的。很遗憾的是，目前自己正处于这种状态，由于工作内容对自己来说比较容易，自己也没有适时的给自己足够的挑战，10月份以来，自己一直处于这种慵懒的状态，所以整个月的都处于基本停止的状态。仔细想来，应该是上次的面试结束之后，由于非技术原因没拿到offer，尽管情绪上来说没什么影响，但是准备算法OJ的积极性有点下降，努力想要认真刷算法题的这个弦突然就松下来了，这才导致后续很多事情都开始丧失积极性直到彻底懒得去做了。从这个角度来说，自己在战略上，还是需要足够的压力来推进自己去实践，否则很容易落入偷懒的陷阱之中。譬如，每天的总结，每周的反思，都在那之后渐渐都没有了；细想之下，我都是用，不做也没什么，晚点做也一样这种轻描淡写的借口一带而过。想来，自己也足够鸡贼，在缺乏意识驱动的事情上，是没有感情的理性机器，在这种需要理性监督的日常惯例上，却贪图一时的便利，自欺欺人起来。说到这里，猛然发现自己有一个很坑爹的问题就是，每当某些事做的很好的时候，心里洋溢着开心和满足，发自内心的对自己说，原来认真一把，也很有意思很好玩的，信誓旦旦的对自己说，记住这种感觉，明天也要这样加油努力。 转头就把这些警醒忘得一干二净，反而在满足感的驱使下开始完全放松的日子。从根源上来讲，自己这个问题应该是，目标太小，易于满足；然而另一方面，为了从长远角度保证计划的实施同时保持生活的乐趣，避免陷入某天计划没完成，直接导致后续计划的崩盘，本来就没有给每天安排很多任务，所以这样就陷入了一种矛盾的状态。 面对这个事情，我想起来之前 看到的<strong>延迟满足</strong>这个词，当时看的就觉得虽然意思明白，但是实践起来是什么样子，没有什么概念。现在或许能有点明白，应该是，满足感留在完成那一天，但是再接再厉的警醒，还是需要时刻提醒自己，在整个规划中，自己走到哪一步了，有了今天 的成果，明天该怎么更进一步，这种不断进步的渴求，才是敦促自己前进的最原始的动力。</p><p>解决问题：</p><p>　　用认真的态度过好每一天，而不是得过且过的自我敷衍。这其实是自己一直没太关注的，总是试图用全局的计划和美好的理想来敦促自己，发现仍然过不好每一天的生活。渴望进步的决心，是绝对不会变的，但是认真的态度，特别是每天都坚持保持这种精神，实际是不容易办到的，而且偶尔的放松，实际上对自己有很大影响，因为自己特别容易自暴自弃，接受那些不受控制或者并非属于自身原因的变化，享受当下认真带来的满足和乐趣，放眼明日需要改变和努力的方向，过好自己的每一天，我想也不会有那种缺乏目标，激情和动力的乏味感觉了吧！</p><p>　　说到这里，这篇关于懒惰和改变的讨论应该已经得到答案了。但是彼时对夏日的怀恋和异域的沉迷并没有得到解决，似乎一场旅行是非常有必要的，虽然真的很想去日本旅游，遗憾的是年末疫情复发可能对出国旅行产生很大的影响，不过究竟是什么程度的影响，自己也并没有做过多考察，剩下几个月的时间，自己还是应该鼓起干劲，多做一些信息上的搜集和准备，努力规划一场美好的动漫朝圣之旅。</p><p><img src="2020-07-31.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要写博客？</title>
      <link href="sui-bi/my-first-blog/"/>
      <url>sui-bi/my-first-blog/</url>
      
        <content type="html"><![CDATA[<p>　　我有一个很奇特的习性，就是无论做任何事情，喜欢起个大早，却赶了个晚集；究其原因，想来应该是一直以来困扰我的慵懒毛病，做什么事情都是三分钟热度，热情消退之后，很多设想都被抛诸脑后，结果留下一地鸡毛。曾经几度自我挣扎过，甚至几度接近成功，但是每次达到一定高度之后，很快就如弹簧般反弹到最初的起点。从这个角度分析，我想应该是每次跟自我的斗争时候，都没有树立一个明显的目标，结果在对付完心中的对自己的愧疚和不甘之后，很快的便沉溺于自我满足的情绪中，直到意识到自己是不是该做点什么来拯救一下自己。写博客的设想也是如此，曾经看到过很多博主在序言中论述自己为何写博客，很多文字和想法都对自己很有感触，觉得自己也完全可以学习这种做法，努力提升自己，改变自己。这就有了第一次想写blog的想法，来自于模仿，然而遗憾的是，行动力太差，这个设想也仅仅停留在设想而已；随后无论是写日记，记录此时自己的所思所想，学习笔记，工作笔记，算法刷题的小结，看书感想，电影鉴赏，动漫观后感，旅游记录等，其实都零零碎碎都产生了很多碎片化的记录，只是没有按照合理的结构组织成一份文章而已。真正意识到这种记录的整理是非常非常有必要的是在看自己的相册的时候，恍惚间自己居然已经做过这么多事情，留下了这么多图片记录，自己居然完全不记得了，而且看自己相册的过程是一个跟理想中的美好回忆完全不同的艰难历程，其中充斥着废图，毫不相干的图片，甚至毫无意义，不明所以的照片，严重干扰了自己的回忆活动，尽管iOS很贴心的用算法整理出了一些有主题的照片合辑，但是仍然杯水车薪，难以从根本上解决这个问题。每次想到，曾经经历过如此重要的经历，尽管有文字，图片甚至视频记录下来了，但是却散落在这些毫不相干的地方，自己只是一味的寻求记录，仿佛有着疯狂的收集癖的人一样，疯狂的记录着自己周遭的一切，却完全忘记了要去用心去感受和回忆经历的那些重要时刻。等到自己忘记的差不多的时候，才偶然发现有这么一个记录存在，然而这个时候再回忆的时候，发现自己心里毫无涟漪，似乎在看一个跟自己无关的人的过去那样欣赏着这些破碎的记录，每次想到这里，感觉异常可惜。</p><img src="Euphonium_Movie_2nd_KV.jpg" width="50%" height="50%"><p>　　所以便有了想要通过写blog的方式来记录下自己的经历的想法，遗憾的是，这个虽然不算很复杂的事情，自己也一直没有提上日程，直到近一年来，由于疫情的原因，开始有了足够的时间来思考这个事情，这期间也培养了自己做规划，做总结并不断完善的习惯，这多亏了非常厉害的博主<a href="http://freemind.pluskid.org/">pluskid/freemind</a> 的一篇<a href="http://freemind.pluskid.org/misc/knowledge-accumulate/">关于知识整理，积累与记忆</a> 的优秀文章，恰逢其时的解决了我关于知识和记忆的一些困扰，所以很顺利的便开始学习和实践起来，收到了很不错的效果，如果不是由于自己间歇性的懒惰，应该还能做的更好。（关于这位厉害的博主，之前也写过不少文章，活成自己希望的样子，每次都能恰到好处的激励自己，以后一定要把这些文章都挪到这里来）</p><p>　　在囤积了足够多的文章之后，也到了要准备把这些记录整理输出到页面上的时候了，没想到这个进程被我从7-8月份生生拖到了十月份，才开始着手技术选型和部署相关的事宜，虽然从定制角度，wordpress是最初的首选，但是起数据库的管理方式对于文章为主的组织方式还是觉得有点不习惯，再则很早以前小试过Hexo，上手起来还是很舒适，奇怪的是，熟悉的概念和框架，也还是花了整个下午的时间去测试，磕磕碰碰的，虽然勉强完成了，但是潜意识里对自己的高要求和鄙夷，多少还是让这个成果来的不是那么爽快。我觉得是背负了之前曾经学过这个负担，所以测试途中的任何波折都会成为一个自我否定的理由。之前也讨论过，自己总是潜意识的用否定和打压来给自己前进的动力，但是为什么一直是负反馈的逼迫，而不是正反馈的鼓励，我不得而知，仿佛给压力是前进的唯一动力，而现在我意识到这种方法并不总是有效，反而很影响心情和状态的时候，决心想要改变这个势态。从部署Blog的过程中观察到的这个小心翼翼和不自信的事实，自己这方面还有很大的进步空间。此处就不多展开了，总之，大体的框架都布置好了，只剩下文章了。在选择技术框架的时候，有个回答很好，无论是什么blog框架，坚持写作才是最重要的。提醒了我，不断的优化和改进才是完美进化的捷径，一步到位只是完美主义者的美妙幻想而已。尽管只完成了hexo和主题的最基础的修改，但是起码最重要的文章已经准备就绪，其他的细节以后一步一步的改进和优化。</p><p><img src="relife-1.png"></p><p>　　絮絮叨叨的说了很多，好像都没有触及到自己的blog想要记录的关键，想起不久前看的一部番Relife 中的一个问题，既然认定了青春会结束，恋爱会终结，毕业之后，这一切都烟消云散，为什么此刻要执着于对方呢？这一切的意义是什么？ 我和主人公想的是一样的，就是这些对黄金时代美好事物的追求，会成为生命中最珍贵的回忆，就算最后可能一无所获，但是曾经那份雄心壮志，觉得自己无所不能的勇气，以后和最珍惜的伙伴的度过那些美好岁月，都是未来路上自己所能依仗的一切了。自己早已不复黄金岁月，每每想起，总是心酸无奈，五味杂陈。很多事情都渐渐遗忘，我无法忍受自己面对这种消逝，却选择无动于衷，总是想方设法的要留住。最终，发现还是用文字记录下来，才是对自己最好的一种交代，因为用心在写，用心在看。幸运的是，自己并没有忘记自己的梦想和追求，有很多事很多计划都亟待自己去实现，戒骄戒躁，更要戒怠惰，享受前进途中的种种风景，毕竟人生路上还有很多美好等着自己去探索，怎能因为这些微不足道的原因妨碍自己去追求和享受呢？</p><p><img src="relife-2.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="test/hello-world/"/>
      <url>test/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
